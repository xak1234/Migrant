
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Migrantopoly - Online Multiplayer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            padding: 20px;
            color: #ecf0f1;
            position: relative;
            overflow-x: hidden;
            font-family: 'Inter', Arial, sans-serif;
            min-height: 100vh;
            background: #2c3e50;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* body::before is intended for a subtle background texture or effect.
           Its content is empty, so it should not display any text itself. */
        body::before {
            content: ''; 
            position: fixed;
            top: 50%;
            left: 50%;
            width: 1200px;
            height: 700px;
            transform: translate(-50%, -50%);
            background-color: rgba(255,255,255,0.05);
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.18;
            pointer-events: none;
            z-index: 0;
            mix-blend-mode: lighten;
        }

        .main-content {
          position: relative;
          z-index: 3; /* Ensures main content is above body::before and overlay */
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          min-height: 100vh;
          width: 100%;
          padding-top: 20px;
          padding-bottom: 20px;
          background-color: #2c3e50; /* Added to ensure opacity over potential stray body content */
        }

        #player-setup-screen, #online-setup-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #2c3e50;
            padding: 30px 40px;
            border-radius: 12px;
            border: 2px solid #7f8c8d;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
            color: #ecf0f1;
            text-align: center;
            width: auto;
            max-width: 450px;
        }
        #player-setup-screen h2, #online-setup-screen h2 {
            color: #1abc9c;
            margin-top: 0;
            margin-bottom: 25px;
            font-size: 1.8em;
        }
        .setup-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 18px;
        }
        #player-setup-screen label, #online-setup-screen label {
            font-size: 1em;
            margin-right: 15px;
            flex-basis: 40%;
            text-align: left;
        }
        #player-setup-screen select, #online-setup-screen select, #online-setup-screen input {
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size: 1em;
            flex-grow: 1;
        }
        #online-setup-screen input {
            width: calc(100% - 22px); /* Account for padding */
        }
        #player-setup-screen button, #online-setup-screen button {
            background-color: #27ae60;
            color: white;
            padding: 12px 25px;
            font-size: 1.1em;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 15px;
            margin-right: 10px;
        }
        #player-setup-screen button:last-child, #online-setup-screen button:last-child {
            margin-right: 0;
        }
        #player-setup-screen button:hover, #online-setup-screen button:hover {
            background-color: #2ecc71;
        }
         #online-setup-screen button.secondary {
            background-color: #3498db;
        }
        #online-setup-screen button.secondary:hover {
            background-color: #2980b9;
        }
        #player-setup-message, #online-setup-message {
            color: #f1c40f;
            font-size: 0.9em;
            margin-top: 15px;
            min-height: 1.2em;
        }
        #game-id-display {
            margin-top: 15px;
            font-size: 1.1em;
            color: #1abc9c;
        }
        #game-id-display span {
            font-weight: bold;
            background-color: #34495e;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
         #user-id-display {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.5);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            z-index: 1000;
        }


        #game-container, #game-info-area, #board-container {
            position: relative;
            z-index: 1;
        }

        #game-container {
            display: none; /* Initially hidden */
            flex-wrap: wrap;
            justify-content: center;
            gap: 25px;
            padding-top: 0px;
        }

        #board-container {
            display: grid;
            grid-template-columns: 100px repeat(8, 70px) 100px;
            grid-template-rows: 100px repeat(8, 70px) 100px;
            border: 3px solid #7f8c8d;
            width: 760px; /* Fixed width */
            height: 760px; /* Fixed height */
            position: relative;
            background-color: rgba(52, 73, 94, 0.68);
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            overflow: visible;
            margin-top: 20px;
            /* Add background image for the board */
            background-image: url('migrant3.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        #card-decks-center {
            display: none; /* Hide the center image container, since background is now on the board */
        }
        #center-board-image { display: none; }
        .card-deck {
            width: 110px;
            height: 60px;
            background: linear-gradient(135deg, #f7ca18 60%, #f1c40f 100%);
            border: 2px solid #7f8c8d;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.18);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1em;
            font-weight: bold;
            color: #2c3e50;
            cursor: pointer;
            user-select: none;
            transition: transform 0.1s;
        }
        .card-deck.opportunity {
            background: linear-gradient(135deg, #6dd5ed 60%, #2193b0 100%);
            color: #fff;
        }
        .card-deck.welfare {
            background: linear-gradient(135deg, #f7ca18 60%, #f1c40f 100%);
            color: #2c3e50;
        }
        .card-deck:active {
            transform: scale(0.96);
        }

        #on-board-card-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 280px;
            min-height: 190px; /* Use min-height to allow content to expand */
            background-color: #fdf5e6;
            border: 3px solid #c0392b;
            border-radius: 15px;
            box-shadow: 0 6px 22px rgba(0,0,0,0.35);
            z-index: 5;
            display: none; /* Initially hidden */
            flex-direction: column;
            align-items: center;
            justify-content: space-around;
            padding: 15px;
            box-sizing: border-box;
            text-align: center;
            color: #2c3e50;
        }

        #on-board-card-display h4 {
            margin: 5px 0;
            font-size: 1.4em;
            color: #c0392b;
            font-weight: bold;
        }

        #on-board-card-display p {
            margin: 10px 0; /* Increased margin */
            font-size: 1em;
            line-height: 1.45;
            overflow-y: auto;
            max-height: 100px;
            width: 100%;
            color: #34495e;
        }
        #on-board-card-ok-button { /* Specific ID for this OK button */
            background-color: #27ae60;
            margin-top: 10px;
        }
        #on-board-card-ok-button:hover {
            background-color: #2ecc71;
        }


        .space {
            border: 1px solid #7f8c8d;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 10px;
            position: relative;
            padding: 3px;
            box-sizing: border-box;
            background-color: #4a6378;
            color: #ecf0f1;
            border-radius: 5px;
        }
        .space .name {
            font-weight: bold;
            font-size: 10px;
            margin-bottom: 2px;
            line-height: 1.2;
        }
        .space .price {
            font-size: 9px;
            color: #bdc3c7;
            font-weight: normal;
        }
        .space .owner-indicator {
            width: 90%;
            height: 6px;
            margin-top: 3px;
            background-color: transparent;
            border-radius: 3px;
            position: absolute;
            bottom: 3px;
            left: 5%;
        }
         .space .development-indicator {
            font-size: 12px;
            color: #fff;
            position: absolute;
            top: 15px;
            width: 100%;
            text-align: center;
            line-height: 1;
            text-shadow: 0 0 2px #000;
        }
        .space .sub-label {
            font-size: 10px;
            color: #e74c3c;
            font-weight: bold;
            margin-top: 2px;
            letter-spacing: 0.04em;
            text-align: center;
            line-height: 1.1;
        }

        .corner {
            font-weight: bold;
            background-color: #527a78;
        }
        .corner .name {
            font-size: 16px !important;
            color: #e74c3c !important;
            font-weight: bold !important;
            margin-top: 0;
        }
        .corner .name.detention-center-name {
            margin-top: 35px;
            position: relative;
            z-index: 1;
        }


        .property .color-bar {
            width: 100%;
            height: 12px;
            border-bottom: 1px solid #7f8c8d;
            position: absolute;
            top: 0;
            left: 0;
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
        }
        .space.property .name { margin-top: 14px; }

        .welfare .name, .opportunity .name, .tax .name, .payout .name, .neutral:not(.corner) .name {
            margin-top: 0;
        }
        
        .set-property {
            background-color: #303F4D;
        }
        .set-property .name {
            margin-top: 0;
            font-size: 11px;
            font-weight: bold;
        }


        .brown .color-bar { background-color: #8B4513; }
        .light-blue .color-bar { background-color: #ADD8E6; }
        .pink .color-bar { background-color: #FFC0CB; }
        .orange .color-bar { background-color: #FFA500; }
        .red .color-bar { background-color: #FF0000; }
        .green .color-bar { background-color: #008000; }


        .player-token {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            position: absolute;
            border: none;
            font-size: 26px;
            line-height: 28px;
            text-align: center;
            background: none;
            z-index: 10;
            user-select: none;
            pointer-events: none;
        }

        #game-info-area {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #player-info, #controls, #card-display-container, #game-status-message-container, #develop-property-container {
            padding: 15px;
            background-color: #34495e;
            border: 1px solid #7f8c8d;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            color: #ecf0f1;
        }
        #player-info div { margin-bottom: 8px; font-size: 14px; }
        #card-message { margin-bottom: 10px; font-size: 14px; }

        button {
            padding: 10px 15px;
            font-size: 14px;
            cursor: pointer;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 6px;
            transition: background-color 0.2s;
            margin-top: 5px;
            margin-right: 5px;
        }
        button:last-child { margin-right: 0; }
        button:hover {
            background-color: #c0392b;
        }
        button:disabled {
            background-color: #7f8c8d;
            color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .main-action-button {
            display: block !important;
            margin: 8px auto !important;
        }

        #end-turn-button {
            background-color: #d35400;
        }
        #end-turn-button:hover {
            background-color: #e67e22;
        }
        #develop-property-button {
            background-color: #2980b9;
        }
        #develop-property-button:hover {
            background-color: #3498db;
        }


        #card-display-container, #develop-property-container {
            display: none; /* Initially hidden */
        }
        #card-display-container h3, #develop-property-container h3 {
             margin-top: 0; color: #1abc9c;
        }

        #detention-actions button {
            background-color: #f39c12;
            margin-right: 5px;
        }
        #detention-actions button:hover {
            background-color: #e67e22;
        }
        #game-status-message {
            font-weight: bold;
            color: #e74c3c;
            min-height: 20px;
        }
        #pre-game-roll-area button {
            background-color: #f1c40f;
            color: #2c3e50;
        }
        #pre-game-roll-area button:hover {
            background-color: #f39c12;
        }
        #pre-game-roll-results { margin-top: 10px; font-size: 13px; }
        #develop-property-options button {
            display: block;
            width: calc(100% - 10px);
            margin-bottom: 8px;
            background-color: #2980b9;
        }
        #develop-property-options button:hover {
            background-color: #3498db;
        }

        .space.dole-space .name {
            font-size: 26px !important;
            font-weight: bold;
            letter-spacing: 0.08em;
            color: #fff !important;
            text-transform: uppercase;
            position: absolute;
            top: 15px;
            left: 0;
            width: 100%;
            text-align: center;
            transform: rotate(-36deg);
            transform-origin: center center;
            white-space: nowrap;
            pointer-events: none;
        }
        .dole-sign {
            position: absolute;
            bottom: 8px;
            right: 8px;
            font-size: 28px;
            color: #f1c40f;
            font-weight: bold;
            z-index: 3;
        }

        .space.red-boardname .name {
            color: #e74c3c !important;
            font-weight: bold;
        }
        .space.yellow-boardname .name {
            color: #f1c40f !important;
            font-weight: bold;
        }


        .player-highlight {
            animation: player-highlight-flash 1s;
            background: #ffeaa7;
            color: #222d3a !important;
        }
        @keyframes player-highlight-flash {
            0% { background: #ffeaa7; }
            60% { background: #ffeaa7; }
            100% { background: transparent; }
        }

        #money-flash {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 7vw;
            font-family: 'Impact', 'Arial Black', Arial, sans-serif;
            color: #e74c3c; /* Red for loss, maybe green for gain later */
            font-weight: bold;
            opacity: 0;
            pointer-events: none;
            z-index: 1000;
            text-shadow: 2px 2px 16px #000, 0 0 32px #fff;
            transition: opacity 0.2s;
        }
        #money-flash.show {
            opacity: 1;
            animation: money-flash-pop 0.7s;
        }
        @keyframes money-flash-pop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.7); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            60% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.7); }
        }

        .detention-bars {
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            height: 32px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            z-index: 2;
        }
        .detention-bar {
            width: 4px;
            height: 100%;
            background: #111;
            border-radius: 2px;
            opacity: 0.85;
        }
        .detention-arrow {
            position: absolute;
            bottom: 6px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2em;
            color: #e67e22;
            font-weight: bold;
            z-index: 2;
            pointer-events: none;
            text-shadow: 1px 1px 6px #000, 0 0 8px #fff;
        }

        #current-turn-display {
            text-align: center;
            width: 100%;
            color: #ecf0f1;
            font-weight: bold;
            padding-bottom: 5px;
        }
        #current-turn-display.pulsing { /* New class for pulsing effect */
            font-size: 1.2em; /* Slightly larger font */
            animation: pulse-text-animation 1.5s infinite ease-in-out;
        }
        @keyframes pulse-text-animation { /* New animation for current turn text */
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        #game-status-message-container {
            text-align: center;
        }
        #uk-gov-status {
            padding: 12px;
            background: #222d3a;
            border: 1px solid #7f8c8d;
            border-radius: 8px;
            color: #f7ca18;
            font-weight: bold;
            text-align: center;
        }
         #uk-gov-status-container {
            width: 100%;
            box-sizing: border-box;
        }


        #pre-game-roll-area {
            display: none; /* Initially hidden */
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .overlay {
          position: fixed;
          top: 0; left: 0; right: 0; bottom: 0;
          background: rgba(24,28,36,0.48);
          z-index: 2; /* Ensure it's above body::before but below main content modals */
          pointer-events: none;
        }


        .die {
            width: 30px;
            height: 30px;
            border: 1px solid #ecf0f1;
            background-color: #fff;
            color: #2c3e50;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .dice-animation {
            animation: dice-roll-effect 0.4s ease-out;
        }
        @keyframes dice-roll-effect {
            0% { transform: scale(1) rotate(0deg); opacity: 0.5; }
            25% { transform: scale(1.3) rotate(90deg); opacity: 0.75; }
            50% { transform: scale(1.1) rotate(180deg); opacity: 1; }
            75% { transform: scale(1.3) rotate(270deg); opacity: 0.75; }
            100% { transform: scale(1) rotate(360deg); opacity: 1; }
        }

        .token-hop { /* General hop for landing, can be reused or a new one for steps */
            animation: hop-animation 0.3s ease-out;
        }
        @keyframes hop-animation {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            30% { transform: translateY(-35px) scale(1.25); opacity: 0.9; }
            60% { transform: translateY(-35px) scale(1.25); opacity: 0.9; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }

        .token-arrive-step { /* Short animation for each step */
            animation: arrive-step-animation 0.15s ease-out;
        }
        @keyframes arrive-step-animation {
            0% { transform: scale(0.8) translateY(2px); opacity: 0.7; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }

        #dice-display-master-container {
            min-height: 32px;
            text-align: center;
            margin-bottom: 8px;
        }
        #actual-dice-faces {
            display: inline-flex;
            gap: 5px;
            margin-left: 5px;
            vertical-align: middle;
        }
        #dice-total-display-text {
            margin-left: 8px;
            font-weight: bold;
        }

        .token-flash {
            animation: token-flash-animation 0.7s infinite alternate;
        }
        @keyframes token-flash-animation {
            0% { opacity: 1; transform: scale(1.1); filter: drop-shadow(0 0 6px currentColor) drop-shadow(0 0 3px #fff); }
            100% { opacity: 0.6; transform: scale(1); filter: drop-shadow(0 0 3px currentColor); }
        }
        .token-move-flash {
            animation: token-move-flash-animation 0.2s infinite;
        }
        @keyframes token-move-flash-animation {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 1001; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background-color: #2c3e50;
            margin: auto;
            padding: 25px 35px;
            border: 1px solid #7f8c8d;
            border-radius: 10px;
            width: 80%;
            max-width: 450px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            text-align: center;
        }
        .modal-content h3 {
            color: #1abc9c;
            margin-top: 0;
        }
        .modal-content p {
            margin-bottom: 20px;
        }
        .modal-content button {
             background-color: #e74c3c;
        }
         .modal-content button:hover {
             background-color: #c0392b;
        }

</style>
</head>
<body>
  <div class="overlay"></div>
  <div id="user-id-display">Your User ID: <span id="local-user-id">Not Signed In</span></div>
  <div class="main-content">
    <div id="online-setup-screen"> <h2>Migrantopoly Online</h2>
        <div class="setup-row">
            <label for="player-name-input">Your Name:</label>
            <input type="text" id="player-name-input" placeholder="Enter your name" value="Player">
        </div>
        <div class="setup-row">
            <label for="game-id-input">Game ID (for joining):</label>
            <input type="text" id="game-id-input" placeholder="Enter Game ID to join">
        </div>
        <button id="join-game-button">Join Game</button>
        <hr style="width:80%; margin: 20px 0; border-color: #7f8c8d;">
        <div class="setup-row">
            <label for="num-players-online-select">Total Players in Game:</label>
            <select id="num-players-online-select">
                <option value="2" selected>2 Players</option>
                <option value="3">3 Players</option>
                <option value="4">4 Players</option>
            </select>
        </div>
        <button id="create-game-button">Create New Game</button>
        <p id="online-setup-message"></p>
        <div id="game-id-display" style="display:none;">
            Share this Game ID: <span id="generated-game-id" title="Click to copy"></span>
        </div>
    </div>

    <div id="player-setup-screen" style="display: none;"> <h2>Player Setup (Local)</h2>
        </div>

    <div id="game-container" style="display: none;">
        <div id="board-container">
            </div>

        <div id="game-info-area">
            <div id="player-info">
                </div>

            <div id="controls">
                <h3 id="current-turn-display">Current Turn: Player 1</h3>
                <div id="pre-game-roll-area" style="display:none;">
                    <h4>Determine Starting Player</h4>
                    <button id="pre-game-roll-button">Roll to Start</button>
                    <div id="pre-game-roll-results"></div>
                </div>

                <div id="dice-display-master-container">
                    <span>Dice: </span>
                    <div id="actual-dice-faces">
                        <div class="die" id="die-face-1">--</div>
                        <div class="die" id="die-face-2">--</div>
                    </div>
                    <span id="dice-total-display-text"></span>
                </div>
                <button id="roll-dice-button" style="display:none;">Roll Dice</button>
                <button id="end-turn-button" style="display:none;">End Turn</button>

                <div id="other-actions-container" style="text-align: center; margin-top: 5px;">
                    <button id="develop-property-button" style="display:none;">Develop Property</button>
                    <button id="buy-property-button" style="display:none;">Buy Property (Â£<span id="buy-property-price"></span>)</button>
                </div>
                <div id="detention-actions" style="margin-top: 10px;">
                    </div>
            </div>

            <div id="develop-property-container" style="display:none;">
                <h3 id="develop-property-name">Develop Property</h3>
                <div id="develop-property-options">
                    </div>
                <button id="close-develop-button">Close</button>
            </div>


            <div id="card-display-container" style="display:none;">
                <h3 id="card-type-title">Card Drawn</h3>
                <p id="card-message"></p>
                <button id="card-ok-button">OK</button>
            </div>

            <div id="game-status-message-container">
                <h4>Game Status:</h4>
                <p id="game-status-message">Waiting for game to start...</p>
            </div>

            <div id="uk-gov-status-container">
                <div id="uk-gov-status">
                    UK Gov: Â£<span id="uk-gov-cash">20000</span>
                </div>
            </div>
        </div>
    </div>

    <div id="money-flash"></div>

    <div id="message-modal" class="modal">
        <div class="modal-content">
            <h3 id="modal-title">Notification</h3>
            <p id="modal-message">This is a sample message.</p>
            <button id="modal-ok-button">OK</button>
        </div>
    </div>

  </div>

    <script type="module">
        // --- Firebase Configuration ---
        const userProvidedFirebaseConfig = {
            apiKey: "AIzaSyARzlfhH_AC0YTxJ5fKvhz_SPDq1r6mWPA",
            authDomain: "migrantopoly.firebaseapp.com",
            projectId: "migrantopoly",
            storageBucket: "migrantopoly.firebasestorage.app",
            messagingSenderId: "649348280586",
            appId: "1:649348280586:web:2bd3be4d2de84c0ea8caf3",
            measurementId: "G-1TMRSC6KL8"
        };
        // Use global config if available, otherwise fallback to userProvided (or your defaults)
        const firebaseConfigToUse = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : userProvidedFirebaseConfig;
        
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Firebase SDK imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, serverTimestamp, arrayUnion, arrayRemove, runTransaction, writeBatch, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js"; // Analytics can be added if needed

        let db, auth, currentUserId = null, localPlayerName = '';
        let currentGameId = null; 
        let unsubscribeGameState = null; 
        let localGameData = {}; // Local cache of the game state
        let aiAddTimerId = null; // Timer for adding AI players
        // let analytics; // Declare analytics if you plan to use it

        // --- DOM Elements ---
        const onlineSetupScreen = document.getElementById('online-setup-screen');
        const gameContainer = document.getElementById('game-container');
        const playerNameInput = document.getElementById('player-name-input');
        const gameIdInput = document.getElementById('game-id-input');
        const createGameButton = document.getElementById('create-game-button');
        const joinGameButton = document.getElementById('join-game-button');
        const numPlayersOnlineSelect = document.getElementById('num-players-online-select');
        const onlineSetupMessage = document.getElementById('online-setup-message');
        const gameIdDisplayDiv = document.getElementById('game-id-display');
        const generatedGameIdSpan = document.getElementById('generated-game-id');
        const localUserIdSpan = document.getElementById('local-user-id');

        const boardContainer = document.getElementById('board-container');
        const playerInfoDiv = document.getElementById('player-info');
        const rollDiceButton = document.getElementById('roll-dice-button');
        const endTurnButton = document.getElementById('end-turn-button');
        const buyPropertyButton = document.getElementById('buy-property-button');
        const buyPropertyPriceSpan = document.getElementById('buy-property-price');
        const developPropertyButton = document.getElementById('develop-property-button');
        const diceFace1Elem = document.getElementById('die-face-1');
        const diceFace2Elem = document.getElementById('die-face-2');
        const diceTotalDisplayText = document.getElementById('dice-total-display-text');
        const currentTurnDisplay = document.getElementById('current-turn-display');
        const cardDisplayContainer = document.getElementById('card-display-container');
        const cardTypeTitle = document.getElementById('card-type-title');
        const cardMessageP = document.getElementById('card-message');
        const cardOkButton = document.getElementById('card-ok-button');
        const detentionActionsDiv = document.getElementById('detention-actions');
        const gameStatusMessageP = document.getElementById('game-status-message');
        const preGameRollArea = document.getElementById('pre-game-roll-area');
        const preGameRollButton = document.getElementById('pre-game-roll-button');
        const preGameRollResultsDiv = document.getElementById('pre-game-roll-results');
        const developPropertyContainer = document.getElementById('develop-property-container');
        const developPropertyNameH3 = document.getElementById('develop-property-name');
        const developPropertyOptionsDiv = document.getElementById('develop-property-options');
        const closeDevelopButton = document.getElementById('close-develop-button');
        const otherActionsContainer = document.getElementById('other-actions-container');
        const ukGovCashSpan = document.getElementById('uk-gov-cash');
        let onBoardCardDisplayDiv, onBoardCardTypeH4, onBoardCardTextP, onBoardCardOkButton; 

        const messageModal = document.getElementById('message-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalOkButton = document.getElementById('modal-ok-button');
        const moneyFlashDiv = document.getElementById('money-flash');


        // --- Game Data Definitions ---
        let initialBoardLayout = [ // This layout will be reformatted
            { id: 0, name: "Dole", type: "go" },
            { id: 1, name: "Tent in Field 1", type: "property", price: 60, rent: [4, 10, 20, 40, 80], color: "brown", groupId: "brown" },
            { id: 2, name: "Welfare Card", type: "welfare" },
            { id: 3, name: "Tent in Field 2", type: "property", price: 80, rent: [8, 10, 20, 40, 80], color: "brown", groupId: "brown" },
            { id: 4, name: "Black Market Sales", type: "set_property", price: 200, rent_base: 200, groupId: "special_set" },
            { id: 5, name: "Fake PIP declined", type: "tax", amount: 100 },
            { id: 6, name: "Tesco Cardboard Skip 1", type: "property", price: 100, rent: [6, 15, 30, 60, 120], color: "light-blue", groupId: "lightblue" },
            { id: 7, name: "Tesco Cardboard Skip 2", type: "property", price: 120, rent: [8, 15, 30, 60, 120], color: "light-blue", groupId: "lightblue" },
            { id: 8, name: "Detention Center", type: "detention_visiting" },
            { id: 9, name: "Payout: Job Seeker's", type: "payout", amount: 100 },
            { id: 10, name: "Tesco Cardboard Skip 3", type: "property", price: 140, rent: [10, 15, 30, 60, 120], color: "light-blue", groupId: "lightblue" },
            { id: 11, name: "Council Highrise 1", type: "property", price: 160, rent: [12, 25, 50, 100, 200], color: "pink", groupId: "pink" },
            { id: 12, name: "Forced Marriage", type: "set_property", price: 200, rent_base: 200, groupId: "special_set" },
            { id: 13, name: "Welfare Card", type: "welfare" }, // Note: this was id 13, will be re-indexed
            { id: 14, name: "Council Highrise 2", type: "property", price: 180, rent: [14, 25, 50, 100, 200], color: "pink", groupId: "pink" },
            { id: 15, name: "Council Highrise 3", type: "property", price: 200, rent: [16, 25, 50, 100, 200], color: "pink", groupId: "pink" },
            { id: 16, name: "Crime Spree !!! Arrest", type: "crime_spree", amount: 150 }, // Updated fine
            { id: 17, name: "Gypsy Estate 1", type: "property", price: 220, rent: [18, 35, 70, 140, 280], color: "orange", groupId: "orange" },
            { id: 18, name: "Opportunity Card", type: "opportunity" }, // Note: this was id 18
            { id: 19, name: "Gypsy Estate 2", type: "property", price: 240, rent: [20, 35, 70, 140, 280], color: "orange", groupId: "orange" },
            { id: 20, name: "Child Wives", type: "set_property", price: 200, rent_base: 200, groupId: "special_set" },
            { id: 21, name: "Fake ID Cards", type: "tax", amount: 100 },
            { id: 22, name: "Gypsy Estate 3", type: "property", price: 260, rent: [22, 35, 70, 140, 280], color: "orange", groupId: "orange" },
            { id: 23, name: "Holiday Inn 1", type: "property", price: 280, rent: [24, 45, 90, 180, 360], color: "red", groupId: "red" },
            { id: 24, name: "Go to Detention Center", type: "go_to_detention" }, // Fine removed from here
            { id: 25, name: "Welfare Card", type: "welfare" }, // Note: this was id 25
            { id: 26, name: "Holiday Inn 2", type: "property", price: 300, rent: [26, 45, 90, 180, 360], color: "red", groupId: "red" },
            { id: 27, name: "Holiday Inn 3", type: "property", price: 320, rent: [28, 45, 90, 180, 360], color: "red", groupId: "red" },
            { id: 28, name: "I Dont speak English", type: "set_property", price: 200, rent_base: 200, groupId: "special_set" },
            { id: 29, name: "Luxury Flat 1", type: "property", price: 350, rent: [30, 60, 120, 240, 480], color: "green", groupId: "green" },
            { id: 30, name: "Opportunity Card", type: "opportunity" }, // Note: this was id 30
            { id: 31, name: "Luxury Flat 2", type: "property", price: 400, rent: [35, 60, 120, 240, 480], color: "green", groupId: "green" },
        ];
        let boardLayout = []; // Will hold the final, re-indexed board layout
        let detentionCenterSpaceId;
        const TENANCY_COST = 50;
        const PR_COST = 150;
        const MAX_TENANCIES = 3;

        const welfareCards = [
            { text: "Child Benefit: Collect Â£100.", action: "collect", amount: 100 },
            { text: "Free Health Service: Gain a health service (worth Â£100).", action: "gainHealthService" },
            { text: "Council House Grant: Collect Â£150.", action: "collect", amount: 150 },
            { text: "Social Worker Fee: Pay Â£50.", action: "pay", amount: 50 },
            { text: "Food Voucher: Collect Â£75.", action: "collect", amount: 75 },
            { text: "Education Grant: Collect Â£120.", action: "collect", amount: 120 },
            { text: "Housing Inspection: Pay Â£20 per tenancy owned.", action: "payPerTenancy", amountPer: 20 },
            { text: "Utility Subsidy: Collect Â£80.", action: "collect", amount: 80 },
            { text: "Legal Aid: Get out of Detention Center free.", action: "getOutOfDetentionFree" },
            { text: "Emergency bowels: Collect Â£100.", action: "collect", amount: 100 },
            { text: "Tax Audit: Pay Â£60.", action: "pay", amount: 60 },
            { text: "Welfare Review: Move to nearest Payout Space.", action: "moveToNearestPayout" }
        ];
        const opportunityCards = [
            { text: "Work Permit Granted: Collect Â£150.", action: "collect", amount: 150 },
            { text: "Language Subsidy: Collect Â£50.", action: "collect", amount: 50 },
            { text: "Community Grant: Collect Â£100.", action: "collect", amount: 100 },
            { text: "Deportation Threat: Go to Detention Center.", action: "goToDetentionDirect" },
            { text: "Legal Homosexuals: Get out of Detention Center free.", action: "getOutOfDetentionFree" },
            { text: "Job Offer: Collect Â£120.", action: "collect", amount: 120 },
            { text: "Housing Voucher: Next estate purchase is 25% off.", action: "housingVoucher" },
            { text: "Free Health Service: Gain a health service (worth Â£100).", action: "gainHealthService" },
            { text: "Bank Manager Shat His Load: Pay Â£50 to the bank.", action: "pay", amount: 50 },
            { text: "Tax Refund: Collect Â£75.", action: "collect", amount: 75 },
            { text: "Dogs Had An Abortion: Collect Â£40 from each player.", action: "collectFromPlayers", amount: 40 },
            { text: "Advance to Go: Collect Â£200.", action: "advanceToGo" }
        ];
        const playerEmojis = ['ðŸ•â€ðŸ¦º', 'ðŸˆ', 'ðŸ˜', 'ðŸ…', 'ðŸ’', 'ðŸ¦Š']; 
        const playerColors = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6', '#1abc9c']; 

        let toneSynth;
        let audioContextStarted = false;
        let currentCardBeingExecuted = null; 
        // let lastRollWasDoublesGlobal = false; // This global seems redundant with per-player doubles tracking

        // --- Utility Functions ---
        function logEvent(message, data = null) {
            if (data) {
                console.log(`[Game Log] ${new Date().toLocaleTimeString()}: ${message}`, data);
            } else {
                console.log(`[Game Log] ${new Date().toLocaleTimeString()}: ${message}`);
            }
        }

        function showMessageModal(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            messageModal.style.display = 'flex';
        }
        modalOkButton.onclick = () => {
            messageModal.style.display = 'none';
        };

        function generateGameId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function reformatBoardLayout() { 
            // This function re-arranges and re-indexes the board spaces.
            // It's important that all clients use the *exact same* logic here.
            const newBoardLocations = [
                { name: "Boat Sank After Renting", type: "set_property", price: 100, rent_base: 100, groupId: "special_set" },
                { name: "People Trafficking", type: "set_property", price: 100, rent_base: 100, groupId: "special_set" },
                { name: "More than 15 children", type: "set_property", price: 100, rent_base: 100, groupId: "special_set" },
                { name: "Crypto Scam from Iqbhal", type: "set_property", price: 100, rent_base: 100, groupId: "special_set" }
            ];
            let tempBoard = [];
            tempBoard.push(initialBoardLayout.find(s => s.id === 0)); 
            const welfareCardOriginalSide1 = initialBoardLayout.find(s => s.id === 2);
            const boatSankProperty = newBoardLocations[0];
            tempBoard.push(initialBoardLayout.find(s => s.id === 1));
            tempBoard.push(boatSankProperty);
            tempBoard.push(initialBoardLayout.find(s => s.id === 3));
            tempBoard.push(initialBoardLayout.find(s => s.id === 4));
            tempBoard.push(welfareCardOriginalSide1);
            tempBoard.push(...initialBoardLayout.filter(s => s.id >= 5 && s.id <= 7));
            tempBoard.push(initialBoardLayout.find(s => s.id === 8)); 
            const peopleTraffickingProperty = newBoardLocations[1];
            const payoutJobSeekersOriginal = initialBoardLayout.find(s => s.id === 9);
            tempBoard.push(peopleTraffickingProperty);
            tempBoard.push(...initialBoardLayout.filter(s => s.id >= 10 && s.id <= 12));
            tempBoard.push(payoutJobSeekersOriginal);
            tempBoard.push(...initialBoardLayout.filter(s => s.id === 13 || (s.id >= 14 && s.id <= 15))); // Corrected to include id 13
            tempBoard.push(initialBoardLayout.find(s => s.id === 16)); 
            const moreThan15ChildrenProperty = newBoardLocations[2];
            const opportunityCardSide3Original = initialBoardLayout.find(s => s.id === 18);
            tempBoard.push(initialBoardLayout.find(s => s.id === 17));
            tempBoard.push(moreThan15ChildrenProperty);
            tempBoard.push(initialBoardLayout.find(s => s.id === 19));
            tempBoard.push(initialBoardLayout.find(s => s.id === 20));
            tempBoard.push(opportunityCardSide3Original);
            tempBoard.push(...initialBoardLayout.filter(s => s.id >= 21 && s.id <= 23));
            tempBoard.push(initialBoardLayout.find(s => s.id === 24)); 
            const cryptoScamProperty = newBoardLocations[3];
            const opportunityCardSide4Original = initialBoardLayout.find(s => s.id === 30);
            tempBoard.push(...initialBoardLayout.filter(s => s.id === 25 || (s.id >= 26 && s.id <= 28))); // Corrected to include id 25
            tempBoard.push(opportunityCardSide4Original);
            tempBoard.push(initialBoardLayout.find(s => s.id === 29));
            tempBoard.push(cryptoScamProperty);
            tempBoard.push(initialBoardLayout.find(s => s.id === 31));
            
            boardLayout = tempBoard.map((space, index) => ({ ...space, id: index })); // Re-index
            
            const dcSpace = boardLayout.find(s => s.name === "Detention Center");
            detentionCenterSpaceId = dcSpace ? dcSpace.id : (boardLayout.find(s => s.type === "detention_visiting")?.id || 8) ; // Fallback if name changes
        }


        // --- Firebase Setup ---
        async function initializeFirebase() {
            // Check if the essential parts of the config are placeholders or missing
            if (!firebaseConfigToUse || !firebaseConfigToUse.apiKey || firebaseConfigToUse.apiKey === "YOUR_API_KEY" || !firebaseConfigToUse.projectId) { 
                onlineSetupMessage.textContent = "Firebase configuration is missing or incomplete. Online features disabled.";
                console.error("Firebase config is not available or incomplete. Please update it in the script with your actual Firebase project details.");
                createGameButton.disabled = true;
                joinGameButton.disabled = true;
                showMessageModal("Setup Error", "Firebase is not configured. Please check the console for details. Online play is unavailable.");
                return;
            }
            try {
                const app = initializeApp(firebaseConfigToUse); 
                db = getFirestore(app);
                auth = getAuth(app);
                // analytics = getAnalytics(app); // Initialize analytics if you plan to use it

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        localUserIdSpan.textContent = currentUserId;
                        logEvent(`Authenticated as: ${currentUserId}`);
                        onlineSetupMessage.textContent = "Connected. Ready to create or join a game.";
                        createGameButton.disabled = false;
                        joinGameButton.disabled = false;
                        // onSnapshot will handle UI updates if already subscribed
                    } else {
                        currentUserId = null;
                        localUserIdSpan.textContent = "Not Signed In";
                        logEvent("User is signed out or initial authentication pending.");
                        
                        if (initialAuthToken) {
                            try {
                                await signInWithCustomToken(auth, initialAuthToken);
                                logEvent("Signed in with custom token.");
                            } catch (error) {
                                console.error("Custom token sign-in error:", error);
                                logEvent("Custom token sign-in failed, trying anonymous.");
                                await signInAnonymously(auth);
                            }
                        } else {
                            logEvent("No custom token, trying anonymous sign-in.");
                            await signInAnonymously(auth);
                        }
                    }
                });
            } catch (error) {
                console.error("Firebase initialization error:", error);
                onlineSetupMessage.textContent = "Error connecting to Firebase: " + error.message;
                showMessageModal("Firebase Error", "Could not initialize Firebase: " + error.message);
                createGameButton.disabled = true;
                joinGameButton.disabled = true;
            }
        }

        // --- Game Management Functions (Create, Join, Sync) ---
        async function handleCreateGame() {
            if (!currentUserId) {
                showMessageModal("Error", "You are not authenticated. Please wait or refresh.");
                return;
            }
            localPlayerName = playerNameInput.value.trim() || `Player ${currentUserId.substring(0,4)}`;
            if (!localPlayerName) {
                showMessageModal("Input Needed", "Please enter your player name.");
                return;
            }

            const newGameId = generateGameId();
            currentGameId = newGameId; 
            const numPlayers = parseInt(numPlayersOnlineSelect.value);

            const gameDocRef = doc(db, "games", newGameId);

            reformatBoardLayout(); // Ensure board layout is finalized before game creation

            const initialPropertyDataForFirestore = boardLayout
                .filter(s => s.type === 'property' || s.type === 'set_property')
                .map(p => ({
                    id: p.id, 
                    name: p.name,
                    owner: null, 
                    tenancies: 0,
                    permanentResidence: false,
                }));


            const initialPlayerData = {
                id: currentUserId, 
                name: localPlayerName,
                money: 2000,
                position: 0,
                properties: [], 
                healthServices: 0,
                getOutOfDetentionCards: 0,
                inDetention: false,
                missedTurnsInDetention: 0,
                hasHousingVoucher: false,
                isBankrupt: false,
                playerActionTakenThisTurn: false, 
                doublesRolledInTurn: 0, 
                order: 0, 
                govReceived: 0,
                isAI: false 
            };

            const initialGameState = {
                gameId: newGameId,
                status: "waiting", 
                hostId: currentUserId,
                maxPlayers: numPlayers,
                players: { [currentUserId]: initialPlayerData }, 
                playerOrder: [currentUserId], 
                currentPlayerIndex: 0, 
                boardLayout: boardLayout, 
                propertyData: initialPropertyDataForFirestore, 
                bankMoney: 15000,
                ukGovMoney: 20000,
                shuffledWelfareCards: shuffleDeck([...welfareCards]), 
                shuffledOpportunityCards: shuffleDeck([...opportunityCards]),
                welfareCardIndex: 0, 
                opportunityCardIndex: 0,
                lastDiceRoll: null, 
                lastActionMessage: `${localPlayerName} created the game. Waiting for players...`,
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp(),
                preGameRolls: {}, 
                preGamePlayersRolled: [], 
                preGamePhase: true, 
                gamePhase: "setup", 
            };
            
            if (Object.keys(initialGameState.players).length < numPlayers) {
                // Start AI timer only if the game is not full and this client is the host
                if (currentUserId === initialGameState.hostId) {
                    if (aiAddTimerId) clearTimeout(aiAddTimerId); // Clear any existing timer
                    logEvent(`Host starting 30s timer to add AI players if game not full.`);
                    aiAddTimerId = setTimeout(() => {
                        checkAndAddAIPlayers(newGameId, numPlayers);
                    }, 30000); // 30 seconds
                }
            } else {
                 initialGameState.status = "active"; 
                 initialGameState.lastActionMessage = `${localPlayerName} created the game. Starting pre-game rolls.`;
            }


            try {
                await setDoc(gameDocRef, initialGameState);
                logEvent(`Game ${newGameId} created by ${localPlayerName}.`);
                onlineSetupMessage.textContent = `Game created! ID: ${newGameId}. Waiting for players...`;
                generatedGameIdSpan.textContent = newGameId;
                gameIdDisplayDiv.style.display = 'block';
                subscribeToGameState(newGameId);
            } catch (error) {
                console.error("Error creating game:", error);
                showMessageModal("Error", "Could not create game: " + error.message);
                onlineSetupMessage.textContent = "Failed to create game. " + error.message;
            }
        }

        async function handleJoinGame() {
            if (!currentUserId) {
                showMessageModal("Error", "You are not authenticated. Please wait or refresh.");
                return;
            }
            localPlayerName = playerNameInput.value.trim() || `Player ${currentUserId.substring(0,4)}`;
            if (!localPlayerName) {
                showMessageModal("Input Needed", "Please enter your player name.");
                return;
            }

            const gameIdToJoin = gameIdInput.value.trim().toUpperCase();
            if (!gameIdToJoin) {
                showMessageModal("Input Needed", "Please enter a Game ID to join.");
                return;
            }

            const gameDocRef = doc(db, "games", gameIdToJoin);

            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameDocRef);
                    if (!gameDoc.exists()) {
                        throw new Error("Game not found.");
                    }

                    const gameData = gameDoc.data();
                    if (gameData.boardLayout && gameData.boardLayout.length > 0) {
                        boardLayout = gameData.boardLayout;
                        const dcSpace = boardLayout.find(s => s.name === "Detention Center");
                        detentionCenterSpaceId = dcSpace ? dcSpace.id : (boardLayout.find(s => s.type === "detention_visiting")?.id || 8);
                    } else {
                        reformatBoardLayout();
                        logEvent("Warning: Joined game was missing boardLayout, reformatted locally.");
                    }


                    if (Object.keys(gameData.players).length >= gameData.maxPlayers) {
                        if (!gameData.players[currentUserId]) { 
                             throw new Error("Game is full.");
                        } else {
                            logEvent("Already part of this game. Rejoining/Resubscribing...");
                        }
                    }
                    
                    if (!gameData.players[currentUserId]) { 
                        const newPlayerOrderIndex = gameData.playerOrder.length; 
                        const newPlayerData = {
                            id: currentUserId, name: localPlayerName, money: 2000, position: 0, properties: [],
                            healthServices: 0, getOutOfDetentionCards: 0, inDetention: false, missedTurnsInDetention: 0,
                            hasHousingVoucher: false, isBankrupt: false, playerActionTakenThisTurn: false,
                            doublesRolledInTurn: 0, order: newPlayerOrderIndex, govReceived: 0, isAI: false
                        };

                        const updates = {};
                        updates[`players.${currentUserId}`] = newPlayerData;
                        updates.playerOrder = arrayUnion(currentUserId); 
                        updates.updatedAt = serverTimestamp();

                        const newPlayerCount = gameData.playerOrder.length + 1; 

                        if (newPlayerCount === gameData.maxPlayers) {
                            updates.preGamePhase = true; 
                            updates.status = "active";   
                            updates.lastActionMessage = `${localPlayerName} joined. All players present! Starting pre-game rolls.`;
                            // If host's AI timer was running, it should be cleared by onSnapshot update
                        } else {
                            updates.lastActionMessage = `${localPlayerName} joined the game. Waiting for ${gameData.maxPlayers - newPlayerCount} more.`;
                        }
                        transaction.update(gameDocRef, updates);
                        logEvent(`${localPlayerName} joining game ${gameIdToJoin}. Player order index: ${newPlayerOrderIndex}`);
                    }
                });

                currentGameId = gameIdToJoin;
                onlineSetupMessage.textContent = `Joined game ${gameIdToJoin}! Waiting for game to start...`;
                subscribeToGameState(gameIdToJoin);

            } catch (error) {
                console.error("Error joining game:", error);
                showMessageModal("Error", "Could not join game: " + error.message);
                onlineSetupMessage.textContent = "Failed to join game. " + error.message;
            }
        }

        async function checkAndAddAIPlayers(gameId, maxPlayersInGame) {
            if (aiAddTimerId) { // Clear the timer as it's now being processed
                clearTimeout(aiAddTimerId);
                aiAddTimerId = null;
            }
            logEvent(`checkAndAddAIPlayers called for game ${gameId}. Max players: ${maxPlayersInGame}`);

            const gameDocRef = doc(db, "games", gameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameDocRef);
                    if (!gameDoc.exists()) {
                        logEvent("checkAndAddAIPlayers: Game document no longer exists.");
                        return;
                    }
                    const gameData = gameDoc.data();

                    if (gameData.status !== "waiting" || Object.keys(gameData.players).length >= maxPlayersInGame) {
                        logEvent("checkAndAddAIPlayers: Game is no longer waiting or is full. No AI needed.", { status: gameData.status, playerCount: Object.keys(gameData.players).length });
                        return;
                    }

                    const numHumanPlayers = Object.keys(gameData.players).length;
                    const numAIToAdd = maxPlayersInGame - numHumanPlayers;

                    if (numAIToAdd <= 0) {
                        logEvent("checkAndAddAIPlayers: No AI players needed.");
                        return;
                    }

                    logEvent(`checkAndAddAIPlayers: Adding ${numAIToAdd} AI player(s).`);
                    let updates = {};
                    let newPlayerOrder = [...gameData.playerOrder];
                    let newPlayersObject = {...gameData.players};
                    let aiPlayerNames = [];

                    for (let i = 0; i < numAIToAdd; i++) {
                        const aiPlayerId = `AI-${crypto.randomUUID().substring(0, 8)}`;
                        const aiPlayerName = `AI Bot ${i + 1}`;
                        aiPlayerNames.push(aiPlayerName);
                        const aiOrderIndex = newPlayerOrder.length; // AI players join last in initial order
                        const aiPlayerData = {
                            id: aiPlayerId, name: aiPlayerName, money: 2000, position: 0, properties: [],
                            healthServices: 0, getOutOfDetentionCards: 0, inDetention: false, missedTurnsInDetention: 0,
                            hasHousingVoucher: false, isBankrupt: false, playerActionTakenThisTurn: false,
                            doublesRolledInTurn: 0, order: aiOrderIndex, govReceived: 0, isAI: true
                        };
                        newPlayersObject[aiPlayerId] = aiPlayerData;
                        newPlayerOrder.push(aiPlayerId);
                    }

                    updates.players = newPlayersObject;
                    updates.playerOrder = newPlayerOrder;
                    updates.preGamePhase = true; 
                    updates.status = "active";   
                    updates.lastActionMessage = `${aiPlayerNames.join(', ')} joined as AI. Starting pre-game rolls.`;
                    updates.updatedAt = serverTimestamp();
                    
                    transaction.update(gameDocRef, updates);
                    logEvent(`checkAndAddAIPlayers: Successfully added ${numAIToAdd} AI player(s).`);
                });
            } catch (error) {
                console.error("Error in checkAndAddAIPlayers transaction:", error);
                showMessageModal("AI Add Error", "Could not add AI players: " + error.message);
            }
        }


        function subscribeToGameState(gameId) {
            if (unsubscribeGameState) {
                unsubscribeGameState(); 
            }
            const gameDocRef = doc(db, "games", gameId);
            unsubscribeGameState = onSnapshot(gameDocRef, async (docSnap) => {
                if (docSnap.exists()) {
                    const gameData = docSnap.data(); 
                    
                    // If host and AI timer is running, check if game is full or started
                    if (currentUserId === gameData.hostId && aiAddTimerId) {
                        if (gameData.status !== "waiting" || Object.keys(gameData.players).length >= gameData.maxPlayers) {
                            logEvent("Game filled or started, clearing AI add timer.");
                            clearTimeout(aiAddTimerId);
                            aiAddTimerId = null;
                        }
                    }
                    
                    // Check for money changes for the current user before updating localGameData
                    if (localGameData.players && gameData.players && currentUserId && 
                        localGameData.players[currentUserId] && gameData.players[currentUserId]) {
                        
                        const oldMoney = localGameData.players[currentUserId].money;
                        const newMoney = gameData.players[currentUserId].money;

                        if (typeof oldMoney !== 'undefined' && newMoney < oldMoney) {
                            const amountLost = oldMoney - newMoney;
                            if (amountLost > 0) { // Ensure it's a real loss
                                showMoneyChangeEffect(amountLost, 'loss');
                            }
                        } else if (typeof oldMoney !== 'undefined' && newMoney > oldMoney) {
                            const amountGained = newMoney - oldMoney;
                             if (amountGained > 0) { // Ensure it's a real gain
                                showMoneyChangeEffect(amountGained, 'gain');
                            }
                        }
                    }
                    
                    localGameData = gameData; // Update local cache *after* checking for money changes
                    logEvent("Game state updated from Firestore:", gameData.lastActionMessage || "No message", gameData.status);
                    
                    if (gameData.boardLayout && JSON.stringify(boardLayout) !== JSON.stringify(gameData.boardLayout)) {
                        logEvent("Board layout received from Firestore is different or not set, adopting it.");
                        boardLayout = gameData.boardLayout;
                        const dcSpace = boardLayout.find(s => s.name === "Detention Center");
                        detentionCenterSpaceId = dcSpace ? dcSpace.id : (boardLayout.find(s => s.type === "detention_visiting")?.id || 8);
                        if (boardContainer.innerHTML.trim() !== '') { // Only redraw if already drawn
                            logEvent("Board was already drawn, re-setting up from new Firestore layout.");
                            setupBoardFromFirestore(gameData); 
                        }
                    }
                    
                    updateLocalUIFromFirestore(gameData); 
                    
                    if (currentGameId && onlineSetupScreen.style.display !== 'none' && (gameData.status === "active" || gameData.status === "finished")) {
                         onlineSetupScreen.style.display = 'none';
                         gameContainer.style.display = 'flex';
                         logEvent("Switched to game container as game status is active/finished and setup screen was visible.");
                    }
                    // --- AI TURN LOGIC ---
                    if (
                        gameData.status === "active" &&
                        !gameData.preGamePhase &&
                        gameData.playerOrder &&
                        gameData.players
                    ) {
                        const currentPlayerId = gameData.playerOrder[gameData.currentPlayerIndex];
                        const currentPlayer = gameData.players[currentPlayerId];
                        if (currentPlayer && currentPlayer.isAI && !currentPlayer.isBankrupt) {
                            if (!window._aiTurnInProgress) {
                                window._aiTurnInProgress = true;
                                setTimeout(async () => {
                                    await handleAITurn(gameData, currentPlayerId);
                                    window._aiTurnInProgress = false;
                                }, 1000);
                            }
                        }
                    }
                } else {
                    logEvent(`Game ${gameId} no longer exists or access denied.`);
                    showMessageModal("Game Ended", "The game session has ended or is no longer available.");
                    if (unsubscribeGameState) unsubscribeGameState();
                    resetToSetupScreen();
                }
            }, (error) => {
                console.error("Error listening to game state:", error);
                showMessageModal("Connection Error", "Lost connection to the game: " + error.message);
                if (unsubscribeGameState) unsubscribeGameState();
                resetToSetupScreen();
            });
        }
        
        function resetToSetupScreen() {
            onlineSetupScreen.style.display = 'flex';
            gameContainer.style.display = 'none';
            currentGameId = null;
            localGameData = {};
            if (unsubscribeGameState) {
                unsubscribeGameState();
                unsubscribeGameState = null;
            }
            if (aiAddTimerId) { // Clear AI timer if it's running
                clearTimeout(aiAddTimerId);
                aiAddTimerId = null;
            }
            onlineSetupMessage.textContent = "Ready to create or join a new game.";
            gameIdDisplayDiv.style.display = 'none';
            generatedGameIdSpan.textContent = '';
            gameIdInput.value = '';
            boardLayout = []; 
            if(boardContainer) boardContainer.innerHTML = ''; 
            if(playerInfoDiv) playerInfoDiv.innerHTML = '';
            if(diceFace1Elem) diceFace1Elem.textContent = '--';
            if(diceFace2Elem) diceFace2Elem.textContent = '--';
            if(diceTotalDisplayText) diceTotalDisplayText.textContent = '';
            if(currentTurnDisplay) currentTurnDisplay.textContent = 'Current Turn: Player 1';
            if(gameStatusMessageP) gameStatusMessageP.textContent = 'Waiting for game to start...';

        }

        async function finalizePreGameAsHost() {
            if (!currentGameId || !currentUserId || !db || !localGameData.hostId || localGameData.hostId !== currentUserId) {
                logEvent("finalizePreGameAsHost: Conditions not met.");
                return;
            }
            logEvent("Host attempting to finalize pre-game rolls.");

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) {
                        throw new Error("Game document not found during host finalization.");
                    }
                    const freshGameData = freshGameDoc.data();

                    if (!freshGameData.preGamePhase) {
                        logEvent("Host finalization: Pre-game phase already ended.");
                        return; 
                    }
                     if (freshGameData.hostId !== currentUserId) { 
                        logEvent("Host finalization check: Current user is NOT host in fresh data. Aborting.");
                        return;
                    }

                    const allPlayersInOrder = freshGameData.playerOrder || [];
                    const currentPreGameRolls = freshGameData.preGameRolls || {};
                    const allHaveRolled = allPlayersInOrder.length > 0 &&
                                        allPlayersInOrder.length === freshGameData.maxPlayers && 
                                        allPlayersInOrder.every(pid => currentPreGameRolls[pid] !== undefined);

                    if (!allHaveRolled) {
                        logEvent("Host finalization: Not all players have rolled or not all joined. Aborting.");
                        return; 
                    }
                    
                    logEvent("Host is proceeding with finalization of pre-game rolls.");
                    let updates = {};
                    const sortedPlayerIds = [...allPlayersInOrder].sort((a, b) => {
                        const rollA = currentPreGameRolls[a];
                        const rollB = currentPreGameRolls[b];
                        if (rollB === rollA) { 
                            return (freshGameData.players[a]?.order || 0) - (freshGameData.players[b]?.order || 0);
                        }
                        return rollB - rollA; 
                    });

                    updates.playerOrder = sortedPlayerIds; 
                    updates.currentPlayerIndex = 0;
                    updates.preGamePhase = false;
                    updates.gamePhase = "main";
                    updates.status = "active"; 
                    updates.lastActionMessage = `Starting order determined by host. ${freshGameData.players[sortedPlayerIds[0]].name} starts!`;
                    updates.updatedAt = serverTimestamp();
                    
                    transaction.update(gameDocRef, updates);
                    logEvent("Host successfully finalized pre-game starting order.");
                });
            } catch (error) {
                console.error("Error during host finalization of pre-game rolls:", error);
                showMessageModal("Host Finalization Error", "Could not finalize game start: " + error.message);
            }
        }

        // --- UI HELPER FUNCTION DEFINITIONS ---
        function updateDiceUIDisplay(gameData) {
            const diceDisplayContainer = document.getElementById('actual-dice-faces');
            if (!diceFace1Elem || !diceFace2Elem || !diceTotalDisplayText || !diceDisplayContainer) return;

            if (gameData.lastDiceRoll && gameData.gamePhase === "main" && !gameData.preGamePhase) {
                diceFace1Elem.textContent = gameData.lastDiceRoll.die1;
                diceFace2Elem.textContent = gameData.lastDiceRoll.die2;
                diceTotalDisplayText.textContent = ` = ${gameData.lastDiceRoll.total}`;
                
                diceDisplayContainer.classList.remove('dice-animation');
                void diceDisplayContainer.offsetWidth; 
                diceDisplayContainer.classList.add('dice-animation');
            } else { 
                diceFace1Elem.textContent = '--';
                diceFace2Elem.textContent = '--';
                diceTotalDisplayText.textContent = '';
                diceDisplayContainer.classList.remove('dice-animation');
            }
        }

        function updatePlayerInfoPanel(gameData) {
            if (!playerInfoDiv) return;
            playerInfoDiv.innerHTML = ''; 
            if (!gameData.playerOrder || !gameData.players) {
                logEvent("updatePlayerInfoPanel: Missing playerOrder or players data.");
                return;
            }

            gameData.playerOrder.forEach(playerId => {
                const p = gameData.players[playerId];
                if (!p || typeof p.id === 'undefined' || typeof p.order === 'undefined') { 
                    logEvent("updatePlayerInfoPanel: Invalid player data encountered for ID:", playerId, p);
                    return; 
                };

                const playerColor = playerColors[p.order % playerColors.length];
                const pDiv = document.createElement('div');
                if (p.isBankrupt) {
                    pDiv.innerHTML = `<b style="color:${playerColor};">${p.name}</b>: BANKRUPT`;
                    pDiv.style.textDecoration = 'line-through';
                    pDiv.style.opacity = '0.6';
                } else {
                    pDiv.innerHTML = `<b style='color:${playerColor};'>${p.name}</b>: <span style='font-weight:bold;'>Â£${p.money}</span> | HS: ${p.healthServices} | LegalAids: ${p.getOutOfDetentionCards}`;
                    if (p.inDetention) pDiv.innerHTML += ` (In Detention - ${p.missedTurnsInDetention} missed)`;
                    // Removed 'From UK Gov' line
                }
                if (!gameData.preGamePhase && gameData.status === "active" && gameData.playerOrder[gameData.currentPlayerIndex] === p.id && !p.isBankrupt) { 
                    pDiv.style.border = `2px solid ${playerColor}`;
                    pDiv.style.padding = "3px";
                    pDiv.style.borderRadius = "4px";
                    pDiv.classList.add('player-highlight'); 
                } else {
                    pDiv.classList.remove('player-highlight');
                }
                playerInfoDiv.appendChild(pDiv);
            });
        }
        
        function updateGameStatusPanel(gameData) {
            if (!gameStatusMessageP || !currentTurnDisplay || !gameData.players || !gameData.playerOrder) return;

            if (gameData.preGamePhase) {
                 const joined = Object.keys(gameData.players).length;
                 if (joined < gameData.maxPlayers) {
                    gameStatusMessageP.textContent = `Waiting for players... (${joined}/${gameData.maxPlayers} joined)`;
                 } else { 
                    const allRolled = gameData.playerOrder.every(pid => gameData.preGameRolls && gameData.preGameRolls[pid] !== undefined);
                    if (allRolled) {
                        gameStatusMessageP.textContent = "All players rolled. Host is determining start order...";
                    } else {
                        gameStatusMessageP.textContent = "Pre-game: Determine starting player by rolling.";
                    }
                 }
            } else if (gameData.status === "active" && gameData.gamePhase === "main") {
                gameStatusMessageP.textContent = gameData.lastActionMessage || "Game in progress...";
            } else if (gameData.status === "finished") {
                gameStatusMessageP.textContent = gameData.lastActionMessage || "Game Over!";
            } else { 
                 gameStatusMessageP.textContent = `Waiting for players... (${Object.keys(gameData.players).length}/${gameData.maxPlayers} joined)`;
            }

            const currentPlayerIdInOrder = gameData.playerOrder[gameData.currentPlayerIndex];
            const currentPlayerInOrder = gameData.players[currentPlayerIdInOrder];

            if (currentPlayerInOrder && gameData.status === "active") { 
                if (gameData.preGamePhase) {
                    let nextPlayerToRollForDisplayId = null;
                    for(const pid of gameData.playerOrder) { 
                        if(!gameData.preGameRolls || gameData.preGameRolls[pid] === undefined) {
                            nextPlayerToRollForDisplayId = pid;
                            break;
                        }
                    }
                    const playerToRoll = gameData.players[nextPlayerToRollForDisplayId];

                    if (playerToRoll && typeof playerToRoll.name !== 'undefined' && typeof playerToRoll.order !== 'undefined') {
                         currentTurnDisplay.textContent = `Pre-Game Roll: ${playerToRoll.name}`;
                         currentTurnDisplay.style.color = playerColors[playerToRoll.order % playerColors.length];
                         currentTurnDisplay.classList.remove('pulsing'); // No pulse in pre-game
                    } else if (Object.keys(gameData.players).length === gameData.maxPlayers) { 
                        currentTurnDisplay.textContent = "Pre-Game Rolls Complete";
                        currentTurnDisplay.style.color = '#ecf0f1'; 
                        currentTurnDisplay.classList.remove('pulsing');
                    } else {
                        currentTurnDisplay.textContent = "Waiting for Players...";
                        currentTurnDisplay.style.color = '#ecf0f1';
                        currentTurnDisplay.classList.remove('pulsing');
                    }
                } else if (gameData.gamePhase === "main" && !currentPlayerInOrder.isBankrupt) { 
                    currentTurnDisplay.textContent = `Current Turn: ${currentPlayerInOrder.name}`;
                    currentTurnDisplay.style.color = playerColors[currentPlayerInOrder.order % playerColors.length];
                    currentTurnDisplay.classList.add('pulsing'); // Add pulse for active turn
                } else if (gameData.gamePhase === "main" && currentPlayerInOrder.isBankrupt) {
                    currentTurnDisplay.textContent = `Skipping Bankrupt: ${currentPlayerInOrder.name}`;
                    currentTurnDisplay.style.color = '#7f8c8d'; 
                    currentTurnDisplay.classList.remove('pulsing');
                }
            } else if (gameData.status === "finished") {
                currentTurnDisplay.textContent = "Game Over!";
                currentTurnDisplay.style.color = '#e74c3c';
                currentTurnDisplay.classList.remove('pulsing');
            } else { 
                currentTurnDisplay.textContent = "Game Not Fully Started";
                currentTurnDisplay.style.color = '#ecf0f1';
                currentTurnDisplay.classList.remove('pulsing');
            }
        }

        function updateControlsBasedOnTurn(gameData) {
            if (!currentUserId || !gameData.players || !gameData.players[currentUserId]) {
                rollDiceButton.style.display = 'none';
                endTurnButton.style.display = 'none';
                buyPropertyButton.style.display = 'none';
                developPropertyButton.style.display = 'none';
                otherActionsContainer.style.display = 'none'; 
                detentionActionsDiv.innerHTML = ''; 
                return;
            }
            const amIBankrupt = gameData.players[currentUserId]?.isBankrupt;

            rollDiceButton.style.display = 'none';
            endTurnButton.style.display = 'none';
            buyPropertyButton.style.display = 'none';
            developPropertyButton.style.display = 'none';
            otherActionsContainer.style.display = 'none'; 
            detentionActionsDiv.innerHTML = ''; 

            if (amIBankrupt || gameData.status === "finished" || gameData.preGamePhase) {
                const playerToken = document.getElementById(`player-token-${currentUserId}`);
                if (playerToken) playerToken.classList.remove('token-flash');
                return;
            }
            
            if (gameData.status !== "active" || gameData.gamePhase !== "main") return;

            const isMyTurn = gameData.playerOrder[gameData.currentPlayerIndex] === currentUserId;
            const myPlayerState = gameData.players[currentUserId]; 
            const amIInDetention = myPlayerState.inDetention;
            const myPlayerActionTakenThisTurn = myPlayerState.playerActionTakenThisTurn; 

            const playerToken = document.getElementById(`player-token-${currentUserId}`);
            if (isMyTurn) {
                if (playerToken && cardDisplayContainer.style.display === 'none' && developPropertyContainer.style.display === 'none' && (!onBoardCardDisplayDiv || onBoardCardDisplayDiv.style.display === 'none')) {
                    playerToken.classList.add('token-flash');
                } else if (playerToken) {
                    playerToken.classList.remove('token-flash');
                }
            } else {
                 if (playerToken) playerToken.classList.remove('token-flash');
            }


            if (isMyTurn) {
                if (amIInDetention) {
                    setupDetentionActionsUI(myPlayerState, gameData); 
                    if (myPlayerActionTakenThisTurn) { 
                        endTurnButton.style.display = 'block';
                        endTurnButton.disabled = false; 
                        endTurnButton.classList.add('main-action-button');
                        detentionActionsDiv.innerHTML = ''; 
                    }
                } else { 
                    const rolledDoubles = gameData.lastDiceRoll?.isDoubles;
                    const doublesCount = myPlayerState.doublesRolledInTurn || 0;

                    // Roll Dice Button Logic:
                    if (!myPlayerActionTakenThisTurn || (rolledDoubles && doublesCount > 0 && doublesCount < 3) ) {
                        rollDiceButton.style.display = 'block';
                        rollDiceButton.disabled = false; 
                        rollDiceButton.classList.add('main-action-button');
                        if (rolledDoubles && doublesCount > 0 && doublesCount < 3 && gameStatusMessageP) {
                            gameStatusMessageP.textContent = `${myPlayerState.name} rolled doubles! Roll again.`;
                        }
                    }

                    // Optional Actions (Buy/Develop) and End Turn Button Logic:
                    let showOptionalActions = false;
                    // Show optional actions if the player has landed (lastDiceRoll is set for their turn)
                    // OR if playerActionTakenThisTurn is true (meaning they completed a non-doubles roll/move)
                    if (gameData.lastDiceRoll || myPlayerActionTakenThisTurn) { 
                        showOptionalActions = true;
                    }


                    if (showOptionalActions) {
                        otherActionsContainer.style.display = 'block';
                        const currentSpace = gameData.boardLayout[myPlayerState.position];
                        const propData = Array.isArray(gameData.propertyData) ? gameData.propertyData.find(p => p.id === currentSpace?.id) : null;

                        // Buy Property Button
                        if (currentSpace && propData && (currentSpace.type === 'property' || currentSpace.type === 'set_property') && propData.owner === null) {
                            let price = currentSpace.price;
                            if (myPlayerState.hasHousingVoucher && currentSpace.type === 'property') {
                                price = Math.round(price * 0.75);
                            }
                            buyPropertyPriceSpan.textContent = price;
                            buyPropertyButton.style.display = (myPlayerState.money >= price) ? 'inline-block' : 'none';
                            if (buyPropertyButton.style.display === 'inline-block') buyPropertyButton.disabled = false;
                        } else {
                            buyPropertyButton.style.display = 'none';
                        }

                        // Develop Property Button
                        developPropertyButton.style.display = canPlayerDevelopAnyProperty(myPlayerState, gameData) ? 'inline-block' : 'none';
                        if (developPropertyButton.style.display === 'inline-block') {
                            developPropertyButton.disabled = false; 
                        }

                        if (buyPropertyButton.style.display === 'none' && developPropertyButton.style.display === 'none') {
                            otherActionsContainer.style.display = 'none'; // Hide container if no optional actions
                        }
                    } else {
                         otherActionsContainer.style.display = 'none';
                    }
                    
                    // End Turn button: Show if playerActionTakenThisTurn is true AND they are not forced to roll again for doubles.
                    if (myPlayerActionTakenThisTurn && !(rolledDoubles && doublesCount > 0 && doublesCount < 3) ) {
                        endTurnButton.style.display = 'block';
                        endTurnButton.disabled = false;
                        endTurnButton.classList.add('main-action-button');
                    }


                    // Auto-end turn logic
                    const noMandatoryRollPending = !((myPlayerState.doublesRolledInTurn || 0) > 0 && (myPlayerState.doublesRolledInTurn || 0) < 3 && !myPlayerActionTakenThisTurn);
                    const noOptionalActionsAvailable = buyPropertyButton.style.display === 'none' && developPropertyButton.style.display === 'none';
                    const noCardActionPending = cardDisplayContainer.style.display === 'none' && (!onBoardCardDisplayDiv || onBoardCardDisplayDiv.style.display === 'none');

                    if (myPlayerActionTakenThisTurn && noMandatoryRollPending && noOptionalActionsAvailable && noCardActionPending) {
                        logEvent("Auto-ending turn conditions met. Setting timeout.");
                        setTimeout(() => {
                            // Re-check critical conditions within timeout, using the most current localGameData
                            const freshLocalDataForAutoEnd = localGameData; 
                            if (freshLocalDataForAutoEnd && freshLocalDataForAutoEnd.players && freshLocalDataForAutoEnd.players[currentUserId]) {
                                const stillMyTurnNow = freshLocalDataForAutoEnd.playerOrder[freshLocalDataForAutoEnd.currentPlayerIndex] === currentUserId;
                                const playerStateNow = freshLocalDataForAutoEnd.players[currentUserId];
                                
                                // Re-evaluate conditions with this freshest data
                                const noRollPendingNow = !((playerStateNow.doublesRolledInTurn || 0) > 0 && (playerStateNow.doublesRolledInTurn || 0) < 3 && !playerStateNow.playerActionTakenThisTurn);
                                const noOptionsNow = document.getElementById('buy-property-button').style.display === 'none' &&
                                                     document.getElementById('develop-property-button').style.display === 'none';
                                const noCardNow = document.getElementById('card-display-container').style.display === 'none' &&
                                                  (!document.getElementById('on-board-card-display') || document.getElementById('on-board-card-display').style.display === 'none');

                                if (stillMyTurnNow && playerStateNow.playerActionTakenThisTurn && noRollPendingNow && noOptionsNow && noCardNow) {
                                    logEvent("Auto-end conditions still met in timeout. Calling handleEndTurnAction.");
                                    handleEndTurnAction();
                                } else {
                                    logEvent("Auto-end conditions changed during timeout or not my turn anymore. Not auto-ending.");
                                }
                            } else {
                                logEvent("Auto-end timeout: Could not get fresh player data. Not auto-ending.");
                            }
                        }, 1500); 
                    }
                }
            }
        }
        
        function updatePreGameRollUI(gameData) {
            if (!preGameRollArea || !preGameRollButton || !preGameRollResultsDiv || !gameData.players) { 
                logEvent("updatePreGameRollUI: Missing DOM elements or player data.");
                return;
            }

            if (!gameData.preGamePhase || gameData.status !== "active" || Object.keys(gameData.players).length < gameData.maxPlayers) { 
                preGameRollArea.style.display = 'none';
                preGameRollButton.style.display = 'none';
                return;
            }
            
            preGameRollArea.style.display = 'flex'; 
            preGameRollResultsDiv.innerHTML = ''; 
            preGameRollButton.style.display = 'none'; // Default to hidden

            let allPlayerIdsInOrder = gameData.playerOrder || []; 
            let preGameRollsData = gameData.preGameRolls || {};
            let numberOfPlayers = allPlayerIdsInOrder.length;
            
            let rolledPlayerCount = 0;
            allPlayerIdsInOrder.forEach(pid => {
                const playerName = gameData.players[pid]?.name || 'Unknown Player';
                const playerOrderForColor = gameData.players[pid]?.order; 
                const playerColor = (typeof playerOrderForColor !== 'undefined') ? playerColors[playerOrderForColor % playerColors.length] : '#ecf0f1';

                if (preGameRollsData[pid] !== undefined) {
                    preGameRollResultsDiv.innerHTML += `<span style="color:${playerColor};">${playerName}</span> rolled: ${preGameRollsData[pid]}<br>`;
                    rolledPlayerCount++;
                } else {
                    preGameRollResultsDiv.innerHTML += `<span style="color:${playerColor};">${playerName}</span> has not rolled yet.<br>`;
                }
            });
            
            if (rolledPlayerCount === numberOfPlayers && numberOfPlayers > 0 && numberOfPlayers === gameData.maxPlayers) {
                preGameRollResultsDiv.innerHTML += "All players rolled. Host is determining start order...";
            } else if (numberOfPlayers > 0 && numberOfPlayers === gameData.maxPlayers) { 
                let nextPlayerToRollId = null;
                const sortedByJoinOrder = [...allPlayerIdsInOrder].sort((a,b) => (gameData.players[a]?.order || 0) - (gameData.players[b]?.order || 0));

                for (const pid of sortedByJoinOrder) {
                    if (preGameRollsData[pid] === undefined) {
                        nextPlayerToRollId = pid;
                        break;
                    }
                }

                if (nextPlayerToRollId === currentUserId) {
                    preGameRollButton.style.display = 'block';
                    preGameRollButton.textContent = `Your turn, ${gameData.players[currentUserId]?.name || 'Player'}, Roll to Start`;
                    preGameRollButton.disabled = false;
                } else if (nextPlayerToRollId && gameData.players[nextPlayerToRollId]) {
                    preGameRollButton.style.display = 'block'; 
                    preGameRollButton.textContent = `Waiting for ${gameData.players[nextPlayerToRollId].name} to roll...`;
                    preGameRollButton.disabled = true;
                } else if (rolledPlayerCount < numberOfPlayers) { 
                    preGameRollButton.style.display = 'block';
                    preGameRollButton.textContent = `Waiting for players to roll...`;
                    preGameRollButton.disabled = true;
                }
            } else { 
                 preGameRollResultsDiv.innerHTML = "Waiting for all players to join before starting rolls...";
            }
        }

        function updateUkGovDisplay(govMoney) {
            if (ukGovCashSpan) {
                 ukGovCashSpan.textContent = govMoney !== undefined ? govMoney : (localGameData.ukGovMoney || 20000);
            }
        }

        function handleGameEndUI(gameData) {
            if (!gameStatusMessageP || !currentTurnDisplay || !rollDiceButton || !endTurnButton || !buyPropertyButton || !developPropertyButton || !preGameRollArea || !otherActionsContainer) return;
            
            gameStatusMessageP.textContent = gameData.lastActionMessage || "Game Over!";
            currentTurnDisplay.textContent = "Game Over!";
            currentTurnDisplay.style.color = '#e74c3c';

            rollDiceButton.style.display = 'none';
            endTurnButton.style.display = 'none';
            buyPropertyButton.style.display = 'none';
            developPropertyButton.style.display = 'none';
            preGameRollArea.style.display = 'none'; 
            detentionActionsDiv.innerHTML = ''; 

            otherActionsContainer.style.display = 'block'; 
            otherActionsContainer.innerHTML = '<button id="leave-game-button" style="background-color:#c0392b;">Back to Setup</button>';
            const leaveButton = document.getElementById('leave-game-button');
            if (leaveButton) {
                leaveButton.onclick = () => {
                    if (unsubscribeGameState) unsubscribeGameState();
                    resetToSetupScreen();
                };
            }
        }

        function setupBoardFromFirestore(gameData) {
            if (!boardContainer) {
                logEvent("Error: boardContainer DOM element not found in setupBoardFromFirestore.");
                return;
            }
            boardContainer.innerHTML = ''; 
            
            if (gameData.boardLayout && gameData.boardLayout.length > 0) {
                boardLayout = gameData.boardLayout;
            } else {
                logEvent("setupBoardFromFirestore: gameData.boardLayout is missing or empty. Cannot setup board.");
                return;
            }
            
            const dcSpace = boardLayout.find(s => s.name === "Detention Center");
            detentionCenterSpaceId = dcSpace ? dcSpace.id : (boardLayout.find(s => s.type === "detention_visiting")?.id || 8) ;

            const cardDecksCenter = document.createElement('div');
            cardDecksCenter.id = 'card-decks-center';
            // Add image to the center
            const centerImage = document.createElement('img');
            centerImage.id = 'center-board-image';
            // Use the provided migrant3.jpg as the image
            centerImage.src = 'migrant3.jpg'; 
            centerImage.alt = 'Migrantopoly Center';
            cardDecksCenter.appendChild(centerImage);
            // Removed the card-deck opportunity and welfare boxes
            boardContainer.appendChild(cardDecksCenter);

            const onBoardCardDiv = document.createElement('div');
            onBoardCardDiv.id = 'on-board-card-display'; 
            onBoardCardDiv.style.display = 'none'; 
            onBoardCardDiv.innerHTML = `
                <h4 id="on-board-card-type">Card Type</h4>
                <p id="on-board-card-text">Card text will appear here.</p>
                <button id="on-board-card-ok-button">OK</button> 
            `;
            boardContainer.appendChild(onBoardCardDiv);
            onBoardCardDisplayDiv = document.getElementById('on-board-card-display'); 
            onBoardCardTypeH4 = document.getElementById('on-board-card-type');
            onBoardCardTextP = document.getElementById('on-board-card-text');
            onBoardCardOkButton = document.getElementById('on-board-card-ok-button');

            if (onBoardCardOkButton) {
                onBoardCardOkButton.onclick = () => {
                    onBoardCardDisplayDiv.style.display = 'none';
                    // After card is acknowledged, check if turn should auto-end or if player needs to roll for doubles
                    // This logic is now primarily handled within updateControlsBasedOnTurn's auto-end section
                    // and the main flow of handleRollDiceAction.
                    // Forcing an update check here can be beneficial.
                    if (localGameData && currentUserId && localGameData.players && localGameData.players[currentUserId]) {
                        updateControlsBasedOnTurn(localGameData); // Re-evaluate controls
                    }
                };
            }


            boardLayout.forEach((s) => {
                const spaceDiv = document.createElement('div');
                spaceDiv.id = `space-${s.id}`;
                spaceDiv.classList.add('space');
                if (s.type === 'go' || s.type === 'detention_visiting' || s.type === 'go_to_detention' || s.type === 'crime_spree') {
                    spaceDiv.classList.add('corner');
                }
                if (['Fake PIP declined', 'Fake ID Cards', "Payout: Job Seeker's"].includes(s.name)) {
                    spaceDiv.classList.add('yellow-boardname');
                }
                if (s.name === "Dole" && s.type === "go"){
                     spaceDiv.classList.add('dole-space');
                     const doleSign = document.createElement('div');
                     doleSign.classList.add('dole-sign');
                     doleSign.textContent = '$'; 
                     spaceDiv.appendChild(doleSign);
                }
                if (s.name === 'Detention Center') {
                    const bars = document.createElement('div'); bars.className = 'detention-bars';
                    for (let b = 0; b < 6; b++) { const bar = document.createElement('div'); bar.className = 'detention-bar'; bars.appendChild(bar); }
                    spaceDiv.appendChild(bars);
                }
                if (s.name === 'Go to Detention Center') {
                    const arrow = document.createElement('div'); arrow.className = 'detention-arrow'; arrow.textContent = 'â†’'; spaceDiv.appendChild(arrow);
                    const subLabel = document.createElement('div'); subLabel.className = 'sub-label'; subLabel.textContent = 'DO NOT PASS GO'; spaceDiv.appendChild(subLabel);
                }
                if (s.type === 'property') {
                    spaceDiv.classList.add('property', s.color || s.groupId); 
                    const colorBar = document.createElement('div'); colorBar.classList.add('color-bar');
                    // Tesco spaces: make color-bar blue
                    if (["Tesco Cardboard Skip 1", "Tesco Cardboard Skip 2", "Tesco Cardboard Skip 3"].includes(s.name)) {
                        colorBar.style.backgroundColor = '#2196f3'; // Blue
                    }
                    spaceDiv.appendChild(colorBar);
                } else if (s.type === 'set_property') {
                    spaceDiv.classList.add('set-property');
                }
                const nameDiv = document.createElement('div'); nameDiv.classList.add('name');
                if (s.name === 'Detention Center') nameDiv.classList.add('detention-center-name');
                nameDiv.textContent = s.name;
                // Opportunity and Welfare: make name orange
                if (s.type === 'opportunity' || s.type === 'welfare') {
                    nameDiv.style.color = '#ff9800'; // Orange
                }
                spaceDiv.appendChild(nameDiv);

                if (s.type === 'property' && s.rent) { 
                    const devIndicator = document.createElement('div');
                    devIndicator.classList.add('development-indicator');
                    devIndicator.id = `dev-indicator-${s.id}`;
                    spaceDiv.appendChild(devIndicator);
                }
                if (s.price) {
                    const priceDiv = document.createElement('div'); priceDiv.classList.add('price');
                    priceDiv.textContent = `Â£${s.price}`; spaceDiv.appendChild(priceDiv);
                }
                if (s.type === 'property' || s.type === 'set_property') { 
                    const ownerIndicator = document.createElement('div');
                    ownerIndicator.classList.add('owner-indicator');
                    ownerIndicator.id = `owner-indicator-${s.id}`;
                    spaceDiv.appendChild(ownerIndicator);
                }
                
                const currentId = s.id; 
                if (currentId === 0) { spaceDiv.style.gridArea = `1 / 1`; } 
                else if (currentId >= 1 && currentId <= 8) { spaceDiv.style.gridArea = `1 / ${currentId + 1}`; } 
                else if (currentId === 9) { spaceDiv.style.gridArea = `1 / 10`; } 
                else if (currentId >= 10 && currentId <= 17) { spaceDiv.style.gridArea = `${(currentId - 9) + 1} / 10`; } 
                else if (currentId === 18) { spaceDiv.style.gridArea = `10 / 10`; } 
                else if (currentId >= 19 && currentId <= 26) { spaceDiv.style.gridArea = `10 / ${10 - (currentId - 18)}`; } 
                else if (currentId === 27) { spaceDiv.style.gridArea = `10 / 1`; } 
                else if (currentId >= 28 && currentId <= 31) { 
                     spaceDiv.style.gridArea = `${10 - (currentId - 27)} / 1`; 
                } else if (currentId >= 28 && currentId <= 35) { 
                    spaceDiv.style.gridArea = `${10 - (currentId - 27)} / 1`; 
                }

                boardContainer.appendChild(spaceDiv);
            });

            if (gameData.players && gameData.playerOrder) {
                Object.values(gameData.players).forEach(player => {
                    if (player && typeof player.id !== 'undefined' && typeof player.order !== 'undefined') { 
                        let token = document.getElementById(`player-token-${player.id}`);
                        if (!token) { 
                            token = document.createElement('div');
                            token.id = `player-token-${player.id}`; 
                            token.classList.add('player-token');
                        }
                        token.textContent = playerEmojis[player.order % playerEmojis.length];
                        const playerTokenColor = playerColors[player.order % playerColors.length];
                        token.style.color = playerTokenColor;
                        token.style.filter = `drop-shadow(0 0 3px ${playerTokenColor})`;
                        
                        const spaceToPlace = document.getElementById(`space-${player.position}`);
                        if (spaceToPlace) {
                            spaceToPlace.appendChild(token);
                        } else {
                            logEvent(`Warning: Could not find space-${player.position} to place token for ${player.name}`);
                            const goSpace = document.getElementById('space-0'); 
                            if (goSpace) goSpace.appendChild(token);
                        }
                    } else {
                        logEvent("Warning: Invalid player data in setupBoardFromFirestore, skipping token creation/update.", player);
                    }
                });
            } else {
                logEvent("Warning: gameData.players or gameData.playerOrder is missing in setupBoardFromFirestore. Tokens not created.");
            }
            updateBoardDynamicElements(gameData); 
        }
        
        function updateBoardDynamicElements(gameData) {
            if (!gameData || !gameData.players || !gameData.boardLayout) {
                logEvent("updateBoardDynamicElements: Missing critical gameData. Skipping updates.");
                return;
            }

            Object.values(gameData.players).forEach(player => {
                if (!player || typeof player.id === 'undefined') { 
                    logEvent("updateBoardDynamicElements: Invalid player object in players list.", player);
                    return; 
                } 
                const token = document.getElementById(`player-token-${player.id}`);
                if (token) {
                    if (player.isBankrupt) {
                        token.style.display = 'none'; 
                    } else {
                        token.style.display = 'block';
                        const currentSpaceEl = document.getElementById(`space-${player.position}`);
                        if (currentSpaceEl) { 
                            if (token.parentNode !== currentSpaceEl) {
                                currentSpaceEl.appendChild(token); 
                            }
                        } else {
                            logEvent(`updateBoardDynamicElements: Could not find space-${player.position} for token ${player.id}`);
                        }
                    }
                } else {
                    logEvent(`updateBoardDynamicElements: Token not found for player ${player.id}. It should have been created.`);
                }
            });

            if (Array.isArray(gameData.propertyData)) {
                gameData.propertyData.forEach(propInPropertyData => {
                    if (!propInPropertyData || typeof propInPropertyData.id === 'undefined') {
                        logEvent("Warning: Invalid item in propertyData array during UI update, skipping this item.", propInPropertyData);
                        return; 
                    }

                    const ownerIndicator = document.getElementById(`owner-indicator-${propInPropertyData.id}`);
                    if (ownerIndicator) {
                        if (propInPropertyData.owner && gameData.players[propInPropertyData.owner] && !gameData.players[propInPropertyData.owner].isBankrupt) {
                            const ownerData = gameData.players[propInPropertyData.owner];
                            if (ownerData && typeof ownerData.order !== 'undefined') {
                                const ownerColor = playerColors[ownerData.order % playerColors.length];
                                ownerIndicator.style.backgroundColor = ownerColor;
                            } else {
                                 ownerIndicator.style.backgroundColor = 'transparent'; 
                            }
                        } else {
                            ownerIndicator.style.backgroundColor = 'transparent'; 
                        }
                    }

                    const boardSpaceDetails = gameData.boardLayout.find(s => s.id === propInPropertyData.id);
                    if (boardSpaceDetails && boardSpaceDetails.type === 'property') { 
                        const devIndicator = document.getElementById(`dev-indicator-${propInPropertyData.id}`);
                        if (devIndicator) {
                            if (propInPropertyData.permanentResidence) {
                                devIndicator.textContent = "ðŸ¢"; 
                            } else if (propInPropertyData.tenancies > 0) {
                                devIndicator.textContent = "ðŸ ".repeat(propInPropertyData.tenancies); 
                            } else {
                                devIndicator.textContent = ""; 
                            }
                        }
                    }
                });
            } else {
                logEvent("updateBoardDynamicElements: gameData.propertyData is NOT an array. Property visual updates will be skipped.", gameData.propertyData);
            }
        }

        function showMoneyChangeEffect(amount, type = 'loss') {
            const moneyFlashDivLocal = document.getElementById('money-flash'); 
            if (!moneyFlashDivLocal) {
                logEvent("showMoneyChangeEffect: money-flash div not found.");
                return;
            }

            moneyFlashDivLocal.textContent = `${type === 'loss' ? '-' : '+'}Â£${Math.abs(amount)}`;
            moneyFlashDivLocal.style.color = type === 'loss' ? '#e74c3c' : '#2ecc71'; 

            moneyFlashDivLocal.classList.add('show'); 

            // Hide after animation (which is 0.7s) + a little buffer, or simply 1 second
            setTimeout(() => {
                moneyFlashDivLocal.classList.remove('show');
            }, 1000); // Display for 1 second total

            if (audioContextStarted && toneSynth) {
                try {
                    if (type === 'loss') {
                        // Caching / money loss sound - short descending notes
                        toneSynth.triggerAttackRelease("A3", "16n", Tone.now());
                        toneSynth.triggerAttackRelease("F#3", "16n", Tone.now() + 0.07);
                    } else { // 'gain'
                        toneSynth.triggerAttackRelease("C5", "16n", Tone.now());
                        toneSynth.triggerAttackRelease("E5", "16n", Tone.now() + 0.07);
                    }
                } catch (e) {
                    console.error("Money change sound error:", e);
                }
            }
        }


        // --- MAIN UI UPDATE FUNCTION (Calls helpers) ---
        function updateLocalUIFromFirestore(gameData) { 
            if (!currentUserId) {
                logEvent("UpdateLocalUI: currentUserId not set yet, deferring UI update.");
                if(gameStatusMessageP) gameStatusMessageP.textContent = "Authenticating..."; 
                return;
            }

            if (!gameData || Object.keys(gameData).length === 0) {
                logEvent("UpdateLocalUI: No game data received. Cannot update UI.");
                return;
            }
            
            if (gameData.preGamePhase && 
                gameData.status === "active" &&
                gameData.hostId === currentUserId && 
                gameData.playerOrder && gameData.playerOrder.length === gameData.maxPlayers && 
                gameData.preGameRolls &&
                gameData.playerOrder.every(pid => gameData.preGameRolls[pid] !== undefined) 
               ) {
                logEvent("Host detected conditions to finalize pre-game. Calling finalizePreGameAsHost.");
                finalizePreGameAsHost(); 
                return; 
            }

            if (gameData.boardLayout && gameData.boardLayout.length > 0) {
                const boardIsMissingOrDifferent = boardLayout.length === 0 || 
                                                (boardContainer && boardContainer.innerHTML.trim() === '') ||
                                                JSON.stringify(boardLayout) !== JSON.stringify(gameData.boardLayout);
                if (boardIsMissingOrDifferent) {
                    logEvent("UpdateLocalUI: Setting up/refreshing board from Firestore data.");
                    setupBoardFromFirestore(gameData); 
                } else {
                    updateBoardDynamicElements(gameData);
                }
            } else {
                logEvent("UpdateLocalUI: gameData.boardLayout is missing or empty. Board not set up/updated.");
            }

            updateDiceUIDisplay(gameData); 
            updatePlayerInfoPanel(gameData); 
            updateGameStatusPanel(gameData);
            updateControlsBasedOnTurn(gameData); 
            updateUkGovDisplay(gameData.ukGovMoney);

            if (gameData.preGamePhase && gameData.status === "active") { 
                updatePreGameRollUI(gameData);
            } else {
                if(preGameRollArea) preGameRollArea.style.display = 'none';
            }

            if (gameData.status === "finished") {
                handleGameEndUI(gameData);
            } 
        }
        
        // --- ACTION HANDLERS (Dice, Turn, Property, etc.) ---

        // New function to animate player movement step-by-step
        async function animatePlayerMove(playerId, startPos, steps, currentBoardLayout) {
            const token = document.getElementById(`player-token-${playerId}`);
            if (!token || !currentBoardLayout || currentBoardLayout.length === 0) return;

            let currentVisualPos = startPos;
            const stepDelay = 200; // Milliseconds per step, adjust for desired speed

            for (let i = 0; i < steps; i++) {
                currentVisualPos = (currentVisualPos + 1) % currentBoardLayout.length;
                const nextSpaceEl = document.getElementById(`space-${currentVisualPos}`);
                
                if (nextSpaceEl) {
                    nextSpaceEl.appendChild(token); // Move token to the new space
                    
                    // Apply a brief animation for the step
                    token.classList.remove('token-arrive-step'); 
                    void token.offsetWidth; // Force reflow to restart animation if already applied
                    token.classList.add('token-arrive-step');
                }

                if (audioContextStarted && toneSynth) {
                    try {
                        // Play a short, high-pitched sound for each step
                        toneSynth.triggerAttackRelease("A5", "32n", Tone.now() + (i * 0.02)); // Stagger slightly if steps are very fast
                    } catch (e) { 
                        console.error("Token move sound error:", e); 
                    }
                }
                await new Promise(resolve => setTimeout(resolve, stepDelay));
            }
        }


        async function handleRollDiceAction() {
            if (!currentGameId || !localGameData || !localGameData.playerOrder || localGameData.playerOrder[localGameData.currentPlayerIndex] !== currentUserId) {
                showMessageModal("Not your turn", "It's not your turn to roll the dice.");
                return;
            }
             if (localGameData.preGamePhase) {
                showMessageModal("Game Phase Error", "Cannot roll main dice during pre-game roll phase. Use 'Roll to Start'.");
                return;
            }
            if (localGameData.gamePhase !== "main") {
                showMessageModal("Game Phase Error", "Cannot roll dice before the main game has started.");
                return;
            }
            if (!localGameData.players || !localGameData.players[currentUserId]) {
                 showMessageModal("Error", "Player data not found."); return;
            }
            
            const currentPlayerStateFromLocal = localGameData.players[currentUserId]; // Use local for initial checks
            if (currentPlayerStateFromLocal.playerActionTakenThisTurn && !(localGameData.lastDiceRoll?.isDoubles && currentPlayerStateFromLocal.doublesRolledInTurn < 3 && currentPlayerStateFromLocal.doublesRolledInTurn > 0)) {
                 showMessageModal("Action Taken", "You've already completed your roll action for this part of the turn.");
                return;
            }
             if (currentPlayerStateFromLocal.inDetention) {
                 showMessageModal("In Detention", "You are in detention. Use detention actions (roll for doubles, pay, or use card).");
                return;
            }

            if(rollDiceButton) rollDiceButton.disabled = true; 

            const die1 = Math.floor(Math.random() * 6) + 1;
            const die2 = Math.floor(Math.random() * 6) + 1;
            const totalRoll = die1 + die2;
            let isDoubles = die1 === die2; // Changed from const to let

            // Play dice roll sound immediately
            if (audioContextStarted && toneSynth) {
                try {
                    toneSynth.triggerAttackRelease("C4", "16n", Tone.now());
                    setTimeout(() => { if (toneSynth) toneSynth.triggerAttackRelease("E4", "16n", Tone.now() + 0.1); }, 100);
                } catch (e) { console.error("Dice roll sound error:", e); }
            }
            
            // Perform client-side animation first
            // Use the player's current position from localGameData for the animation start
            const playerStartPosForAnim = localGameData.players[currentUserId].position;
            await animatePlayerMove(currentUserId, playerStartPosForAnim, totalRoll, localGameData.boardLayout);


            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game document not found during roll.");
                    const freshGameData = freshGameDoc.data();
                    
                    const playerState = freshGameData.players[currentUserId]; 
                    if (!playerState || playerState.isBankrupt) throw new Error("Player data missing or bankrupt in Firestore during roll.");
                    if (freshGameData.playerOrder[freshGameData.currentPlayerIndex] !== currentUserId) {
                        throw new Error("Not your turn (checked in transaction).");
                    }
                     if (playerState.inDetention) { 
                        throw new Error("Still in detention (checked in transaction).");
                    }

                    let newPosition = playerState.position; // This is the position *before* the current roll
                    let messages = [];
                    let updates = {};

                    let currentDoublesCount = playerState.doublesRolledInTurn || 0;
                    if (isDoubles) {
                        currentDoublesCount++;
                    } else {
                        currentDoublesCount = 0; 
                    }
                    updates[`players.${currentUserId}.doublesRolledInTurn`] = currentDoublesCount;
                    
                    if (isDoubles && currentDoublesCount === 3) {
                        messages.push(`${playerState.name} rolled 3 doubles! Sent to Detention.`);
                        newPosition = detentionCenterSpaceId; 
                        updates[`players.${currentUserId}.position`] = newPosition;
                        updates[`players.${currentUserId}.inDetention`] = true;
                        updates[`players.${currentUserId}.missedTurnsInDetention`] = 0; 
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = true; 
                        updates[`players.${currentUserId}.doublesRolledInTurn`] = 0; 
                    } else {
                        // Calculate the final position based on the state *before* this roll
                        newPosition = (playerState.position + totalRoll) % freshGameData.boardLayout.length;
                        updates[`players.${currentUserId}.position`] = newPosition;
                        const landedSpace = freshGameData.boardLayout[newPosition];
                        messages.push(`${playerState.name} rolled ${totalRoll} (${die1}, ${die2})${isDoubles ? " (Doubles!)" : ""}. Moved to ${landedSpace.name}.`);

                        // Check for passing GO
                        let passedGo = false;
                        if (playerState.position + totalRoll >= freshGameData.boardLayout.length && !(isDoubles && currentDoublesCount ===3) && !playerState.inDetention ) {
                             passedGo = true;
                        }
                        if (passedGo) {
                            const goPayout = 400; // Standard GO payout
                            updates[`players.${currentUserId}.money`] = (playerState.money || 0) + goPayout;
                            updates.ukGovMoney = (freshGameData.ukGovMoney || 0) - goPayout; 
                            updates[`players.${currentUserId}.govReceived`] = (playerState.govReceived || 0) + goPayout;
                            messages.push(`${playerState.name} passed Dole and collected Â£${goPayout}.`);
                        }

                        // Handle landing on specific spaces
                        if (landedSpace.type === 'payout' && landedSpace.amount) {
                            updates[`players.${currentUserId}.money`] = (updates[`players.${currentUserId}.money`] || playerState.money) + landedSpace.amount;
                            updates.ukGovMoney = (updates.ukGovMoney || freshGameData.ukGovMoney) - landedSpace.amount;
                            updates[`players.${currentUserId}.govReceived`] = (updates[`players.${currentUserId}.govReceived`] || playerState.govReceived || 0) + landedSpace.amount;
                            messages.push(`${playerState.name} collected Â£${landedSpace.amount} from ${landedSpace.name}.`);
                        } else if (landedSpace.type === 'tax' && landedSpace.amount) {
                            updates[`players.${currentUserId}.money`] = (playerState.money || 0) - landedSpace.amount;
                            updates.bankMoney = (freshGameData.bankMoney || 0) + landedSpace.amount; // Tax goes to bank
                            messages.push(`${playerState.name} paid Â£${landedSpace.amount} for ${landedSpace.name}.`);
                        } else if (landedSpace.type === 'crime_spree' && landedSpace.amount) {
                            // Crime Spree: Fine only, no detention
                            updates[`players.${currentUserId}.money`] = (playerState.money || 0) - landedSpace.amount;
                            updates.bankMoney = (freshGameData.bankMoney || 0) + landedSpace.amount; // Fine goes to bank
                            messages.push(`${playerState.name} landed on Crime Spree and was fined Â£${landedSpace.amount}!`);
                            // Player continues their turn if they rolled doubles and it wasn't the 3rd.
                            // playerActionTakenThisTurn will be set based on isDoubles below.
                        } else if (landedSpace.type === 'go_to_detention') {
                            // Go to Detention Center: No fine, just go to jail
                            updates[`players.${currentUserId}.position`] = detentionCenterSpaceId;
                            updates[`players.${currentUserId}.inDetention`] = true;
                            updates[`players.${currentUserId}.missedTurnsInDetention`] = 0;
                            messages.push(`${playerState.name} was sent to Detention!`);
                            isDoubles = false; // Going to jail overrides doubles continuation
                            currentDoublesCount = 0; // Reset doubles count
                            updates[`players.${currentUserId}.doublesRolledInTurn`] = 0;
                        }
                        
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = !isDoubles;
                    }
                    
                    updates.lastDiceRoll = { die1, die2, total: totalRoll, isDoubles };
                    updates.lastActionMessage = messages.join(" ");
                    updates.updatedAt = serverTimestamp();
                    transaction.update(gameDocRef, updates);
                });
            } catch (error) {
                console.error("Error during roll dice action transaction:", error);
                showMessageModal("Roll Error", "Could not process roll transaction: " + error.message);
            }

            // After transaction, check the new position and show card if needed
            // Use the latest localGameData (will be updated by onSnapshot, but we can check immediately for responsiveness)
            setTimeout(() => {
                const gameData = localGameData;
                if (!gameData || !gameData.players || !gameData.players[currentUserId]) return;
                const player = gameData.players[currentUserId];
                const board = gameData.boardLayout;
                if (!board) return;
                const landedSpace = board[player.position];
                if (!landedSpace) return;
                if (landedSpace.type === 'opportunity') {
                    drawAndShowOpportunityCard(currentUserId);
                } else if (landedSpace.type === 'welfare') {
                    drawAndShowWelfareCard(currentUserId);
                }
            }, 350); // Delay to allow UI and state to update
        }
        
        async function handleEndTurnAction() {
            logEvent("handleEndTurnAction called."); 

            if (!currentGameId || !localGameData || !currentUserId || !db) {
                logEvent("EndTurn: Exiting - Missing critical global vars."); 
                showMessageModal("Error", "Game data or connection issue.");
                return;
            }

            const gameDataForCheck = localGameData; 
            const currentPlayerId = gameDataForCheck.playerOrder[gameDataForCheck.currentPlayerIndex]; 
            
            if (gameDataForCheck.players && gameDataForCheck.players[currentUserId]) {
                const pState = gameDataForCheck.players[currentUserId];
                logEvent(`EndTurn Initial Check: Player ${currentUserId} (current turn player: ${currentPlayerId})
                    playerActionTakenThisTurn: ${pState.playerActionTakenThisTurn}, 
                    inDetention: ${pState.inDetention},
                    doublesRolledInTurn: ${pState.doublesRolledInTurn},
                    lastDiceRoll.isDoubles: ${gameDataForCheck.lastDiceRoll?.isDoubles}`);
            } else {
                logEvent("EndTurn Initial Check: Player data for currentUserId not found in localGameData.");
            }


            if (currentPlayerId !== currentUserId) { 
                logEvent(`EndTurn: ERROR - It's not your turn! Expected: ${currentPlayerId}, You are: ${currentUserId}.`);
                showMessageModal("Error", "It's not your turn to end.");
                return;
            }

            const playerState = gameDataForCheck.players[currentUserId]; 
            if (!playerState || playerState.isBankrupt) {
                logEvent(`EndTurn: Exiting - Player state error or bankrupt.`);
                showMessageModal("Error", "Cannot end turn (player state error or bankrupt).");
                return;
            }
            
            if (gameDataForCheck.lastDiceRoll?.isDoubles && 
                (playerState.doublesRolledInTurn || 0) > 0 && 
                (playerState.doublesRolledInTurn || 0) < 3 && 
                !playerState.inDetention &&
                !playerState.playerActionTakenThisTurn) { 
                logEvent("EndTurn: Exiting - Player must roll again (doubles).");
                showMessageModal("Doubles!", "You rolled doubles, please roll again before ending your turn!");
                return;
            }
            if (!playerState.playerActionTakenThisTurn && !playerState.inDetention) { 
                logEvent("EndTurn: Exiting - Player has not taken their main action (e.g., rolled dice). playerActionTakenThisTurn is false.");
                showMessageModal("Action Required", "You must take an action (e.g., roll dice) before ending your turn.");
                return;
            }
            
            logEvent("EndTurn: Proceeding to transaction.");
            if(endTurnButton) endTurnButton.disabled = true;

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game not found for end turn.");
                    const freshGameData = freshGameDoc.data();

                    if (freshGameData.playerOrder[freshGameData.currentPlayerIndex] !== currentUserId) {
                        logEvent("EndTurn TXN: Turn already changed. Aborting.");
                        return; 
                    }
                    const freshPlayerState = freshGameData.players[currentUserId];
                     if (!freshPlayerState || freshPlayerState.isBankrupt) {
                        logEvent("EndTurn TXN: Player bankrupt/missing. Aborting.");
                        return; 
                    }
                    if (freshGameData.lastDiceRoll?.isDoubles && 
                        (freshPlayerState.doublesRolledInTurn || 0) > 0 && 
                        (freshPlayerState.doublesRolledInTurn || 0) < 3 &&
                        !freshPlayerState.inDetention &&
                        !freshPlayerState.playerActionTakenThisTurn) { 
                        logEvent("EndTurn TXN: Must roll again (doubles) based on fresh data. Aborting.");
                        return; 
                    }
                     if (!freshPlayerState.playerActionTakenThisTurn && !freshPlayerState.inDetention) {
                        logEvent("EndTurn TXN: Player action not taken in fresh data. Aborting. playerActionTakenThisTurn is false.");
                        return;
                    }


                    let updates = {};
                    updates[`players.${currentUserId}.playerActionTakenThisTurn`] = false; 
                    updates[`players.${currentUserId}.doublesRolledInTurn`] = 0;      

                    let nextPlayerIndex = (freshGameData.currentPlayerIndex + 1) % freshGameData.playerOrder.length;
                    let nextPlayerId = freshGameData.playerOrder[nextPlayerIndex];
                    let attempts = 0;
                    const maxAttempts = freshGameData.playerOrder.length;

                    while (freshGameData.players[nextPlayerId]?.isBankrupt && attempts < maxAttempts) {
                        nextPlayerIndex = (nextPlayerIndex + 1) % freshGameData.playerOrder.length;
                        nextPlayerId = freshGameData.playerOrder[nextPlayerIndex];
                        attempts++;
                    }

                    const nonBankruptPlayers = freshGameData.playerOrder.filter(pid => !freshGameData.players[pid]?.isBankrupt);

                    if (nonBankruptPlayers.length <= 1 && freshGameData.playerOrder.length > 1) { 
                         updates.status = "finished";
                         const winnerName = nonBankruptPlayers.length === 1 ? freshGameData.players[nonBankruptPlayers[0]].name : "No one";
                         updates.lastActionMessage = `Game Over! ${winnerName} is the winner!`;
                         logEvent(`Game ended. Winner: ${winnerName}`);
                    } else if (attempts >= maxAttempts && nonBankruptPlayers.length > 1) { 
                        logEvent("Error in turn progression: Loop completed but non-bankrupt players should exist.");
                        updates.status = "finished"; 
                        updates.lastActionMessage = "Error finding next player. Game Over.";
                    } else if (nonBankruptPlayers.length === 0 && freshGameData.playerOrder.length >=1){ 
                        updates.status = "finished";
                        updates.lastActionMessage = "All players are bankrupt! Game Over!";
                    }
                    else { 
                        updates.currentPlayerIndex = nextPlayerIndex;
                        updates.lastActionMessage = `${freshPlayerState.name} ended their turn. It's now ${freshGameData.players[nextPlayerId].name}'s turn.`;
                        updates.lastDiceRoll = null; 
                    }
                    
                    updates.updatedAt = serverTimestamp();
                    transaction.update(gameDocRef, updates);
                    logEvent(`EndTurn TXN: ${freshPlayerState.name} ended turn. Next is ${nextPlayerId || 'N/A'}.`);
                });
            } catch (error) {
                console.error("Error ending turn (transaction phase):", error);
                showMessageModal("End Turn Error", "Could not end turn: " + error.message);
            } finally {
                 // UI will update via onSnapshot
            }
        }

        async function handleBuyPropertyAction() {
            logEvent("BuyProp: Action initiated by user: " + currentUserId); // Log 1

            if (!currentGameId || !localGameData || !currentUserId || !db) {
                logEvent("BuyProp: Exiting - Missing critical global vars.", { currentGameId, localGameDataExists: !!localGameData, currentUserId, dbExists: !!db }); // Log 2
                showMessageModal("Error", "Game data or connection issue.");
                return;
            }

            const currentSnapshotGameData = localGameData; 
            const currentPlayerIdFromOrder = currentSnapshotGameData.playerOrder[currentSnapshotGameData.currentPlayerIndex];
            logEvent("BuyProp: Current turn player from order: " + currentPlayerIdFromOrder + ", current user: " + currentUserId); // Log 3

            if (currentPlayerIdFromOrder !== currentUserId) {
                logEvent(`BuyProp: Exiting - Not current player's turn. Expected: ${currentPlayerIdFromOrder}`); // Log 4
                showMessageModal("Error", "Not your turn to buy property.");
                return;
            }

            const playerState = currentSnapshotGameData.players[currentUserId];
            if (!playerState) {
                logEvent("BuyProp: Exiting - Player state not found for user: " + currentUserId); // Log 5
                showMessageModal("Error", "Player data not found.");
                return;
            }
            if (playerState.isBankrupt) {
                logEvent(`BuyProp: Exiting - Player ${currentUserId} is bankrupt.`); // Log 6
                showMessageModal("Error", "Cannot buy property (player is bankrupt).");
                return;
            }
            
            logEvent("BuyProp: Player state check passed.", { playerMoney: playerState.money, playerActionTaken: playerState.playerActionTakenThisTurn, lastDiceRoll: currentSnapshotGameData.lastDiceRoll }); // Log 7

            // Allow buying if player has landed (lastDiceRoll is set from their current turn segment) 
            // OR if playerActionTakenThisTurn is true (meaning they completed a roll/move that wasn't doubles needing a re-roll).
            if (!currentSnapshotGameData.lastDiceRoll && !playerState.playerActionTakenThisTurn) {
                 logEvent("BuyProp: Exiting - Player has not rolled/landed yet in this turn segment (no lastDiceRoll and playerActionTakenThisTurn is false)."); // Log 8
                 showMessageModal("Action Required", "You must roll and land on a space before buying property.");
                 return;
            }

            const currentPosition = playerState.position;
            const spaceDetails = currentSnapshotGameData.boardLayout[currentPosition];
            logEvent("BuyProp: Attempting to buy space:", { position: currentPosition, spaceDetails }); // Log 9

            const propertyDataEntry = Array.isArray(currentSnapshotGameData.propertyData) ? 
                                      currentSnapshotGameData.propertyData.find(p => p.id === currentPosition) : null;

            if (!spaceDetails || !propertyDataEntry || (spaceDetails.type !== 'property' && spaceDetails.type !== 'set_property')) {
                logEvent(`BuyProp: Exiting - Not a buyable property. Space type: ${spaceDetails?.type}, Prop entry exists: ${!!propertyDataEntry}`); // Log 10
                showMessageModal("Invalid Space", "Not a buyable property space.");
                return;
            }

            if (propertyDataEntry.owner) {
                logEvent(`BuyProp: Exiting - Property already owned by ${propertyDataEntry.owner}`); // Log 11
                showMessageModal("Owned", `This property (${spaceDetails.name}) is already owned by ${currentSnapshotGameData.players[propertyDataEntry.owner]?.name || 'another player'}.`);
                return;
            }

            let price = spaceDetails.price;
            let usedVoucher = false;
            if (playerState.hasHousingVoucher && spaceDetails.type === 'property') { 
                price = Math.round(price * 0.75);
                usedVoucher = true;
                logEvent("BuyProp: Housing voucher applied. New price: " + price); // Log 12
            }

            if (playerState.money < price) {
                logEvent(`BuyProp: Exiting - Insufficient funds. Needs: ${price}, Has: ${playerState.money}`); // Log 13
                showMessageModal("Insufficient Funds", `You need Â£${price} to buy ${spaceDetails.name}, but you only have Â£${playerState.money}.`);
                return;
            }
            
            logEvent("BuyProp: All pre-transaction checks passed. Disabling button and starting transaction."); // Log 14
            if(buyPropertyButton) buyPropertyButton.disabled = true;

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    logEvent("BuyProp TXN: Inside transaction."); // Log TXN 1
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) {
                        logEvent("BuyProp TXN: Game doc not found."); // Log TXN 2
                        throw new Error("Game not found for buying property.");
                    }
                    const freshGameData = freshGameDoc.data();
                    logEvent("BuyProp TXN: Fetched fresh game data."); // Log TXN 3

                    if (freshGameData.playerOrder[freshGameData.currentPlayerIndex] !== currentUserId) {
                        logEvent("BuyProp TXN: Not player's turn in fresh data."); // Log TXN 4
                        throw new Error("Not your turn (checked in transaction).");
                    }
                    const freshPlayerState = freshGameData.players[currentUserId];
                    if (!freshPlayerState || freshPlayerState.isBankrupt) {
                        logEvent("BuyProp TXN: Player state error/bankrupt in fresh data."); // Log TXN 5
                        throw new Error("Player error in transaction.");
                    }
                    
                    // Re-check this condition with fresh data.
                    if (!freshGameData.lastDiceRoll && !freshPlayerState.playerActionTakenThisTurn) {
                         logEvent("BuyProp TXN: Player has not rolled/landed (fresh data)."); // Log TXN 5.1
                         throw new Error("Player action not completed (checked in transaction).");
                    }

                    const freshCurrentPosition = freshPlayerState.position; 
                    const actualSpaceDetails = freshGameData.boardLayout[freshCurrentPosition];
                    logEvent("BuyProp TXN: Fresh player position: " + freshCurrentPosition); // Log TXN 6
                    
                    if (!Array.isArray(freshGameData.propertyData)) { 
                        logEvent("BuyProp TXN: propertyData is not an array in fresh data."); // Log TXN 7
                        throw new Error("Property data in Firestore is not an array. Cannot buy.");
                    }
                    const freshPropertyDataEntry = freshGameData.propertyData.find(p => p.id === freshCurrentPosition);

                    if (!actualSpaceDetails || !freshPropertyDataEntry || (actualSpaceDetails.type !== 'property' && actualSpaceDetails.type !== 'set_property')) {
                         logEvent("BuyProp TXN: Not a buyable space in fresh data.", {actualSpaceDetails, freshPropertyDataEntry}); // Log TXN 8
                         throw new Error("Not a buyable property space (checked in transaction).");
                    }
                    if (freshPropertyDataEntry.owner) {
                        logEvent("BuyProp TXN: Property already owned in fresh data by " + freshPropertyDataEntry.owner); // Log TXN 9
                        throw new Error(`Property (${actualSpaceDetails.name}) already owned by ${freshGameData.players[freshPropertyDataEntry.owner]?.name || 'another player'} (checked in transaction).`);
                    }
                    
                    let actualPrice = actualSpaceDetails.price;
                    let actualUsedVoucher = false;
                    if (freshPlayerState.hasHousingVoucher && actualSpaceDetails.type === 'property') {
                        actualPrice = Math.round(actualPrice * 0.75);
                        actualUsedVoucher = true;
                    }
                    if (freshPlayerState.money < actualPrice) {
                         logEvent("BuyProp TXN: Insufficient funds in fresh data.", {needed: actualPrice, has: freshPlayerState.money}); // Log TXN 10
                         throw new Error(`Insufficient funds (Â£${freshPlayerState.money} vs Â£${actualPrice}) for ${actualSpaceDetails.name} (checked in transaction).`);
                    }

                    let updates = {};
                    updates[`players.${currentUserId}.money`] = freshPlayerState.money - actualPrice;
                    updates[`players.${currentUserId}.properties`] = arrayUnion(freshCurrentPosition); 
                    if (actualUsedVoucher) {
                        updates[`players.${currentUserId}.hasHousingVoucher`] = false;
                    }
                    
                    const updatedPropertyData = freshGameData.propertyData.map(prop => {
                        if (prop.id === freshCurrentPosition) {
                            return { ...prop, owner: currentUserId };
                        }
                        return prop;
                    });
                    updates.propertyData = updatedPropertyData; 

                    updates.lastActionMessage = `${freshPlayerState.name} bought ${actualSpaceDetails.name} for Â£${actualPrice}${actualUsedVoucher ? " (with voucher)" : ""}.`;
                    updates.updatedAt = serverTimestamp();

                    // If player did NOT roll doubles, buying property means their main action for this turn segment is done.
                    // If they DID roll doubles, playerActionTakenThisTurn was already false (from roll action) and stays false,
                    // correctly indicating they still need to roll again.
                    if (!freshGameData.lastDiceRoll?.isDoubles) {
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = true;
                         logEvent("BuyProp TXN: Non-doubles roll, setting playerActionTakenThisTurn to true."); // Log TXN 11
                    } else {
                        // If it was doubles, playerActionTakenThisTurn should remain false (as set by handleRollDiceAction)
                        // because they still need to roll again. Buying is an interim action.
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = false; 
                        logEvent("BuyProp TXN: Doubles roll, playerActionTakenThisTurn explicitly set to false to ensure re-roll."); // Log TXN 12
                    }


                    transaction.update(gameDocRef, updates);
                    logEvent("BuyProp TXN: Transaction update successful."); // Log TXN 13

                    if (audioContextStarted && toneSynth) {
                        try {
                            toneSynth.triggerAttackRelease("A3", "16n", Tone.now()); 
                            toneSynth.triggerAttackRelease("F#3", "16n", Tone.now() + 0.07); 
                        } catch(e){ console.error("Buy property sound error:", e); }
                    }
                });
                logEvent("BuyProp: Transaction completed successfully."); // Log 15
            } catch (error) {
                console.error("Error buying property (transaction phase):", error); // Log 16
                showMessageModal("Buy Property Error", "Could not buy property: " + error.message);
            } finally {
                 // Button state will be updated by onSnapshot -> updateControlsBasedOnTurn
                 logEvent("BuyProp: Action finished (successfully or with error)."); // Log 17
            }
        }

        async function handlePreGameRollAction() {
            if (!currentGameId || !localGameData || !localGameData.preGamePhase) {
                showMessageModal("Error", "Not in pre-game roll phase.");
                return;
            }
             if (Object.keys(localGameData.players).length < localGameData.maxPlayers) {
                showMessageModal("Waiting", "Waiting for all players to join before rolling.");
                return;
            }
            if (localGameData.preGameRolls && localGameData.preGameRolls[currentUserId] !== undefined) {
                showMessageModal("Already Rolled", "You have already rolled for starting position.");
                return;
            }

            let nextToRollInPreGame = null;
            const sortedByJoinOrderForPreGame = [...localGameData.playerOrder].sort((a,b) => (localGameData.players[a]?.order || 0) - (localGameData.players[b]?.order || 0));
            for (const pid of sortedByJoinOrderForPreGame) {
                if (!localGameData.preGameRolls || localGameData.preGameRolls[pid] === undefined) {
                    nextToRollInPreGame = pid;
                    break;
                }
            }
            if (nextToRollInPreGame !== currentUserId) {
                showMessageModal("Wait", "It's not your turn to roll for starting position.");
                return;
            }


            if(preGameRollButton) preGameRollButton.disabled = true;
            const roll = Math.floor(Math.random() * 6) + 1 + Math.floor(Math.random() * 6) + 1; 

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game not found for pre-game roll.");
                    const freshGameData = freshGameDoc.data();
                     if (!freshGameData.players || !freshGameData.players[currentUserId]) throw new Error("Player data missing in Firestore for pre-game roll.");
                     if (!freshGameData.preGamePhase) throw new Error("Pre-game phase ended."); 
                     if (freshGameData.preGameRolls && freshGameData.preGameRolls[currentUserId] !== undefined) {
                         throw new Error("Already rolled (checked in transaction).");
                     }

                    let updates = {};
                    updates[`preGameRolls.${currentUserId}`] = roll;
                    updates.lastActionMessage = `${freshGameData.players[currentUserId].name} rolled ${roll} for starting order.`;
                    updates.updatedAt = serverTimestamp();

                    const currentPreGameRollsWithThis = { ...(freshGameData.preGameRolls || {}), [currentUserId]: roll };
                    const allPlayersInOrder = freshGameData.playerOrder || [];
                    const allHaveRolled = allPlayersInOrder.length > 0 && 
                                          allPlayersInOrder.length === freshGameData.maxPlayers &&
                                          allPlayersInOrder.every(pid => currentPreGameRollsWithThis[pid] !== undefined);


                    if (allHaveRolled) { 
                        updates.lastActionMessage += " All players rolled.";
                        if (currentUserId === freshGameData.hostId) { 
                            logEvent("Host is the last to roll (or among the last) in pre-game, finalizing directly.");
                            const sortedPlayerIds = [...allPlayersInOrder].sort((a, b) => {
                                const rollA = currentPreGameRollsWithThis[a]; 
                                const rollB = currentPreGameRollsWithThis[b];
                                if (rollB === rollA) { 
                                    return (freshGameData.players[a]?.order || 0) - (freshGameData.players[b]?.order || 0);
                                }
                                return rollB - rollA; 
                            });
                            updates.playerOrder = sortedPlayerIds; 
                            updates.currentPlayerIndex = 0; 
                            updates.preGamePhase = false; 
                            updates.gamePhase = "main"; 
                            updates.status = "active";
                            updates.lastActionMessage = `Starting order determined. ${freshGameData.players[sortedPlayerIds[0]].name} starts!`;
                        } else {
                            updates.lastActionMessage += " Waiting for host to finalize starting order.";
                        }
                    }
                    transaction.update(gameDocRef, updates);
                });
            } catch (error) {
                console.error("Error during pre-game roll:", error);
                showMessageModal("Roll Error", "Could not process pre-game roll: " + error.message);
                if(preGameRollButton) preGameRollButton.disabled = false; 
            }
        }


        // --- Event Listeners ---
        createGameButton.onclick = handleCreateGame;
        joinGameButton.onclick = handleJoinGame;
        rollDiceButton.onclick = handleRollDiceAction; 
        preGameRollButton.onclick = handlePreGameRollAction;
        endTurnButton.onclick = handleEndTurnAction; 
        buyPropertyButton.onclick = handleBuyPropertyAction; 
        developPropertyButton.onclick = () => { // Added click listener
            if (localGameData && currentUserId && localGameData.players && localGameData.players[currentUserId]) {
                showDevelopPropertyOptions(localGameData.players[currentUserId], localGameData);
            }
        };
        closeDevelopButton.onclick = () => {
            if(developPropertyContainer) developPropertyContainer.style.display = 'none';
        };
        
        generatedGameIdSpan.onclick = () => {
            if (generatedGameIdSpan.textContent) {
                const textArea = document.createElement("textarea");
                textArea.value = generatedGameIdSpan.textContent;
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy'); 
                    showMessageModal("Copied!", "Game ID copied to clipboard.");
                } catch (err) {
                    console.error('Fallback: Oops, unable to copy', err);
                    showMessageModal("Copy Failed", "Could not copy Game ID automatically. Please select and copy manually.");
                }
                document.body.removeChild(textArea);
            }
        };
        
        function shuffleDeck(deck) { 
            let newDeck = [...deck];
            for (let i = newDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
            }
            return newDeck;
        }

        function canPlayerDevelopAnyProperty(playerState, gameData) {
            if (!playerState || playerState.isBankrupt || !gameData || !Array.isArray(gameData.propertyData) || !gameData.boardLayout) return false;
            
            return playerState.properties.some(propId => {
                const propDetails = gameData.propertyData.find(p => p.id === propId);
                const propLayout = gameData.boardLayout.find(s => s.id === propId);

                if (!propDetails || !propLayout || propLayout.type !== 'property') return false; 
                if (propDetails.owner !== playerState.id || propDetails.permanentResidence) return false; 

                const groupPropertiesLayout = gameData.boardLayout.filter(s => s.groupId === propLayout.groupId && s.type === 'property');
                const ownsAllInGroup = groupPropertiesLayout.every(gpLayout => {
                    const gpDataForCheck = gameData.propertyData.find(pd => pd.id === gpLayout.id);
                    return gpDataForCheck && gpDataForCheck.owner === playerState.id;
                });
                if (!ownsAllInGroup) return false;
                
                return (propDetails.tenancies < MAX_TENANCIES) || (propDetails.tenancies === MAX_TENANCIES && !propDetails.permanentResidence);
            });
        }
        
        function setupDetentionActionsUI(playerState, gameData) {
            if (!playerState || !playerState.inDetention || !detentionActionsDiv) return;
            detentionActionsDiv.innerHTML = ''; 

            const canTakeAction = gameData.playerOrder[gameData.currentPlayerIndex] === currentUserId && !playerState.playerActionTakenThisTurn;

            if (playerState.getOutOfDetentionCards > 0) {
                const useCardBtn = document.createElement('button');
                useCardBtn.textContent = "Use Legal Aid Card";
                useCardBtn.disabled = !canTakeAction;
                useCardBtn.onclick = async () => { 
                    const gameDocRef = doc(db, "games", currentGameId);
                    try {
                        await updateDoc(gameDocRef, {
                            [`players.${currentUserId}.getOutOfDetentionCards`]: playerState.getOutOfDetentionCards - 1,
                            [`players.${currentUserId}.inDetention`]: false,
                            [`players.${currentUserId}.missedTurnsInDetention`]: 0,
                            [`players.${currentUserId}.playerActionTakenThisTurn`]: false, 
                            lastActionMessage: `${playerState.name} used a Legal Aid card and is free. Roll to move.`,
                            updatedAt: serverTimestamp()
                        });
                    } catch (e) { showMessageModal("Error", "Failed to use card: " + e.message); }
                };
                detentionActionsDiv.appendChild(useCardBtn);
            }

            const fineAmount = 50;
            if (playerState.money >= fineAmount) {
                const payFineBtn = document.createElement('button');
                payFineBtn.textContent = `Pay Â£${fineAmount} Fine`;
                payFineBtn.disabled = !canTakeAction;
                payFineBtn.onclick = async () => { 
                    const gameDocRef = doc(db, "games", currentGameId);
                     try {
                        await updateDoc(gameDocRef, {
                            [`players.${currentUserId}.money`]: playerState.money - fineAmount,
                            [`players.${currentUserId}.inDetention`]: false,
                            [`players.${currentUserId}.missedTurnsInDetention`]: 0,
                            [`players.${currentUserId}.playerActionTakenThisTurn`]: false, 
                            bankMoney: (gameData.bankMoney || 0) + fineAmount, 
                            lastActionMessage: `${playerState.name} paid Â£${fineAmount} fine and is free. Roll to move.`,
                            updatedAt: serverTimestamp()
                        });
                    } catch (e) { showMessageModal("Error", "Failed to pay fine: " + e.message); }
                };
                detentionActionsDiv.appendChild(payFineBtn);
            }

            const rollDoublesBtn = document.createElement('button');
            rollDoublesBtn.textContent = "Roll for Doubles (Exit Jail)";
            rollDoublesBtn.disabled = !canTakeAction;
            rollDoublesBtn.onclick = async () => { 
                const die1 = Math.floor(Math.random() * 6) + 1;
                const die2 = Math.floor(Math.random() * 6) + 1;
                const isDoubles = die1 === die2;
                const totalRoll = die1 + die2; 
                
                const gameDocRef = doc(db, "games", currentGameId);
                let updates = { updatedAt: serverTimestamp(), lastDiceRoll: {die1, die2, total: totalRoll, isDoubles: isDoubles} }; 
                let missedTurns = playerState.missedTurnsInDetention || 0;

                if (isDoubles) {
                    updates[`players.${currentUserId}.inDetention`] = false;
                    updates[`players.${currentUserId}.missedTurnsInDetention`] = 0;
                    updates[`players.${currentUserId}.playerActionTakenThisTurn`] = false; 
                    updates.lastActionMessage = `${playerState.name} rolled doubles (${die1},${die2}) and is out of Detention! Roll again to move.`;
                } else {
                    missedTurns++;
                    updates[`players.${currentUserId}.missedTurnsInDetention`] = missedTurns;
                    updates[`players.${currentUserId}.playerActionTakenThisTurn`] = true; 
                    if (missedTurns >= 3) {
                        updates[`players.${currentUserId}.inDetention`] = false; 
                        updates[`players.${currentUserId}.missedTurnsInDetention`] = 0;
                        updates[`players.${currentUserId}.money`] = (playerState.money || 0) - fineAmount; 
                        updates.bankMoney = (gameData.bankMoney || 0) + fineAmount;
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = false; 
                        updates.lastActionMessage = `${playerState.name} failed to roll doubles for 3 turns, paid Â£${fineAmount} fine and is out. Must roll to move on their next turn.`;
                    } else {
                        updates.lastActionMessage = `${playerState.name} failed to roll doubles (${die1},${die2}) in detention. Still in detention. ${3 - missedTurns} attempt(s) left.`;
                    }
                }
                 try {
                    await updateDoc(gameDocRef, updates);
                } catch (e) { showMessageModal("Error", "Failed to roll for doubles in detention: " + e.message); }
            };
            detentionActionsDiv.appendChild(rollDoublesBtn);
        }

        function showDevelopPropertyOptions(playerState, gameData) {
            if (!developPropertyContainer || !developPropertyOptionsDiv || !developPropertyNameH3) return;

            developPropertyOptionsDiv.innerHTML = ''; // Clear previous options
            developPropertyNameH3.textContent = "Develop Property"; // Reset title

            let canDevelopAnything = false;

            playerState.properties.forEach(propId => {
                const propLayout = gameData.boardLayout.find(s => s.id === propId);
                const propData = gameData.propertyData.find(p => p.id === propId);

                if (propLayout && propData && propLayout.type === 'property' && propData.owner === playerState.id) {
                    // Check if player owns all properties in the group
                    const groupPropertiesLayout = gameData.boardLayout.filter(s => s.groupId === propLayout.groupId && s.type === 'property');
                    const ownsAllInGroup = groupPropertiesLayout.every(gpLayout => {
                        const gpDataForCheck = gameData.propertyData.find(pd => pd.id === gpLayout.id);
                        return gpDataForCheck && gpDataForCheck.owner === playerState.id;
                    });

                    if (ownsAllInGroup) {
                        if (!propData.permanentResidence && propData.tenancies < MAX_TENANCIES) {
                            const addTenancyButton = document.createElement('button');
                            addTenancyButton.textContent = `Add Tenancy to ${propLayout.name} (Â£${TENANCY_COST})`;
                            addTenancyButton.disabled = playerState.money < TENANCY_COST;
                            addTenancyButton.onclick = () => handleConfirmDevelopment(propId, 'tenancy');
                            developPropertyOptionsDiv.appendChild(addTenancyButton);
                            canDevelopAnything = true;
                        }
                        if (!propData.permanentResidence && propData.tenancies === MAX_TENANCIES) {
                            const buildPRButton = document.createElement('button');
                            buildPRButton.textContent = `Build PR on ${propLayout.name} (Â£${PR_COST})`;
                            buildPRButton.disabled = playerState.money < PR_COST;
                            buildPRButton.onclick = () => handleConfirmDevelopment(propId, 'pr');
                            developPropertyOptionsDiv.appendChild(buildPRButton);
                            canDevelopAnything = true;
                        }
                    }
                }
            });

            if (!canDevelopAnything) {
                developPropertyOptionsDiv.innerHTML = '<p>No properties currently eligible for development.</p>';
            }
            developPropertyContainer.style.display = 'block';
        }

        async function handleConfirmDevelopment(propertyId, developmentType) {
            logEvent(`handleConfirmDevelopment called for prop: ${propertyId}, type: ${developmentType}`);
            if (!currentGameId || !localGameData || !currentUserId || !db) {
                showMessageModal("Error", "Game data or connection issue.");
                return;
            }

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game not found for development.");
                    
                    const freshGameData = freshGameDoc.data();
                    const playerState = freshGameData.players[currentUserId];
                    const propLayout = freshGameData.boardLayout.find(s => s.id === propertyId);
                    const propDataIndex = freshGameData.propertyData.findIndex(p => p.id === propertyId);

                    if (propDataIndex === -1 || !propLayout || !playerState) {
                        throw new Error("Property or player data not found for development.");
                    }
                    const propData = freshGameData.propertyData[propDataIndex];

                    // Validation
                    if (freshGameData.playerOrder[freshGameData.currentPlayerIndex] !== currentUserId) {
                        throw new Error("Not your turn to develop.");
                    }
                    if (propData.owner !== currentUserId) {
                        throw new Error("You do not own this property.");
                    }
                    if (propLayout.type !== 'property') {
                        throw new Error("This type of property cannot be developed.");
                    }

                    // Check group ownership
                    const groupPropertiesLayout = freshGameData.boardLayout.filter(s => s.groupId === propLayout.groupId && s.type === 'property');
                    const ownsAllInGroup = groupPropertiesLayout.every(gpLayout => {
                        const gpDataForCheck = freshGameData.propertyData.find(pd => pd.id === gpLayout.id);
                        return gpDataForCheck && gpDataForCheck.owner === currentUserId;
                    });
                    if (!ownsAllInGroup) {
                        throw new Error(`You must own all properties in the ${propLayout.color || propLayout.groupId} group to develop.`);
                    }

                    let cost = 0;
                    let newTenancies = propData.tenancies;
                    let newPR = propData.permanentResidence;
                    let developmentMessage = "";

                    if (developmentType === 'tenancy') {
                        if (propData.permanentResidence) throw new Error("Cannot add tenancies to a property with Permanent Residence.");
                        if (propData.tenancies >= MAX_TENANCIES) throw new Error("Maximum tenancies reached.");
                        cost = TENANCY_COST;
                        newTenancies++;
                        developmentMessage = `added a tenancy to ${propLayout.name}`;
                    } else if (developmentType === 'pr') {
                        if (propData.permanentResidence) throw new Error("Permanent Residence already built.");
                        if (propData.tenancies < MAX_TENANCIES) throw new Error(`Must have ${MAX_TENANCIES} tenancies to build PR.`);
                        cost = PR_COST;
                        newPR = true;
                        developmentMessage = `built Permanent Residence on ${propLayout.name}`;
                    } else {
                        throw new Error("Invalid development type.");
                    }

                    if (playerState.money < cost) {
                        throw new Error(`Insufficient funds. Need Â£${cost}.`);
                    }

                    // Prepare updates
                    const updates = {};
                    updates[`players.${currentUserId}.money`] = playerState.money - cost;
                    
                    // Create a new propertyData array with the updated property
                    const updatedPropertyDataArray = freshGameData.propertyData.map((p, index) => {
                        if (index === propDataIndex) {
                            return { ...p, tenancies: newTenancies, permanentResidence: newPR };
                        }
                        return p;
                    });
                    updates.propertyData = updatedPropertyDataArray;
                    
                    updates.lastActionMessage = `${playerState.name} ${developmentMessage} for Â£${cost}.`;
                    updates.updatedAt = serverTimestamp();
                    
                    // playerActionTakenThisTurn should already be true if they are at this stage
                    // unless it's a doubles roll, in which case buying/developing is an interim action.
                    // The existing logic in updateControlsBasedOnTurn and auto-end turn should handle this.

                    transaction.update(gameDocRef, updates);
                    logEvent("Development successful in transaction:", updates);
                });

                developPropertyContainer.style.display = 'none'; // Close modal on success
                // The onSnapshot listener will call updateLocalUIFromFirestore, which calls updateControlsBasedOnTurn
                // updateControlsBasedOnTurn will then trigger auto-end turn logic if applicable.

            } catch (error) {
                console.error("Error confirming development:", error);
                showMessageModal("Development Error", error.message);
                // Re-enable button or close modal might be needed here if transaction fails early
                // but generally onSnapshot will refresh the UI state.
            }
        }


        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', async () => {
            // Firebase config placeholder check
            if (firebaseConfigToUse.apiKey === "YOUR_API_KEY" || !firebaseConfigToUse.projectId) {
                 onlineSetupMessage.textContent = "CRITICAL: Firebase is not configured. Please update firebaseConfigToUse in the script.";
                 console.error("CRITICAL: Firebase configuration is a placeholder. Update it with your actual Firebase project details.");
                 createGameButton.disabled = true;
                 joinGameButton.disabled = true;
                 showMessageModal("SETUP REQUIRED", "Firebase is not configured. Online features are disabled. See console for details.");
                 return; 
            }
            reformatBoardLayout(); 
            await initializeFirebase();
            
            const overlay = document.querySelector('.overlay');
            if(overlay) overlay.style.display = 'none';
        });

        document.body.addEventListener('click', async () => {
            if (!audioContextStarted && typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                try {
                    await Tone.start();
                    audioContextStarted = true;
                    logEvent("AudioContext started by user interaction.");
                    if (!toneSynth) { 
                        toneSynth = new Tone.Synth({
                            oscillator: { type: "triangle" }, 
                            envelope: { attack: 0.005, decay: 0.1, sustain: 0.2, release: 0.3 }
                        }).toDestination();
                        logEvent("Tone.Synth initialized.");
                    }
                } catch (e) { 
                    console.error("Error starting Tone.js AudioContext or initializing synth:", e); 
                }
            }
        }, { once: true }); 

        // --- Card Draw and Action Logic ---
        async function setCurrentCardDraw(card, type, playerId) {
            // Store the drawn card in Firestore for all to see
            const gameDocRef = doc(db, "games", currentGameId);
            await updateDoc(gameDocRef, {
                currentCardDraw: {
                    id: `${Date.now()}_${Math.random().toString(36).substr(2,5)}`,
                    type,
                    text: card.text,
                    action: card.action,
                    amount: card.amount || null,
                    playerId,
                },
                updatedAt: serverTimestamp(),
            });
        }

        function drawAndShowOpportunityCard(playerId) {
            const gameData = localGameData;
            if (!gameData) return;
            let cardIndex = gameData.opportunityCardIndex || 0;
            let deck = gameData.shuffledOpportunityCards || opportunityCards;
            if (cardIndex >= deck.length) {
                deck = shuffleDeck([...opportunityCards]);
                cardIndex = 0;
            }
            const card = deck[cardIndex];
            // Instead of showing locally, set in Firestore for all
            setCurrentCardDraw(card, 'Opportunity', playerId);
            // Update deck index in Firestore
            updateDoc(doc(db, "games", currentGameId), {
                opportunityCardIndex: cardIndex + 1,
                shuffledOpportunityCards: deck
            });
        }

        function drawAndShowWelfareCard(playerId) {
            const gameData = localGameData;
            if (!gameData) return;
            let cardIndex = gameData.welfareCardIndex || 0;
            let deck = gameData.shuffledWelfareCards || welfareCards;
            if (cardIndex >= deck.length) {
                deck = shuffleDeck([...welfareCards]);
                cardIndex = 0;
            }
            const card = deck[cardIndex];
            setCurrentCardDraw(card, 'Welfare', playerId);
            updateDoc(doc(db, "games", currentGameId), {
                welfareCardIndex: cardIndex + 1,
                shuffledWelfareCards: deck
            });
        }

        // --- Listen for currentCardDraw in Firestore and show modal for all ---
        // Add to subscribeToGameState (after localGameData = gameData; ...)
        // ... existing code ...
        // Find this in subscribeToGameState:
        // localGameData = gameData; // Update local cache *after* checking for money changes
        // ...
        // Add after:
        if (gameData.currentCardDraw && !window._lastCardDrawIdShown) {
            // Only show if not already shown
            if (!window._lastCardDrawIdShown || window._lastCardDrawIdShown !== gameData.currentCardDraw.id) {
                window._lastCardDrawIdShown = gameData.currentCardDraw.id;
                showCardModal(gameData.currentCardDraw, gameData.currentCardDraw.type, () => {
                    applyCardAction(gameData.currentCardDraw, gameData.currentCardDraw.playerId, gameData.currentCardDraw.type.toLowerCase());
                    // Clear the card from Firestore for all
                    updateDoc(doc(db, "games", currentGameId), { currentCardDraw: null, updatedAt: serverTimestamp() });
                });
            }
        } else if (!gameData.currentCardDraw) {
            window._lastCardDrawIdShown = null;
        }

        function showCardModal(card, type, onOk) {
            if (!onBoardCardDisplayDiv || !onBoardCardTypeH4 || !onBoardCardTextP || !onBoardCardOkButton) return;
            onBoardCardTypeH4.textContent = `${type} Card`;
            onBoardCardTextP.textContent = card.text;
            onBoardCardDisplayDiv.style.display = 'flex';
            onBoardCardOkButton.onclick = () => {
                onBoardCardDisplayDiv.style.display = 'none';
                if (onOk) onOk();
            };
        }

        function applyCardAction(card, playerId, deckType) {
            // This function should be expanded to handle all card actions
            const gameDocRef = doc(db, "games", currentGameId);
            let updates = {};
            const player = localGameData.players[playerId];
            switch(card.action) {
                case 'collect':
                    updates[`players.${playerId}.money`] = (player.money || 0) + (card.amount || 0);
                    updates.lastActionMessage = `${player.name} collected Â£${card.amount} (${deckType} card)`;
                    break;
                case 'pay':
                    updates[`players.${playerId}.money`] = (player.money || 0) - (card.amount || 0);
                    updates.lastActionMessage = `${player.name} paid Â£${card.amount} (${deckType} card)`;
                    break;
                case 'getOutOfDetentionFree':
                    updates[`players.${playerId}.getOutOfDetentionCards`] = (player.getOutOfDetentionCards || 0) + 1;
                    updates.lastActionMessage = `${player.name} received a Legal Aid card (${deckType})`;
                    break;
                // Add more cases for other card actions as needed
                default:
                    updates.lastActionMessage = `${player.name} drew a card: ${card.text}`;
            }
            updates.updatedAt = serverTimestamp();
            updateDoc(gameDocRef, updates);
        }

        // --- Integrate with Move Logic ---
        // In your dice roll/turn resolution logic, after moving the player, add:
        // if (landedSpace.type === 'opportunity') {
        //     drawAndShowOpportunityCard(currentUserId);
        // } else if (landedSpace.type === 'welfare') {
        //     drawAndShowWelfareCard(currentUserId);
        // }

        function calculateSpecialSetRent(property, owner) {
            if (property.groupId !== 'special_set') return 0;
            
            // Count how many special set properties the owner has
            const ownedSpecialProperties = propertyData.filter(p => 
                p.groupId === 'special_set' && 
                p.owner === owner
            );
            
            const baseRent = property.rent_base;
            const multiplier = ownedSpecialProperties.length * 0.5; // 50% per property owned
            return Math.floor(baseRent * multiplier);
        }

        function handlePropertyLanding(player, property) {
            if (property.owner === null) {
                // ... existing code ...
            } else if (property.owner !== player) {
                let rentAmount;
                if (property.type === 'set_property') {
                    rentAmount = calculateSpecialSetRent(property, property.owner);
                } else {
                    // ... existing regular property rent calculation ...
                }
                makePayment(player, property.owner, rentAmount, true);
            }
        }

        function payRent(player, propertyFromData) {
            if (player.isBankrupt) return;

            const owner = players.find(p => p.id === propertyFromData.owner);
            const propertyLayoutDetails = boardLayout.find(s => s.id === propertyFromData.id);

            if (!owner || owner.isBankrupt || !propertyLayoutDetails) {
                logEvent(`Owner ${owner ? owner.name : `ID ${propertyFromData.owner}`} is bankrupt or not found, or property details missing. No rent for ${propertyLayoutDetails ? propertyLayoutDetails.name : 'unknown property'}.`);
                return;
            }

            let rentAmount = 0;

            if (propertyLayoutDetails.type === "set_property") {
                // Count how many special set properties the owner has
                const ownedSetProperties = propertyData.filter(pData =>
                    pData.owner === propertyFromData.owner &&
                    boardLayout.find(s => s.id === pData.id)?.type === "set_property"
                );
                
                // Calculate rent as 50% of base rent per property owned
                const baseRent = propertyLayoutDetails.rent_base;
                const multiplier = ownedSetProperties.length * 0.5; // 50% per property owned
                rentAmount = Math.floor(baseRent * multiplier);
                
                logEvent(`${player.name} owes Â£${rentAmount} rent to ${owner.name} for ${propertyLayoutDetails.name} (Owner has ${ownedSetProperties.length} special set properties, multiplier: ${multiplier}x).`);
            } else if (propertyLayoutDetails.type === "property") {
                if (propertyFromData.tenancies === 0 && !propertyFromData.permanentResidence) {
                    const propertyPrice = propertyLayoutDetails.price;
                    const groupId = propertyLayoutDetails.groupId;
                    const ownerId = owner.id;
                    const numOwnedInGroup = propertyData.filter(p => {
                        const layout = boardLayout.find(bl => bl.id === p.id);
                        return layout && layout.groupId === groupId && p.owner === ownerId;
                    }).length;

                    rentAmount = Math.floor(propertyPrice / 2) * numOwnedInGroup;
                    logEvent(`Rent for unimproved ${propertyLayoutDetails.name}: (Â£${propertyPrice}/2) * ${numOwnedInGroup} (owned in group) = Â£${rentAmount}`);
                } else {
                    let rentLevel = 0;
                    if (propertyFromData.permanentResidence) {
                        rentLevel = MAX_TENANCIES + 1;
                    } else if (propertyFromData.tenancies > 0) {
                        rentLevel = propertyFromData.tenancies;
                    }

                    if (propertyLayoutDetails.rent && rentLevel < propertyLayoutDetails.rent.length) {
                        rentAmount = propertyLayoutDetails.rent[rentLevel];
                    } else if (propertyLayoutDetails.rent && propertyLayoutDetails.rent.length > 0) {
                        rentAmount = propertyLayoutDetails.rent[propertyLayoutDetails.rent.length -1];
                        logEvent(`Warning: Rent level ${rentLevel} adjusted for ${propertyLayoutDetails.name}. Using highest available rent tier.`);
                    } else {
                        logEvent(`Error: Missing rent tiers for developed property ${propertyLayoutDetails.name}. Defaulting rent to 0.`);
                        rentAmount = 0;
                    }
                    logEvent(`${player.name} owes Â£${rentAmount} rent to ${owner.name} for developed ${propertyLayoutDetails.name} (Tenancies: ${propertyFromData.tenancies}, PR: ${propertyFromData.permanentResidence}).`);
                }
            } else {
                logEvent(`Cannot calculate rent for ${propertyLayoutDetails.name} - unknown type or configuration.`);
                return;
            }

            if (rentAmount > 0) {
                makePayment(player, owner, rentAmount, true);
            } else {
                logEvent(`Calculated rent is Â£0 for ${propertyLayoutDetails.name}. No payment made.`);
            }

            highlightPlayerInfo(player.id);
            highlightPlayerInfo(owner.id);
        }

    </script>
  </div>
</body>
</html>
