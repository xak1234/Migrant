<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Migrantopoly - Online Multiplayer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            padding: 20px;
            color: #ecf0f1;
            position: relative;
            overflow-x: hidden;
            font-family: 'Inter', Arial, sans-serif;
            min-height: 100vh;
            background: #2c3e50;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* body::before is intended for a subtle background texture or effect.
           Its content is empty, so it should not display any text itself. */
        body::before {
            content: '';
            position: fixed;
            top: 50%;
            left: 50%;
            width: 1200px;
            height: 700px;
            transform: translate(-50%, -50%);
            background-color: rgba(255,255,255,0.05);
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.18;
            pointer-events: none;
            z-index: 0;
            mix-blend-mode: lighten;
        }

        .main-content {
          position: relative;
          z-index: 3; /* Ensures main content is above body::before and overlay */
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          min-height: 100vh;
          width: 100%;
          padding-top: 20px;
          padding-bottom: 20px;
          background-color: #2c3e50; /* Added to ensure opacity over potential stray body content */
        }

        #player-setup-screen, #online-setup-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #2c3e50;
            padding: 30px 40px;
            border-radius: 12px;
            border: 2px solid #7f8c8d;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
            color: #ecf0f1;
            text-align: center;
            width: auto;
            max-width: 450px;
        }
        #player-setup-screen h2, #online-setup-screen h2 {
            color: #1abc9c;
            margin-top: 0;
            margin-bottom: 25px;
            font-size: 1.8em;
        }
        .setup-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 18px;
        }
        #player-setup-screen label, #online-setup-screen label {
            font-size: 1em;
            margin-right: 15px;
            flex-basis: 40%;
            text-align: left;
        }
        #player-setup-screen select, #online-setup-screen select, #online-setup-screen input {
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size: 1em;
            flex-grow: 1;
        }
        #online-setup-screen input {
            width: calc(100% - 22px); /* Account for padding */
        }
        #player-setup-screen button, #online-setup-screen button {
            background-color: #27ae60;
            color: white;
            padding: 12px 25px;
            font-size: 1.1em;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 15px;
            margin-right: 10px;
        }
        #player-setup-screen button:last-child, #online-setup-screen button:last-child {
            margin-right: 0;
        }
        #player-setup-screen button:hover, #online-setup-screen button:hover {
            background-color: #2ecc71;
        }
         #online-setup-screen button.secondary {
            background-color: #3498db;
        }
        #online-setup-screen button.secondary:hover {
            background-color: #2980b9;
        }
        #player-setup-message, #online-setup-message {
            color: #f1c40f;
            font-size: 0.9em;
            margin-top: 15px;
            min-height: 1.2em;
        }
        #game-id-display {
            margin-top: 15px;
            font-size: 1.1em;
            color: #1abc9c;
        }
        #game-id-display span {
            font-weight: bold;
            background-color: #34495e;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
         #user-id-display {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.5);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            z-index: 1000;
        }


        #game-container, #game-info-area, #board-container {
            position: relative;
            z-index: 1;
        }

        #game-container {
            display: none; /* Initially hidden */
            flex-wrap: wrap;
            justify-content: center;
            gap: 25px;
            padding-top: 0px;
        }

        #board-container {
            display: grid;
            grid-template-columns: 100px repeat(8, 70px) 100px;
            grid-template-rows: 100px repeat(8, 70px) 100px;
            border: 3px solid #7f8c8d;
            width: 760px; /* Fixed width */
            height: 760px; /* Fixed height */
            position: relative;
            background-color: rgba(52, 73, 94, 0.68);
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            overflow: visible;
            margin-top: 20px;
        }

        #card-decks-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 18px;
            z-index: 2;
        }
        #center-board-image {
            width: 200px;
            height: auto;
            max-height: 150px;
            object-fit: contain;
            margin-bottom: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        #on-board-card-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 280px;
            min-height: 190px;
            background-color: #fdf5e6;
            border: 3px solid #c0392b;
            border-radius: 15px;
            box-shadow: 0 6px 22px rgba(0,0,0,0.35);
            z-index: 5;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: space-around;
            padding: 15px;
            box-sizing: border-box;
            text-align: center;
            color: #2c3e50;
        }

        #on-board-card-display h4 {
            margin: 5px 0;
            font-size: 1.4em;
            color: #c0392b;
            font-weight: bold;
        }

        #on-board-card-display p {
            margin: 10px 0;
            font-size: 1em;
            line-height: 1.45;
            overflow-y: auto;
            max-height: 100px;
            width: 100%;
            color: #34495e;
        }
        #on-board-card-ok-button {
            background-color: #27ae60;
            color: white;
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s, opacity 0.2s;
            margin-top: 10px;
        }
        #on-board-card-ok-button:hover:not(:disabled) {
            background-color: #2ecc71;
        }
        #on-board-card-ok-button:disabled {
            background-color: #7f8c8d;
            opacity: 0.7;
            cursor: default;
        }


        .space {
            border: 1px solid #7f8c8d;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 10px;
            position: relative;
            padding: 3px;
            box-sizing: border-box;
            background-color: #4a6378;
            color: #ecf0f1;
            border-radius: 5px;
        }
        .space .name {
            font-weight: bold;
            font-size: 10px;
            margin-bottom: 2px;
            line-height: 1.2;
        }
        .space .price {
            font-size: 9px;
            color: #bdc3c7;
            font-weight: normal;
        }
        .space .owner-indicator {
            width: 90%;
            height: 6px;
            margin-top: 3px;
            background-color: transparent;
            border-radius: 3px;
            position: absolute;
            bottom: 3px;
            left: 5%;
        }
         .space .development-indicator {
            font-size: 12px;
            color: #fff;
            position: absolute;
            top: 15px;
            width: 100%;
            text-align: center;
            line-height: 1;
            text-shadow: 0 0 2px #000;
        }
        .space .sub-label {
            font-size: 10px;
            color: #e74c3c;
            font-weight: bold;
            margin-top: 2px;
            letter-spacing: 0.04em;
            text-align: center;
            line-height: 1.1;
        }

        .corner {
            font-weight: bold;
            background-color: #527a78;
        }
        .corner .name {
            font-size: 16px !important;
            color: #e74c3c !important;
            font-weight: bold !important;
            margin-top: 0;
        }
        .corner .name.detention-center-name {
            margin-top: 35px;
            position: relative;
            z-index: 1;
        }


        .property .color-bar {
            width: 100%;
            height: 12px;
            border-bottom: 1px solid #7f8c8d;
            position: absolute;
            top: 0;
            left: 0;
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
        }
        .space.property .name { margin-top: 14px; }

        .welfare .name, .opportunity .name, .tax .name, .payout .name, .neutral:not(.corner) .name {
            margin-top: 0;
        }

        .set-property {
            background-color: #303F4D;
        }
        .set-property .name {
            margin-top: 0;
            font-size: 11px;
            font-weight: bold;
        }


        .brown .color-bar { background-color: #8B4513; }
        .light-blue .color-bar { background-color: #ADD8E6; }
        .pink .color-bar { background-color: #FFC0CB; }
        .orange .color-bar { background-color: #FFA500; }
        .red .color-bar { background-color: #FF0000; }
        .green .color-bar { background-color: #008000; }


        .player-token {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            position: absolute;
            border: none;
            font-size: 26px;
            line-height: 28px;
            text-align: center;
            background: none;
            z-index: 10;
            user-select: none;
            pointer-events: none;
        }

        #game-info-area {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #player-info, #controls, #game-status-message-container, #develop-property-container { /* Removed #card-display-container from this rule */
            padding: 15px;
            background-color: #34495e;
            border: 1px solid #7f8c8d;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            color: #ecf0f1;
        }
         #card-display-container { /* Side panel - if still used for other things */
            padding: 15px;
            background-color: #34495e;
            border: 1px solid #7f8c8d;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            color: #ecf0f1;
            display: none; /* Keep hidden by default if main card display is on board */
        }
        #player-info div { margin-bottom: 8px; font-size: 14px; }


        button {
            padding: 10px 15px;
            font-size: 14px;
            cursor: pointer;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 6px;
            transition: background-color 0.2s;
            margin-top: 5px;
            margin-right: 5px;
        }
        button:last-child { margin-right: 0; }
        button:hover:not(:disabled) { /* Only apply hover if not disabled */
            background-color: #c0392b;
        }
        button:disabled {
            background-color: #7f8c8d;
            color: #bdc3c7;
            cursor: not-allowed;
        }

        .main-action-button {
            display: block !important;
            margin: 8px auto !important;
        }

        #end-turn-button {
            background-color: #d35400;
        }
        #end-turn-button:hover:not(:disabled) {
            background-color: #e67e22;
        }
        #develop-property-button {
            background-color: #2980b9;
        }
        #develop-property-button:hover:not(:disabled) {
            background-color: #3498db;
        }


        #develop-property-container {
            display: none; /* Initially hidden */
        }
        #card-display-container h3, #develop-property-container h3 { /* Adjusted for side panel if used */
             margin-top: 0; color: #1abc9c;
        }

        #detention-actions button {
            background-color: #f39c12;
            margin-right: 5px;
        }
        #detention-actions button:hover:not(:disabled) {
            background-color: #e67e22;
        }
        #game-status-message {
            font-weight: bold;
            color: #e74c3c;
            min-height: 20px;
        }
        #pre-game-roll-area button {
            background-color: #f1c40f;
            color: #2c3e50;
        }
        #pre-game-roll-area button:hover:not(:disabled) {
            background-color: #f39c12;
        }
        #pre-game-roll-results { margin-top: 10px; font-size: 13px; }
        #develop-property-options button {
            display: block;
            width: calc(100% - 10px);
            margin-bottom: 8px;
            background-color: #2980b9;
        }
        #develop-property-options button:hover:not(:disabled) {
            background-color: #3498db;
        }

        .space.dole-space .name {
            font-size: 26px !important;
            font-weight: bold;
            letter-spacing: 0.08em;
            color: #fff !important;
            text-transform: uppercase;
            position: absolute;
            top: 15px;
            left: 0;
            width: 100%;
            text-align: center;
            transform: rotate(-36deg);
            transform-origin: center center;
            white-space: nowrap;
            pointer-events: none;
        }
        .dole-sign {
            position: absolute;
            bottom: 8px;
            right: 8px;
            font-size: 28px;
            color: #f1c40f;
            font-weight: bold;
            z-index: 3;
        }

        .space.red-boardname .name {
            color: #e74c3c !important;
            font-weight: bold;
        }
        .space.yellow-boardname .name {
            color: #f1c40f !important;
            font-weight: bold;
        }


        .player-highlight {
            animation: player-highlight-flash 1s;
            background: #ffeaa7;
            color: #222d3a !important;
        }
        @keyframes player-highlight-flash {
            0% { background: #ffeaa7; }
            60% { background: #ffeaa7; }
            100% { background: transparent; }
        }

        #money-flash {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 7vw; /* Can be adjusted */
            font-family: 'Impact', 'Arial Black', Arial, sans-serif;
            color: #e74c3c;
            font-weight: bold;
            opacity: 0;
            pointer-events: none;
            z-index: 1000;
            text-shadow: 2px 2px 16px #000, 0 0 32px #fff;
            transition: opacity 0.2s; /* For smooth fade-in via 'show' class */
        }
        #money-flash.show {
            opacity: 1;
            animation: money-flash-pop 0.7s ease-out; /* Animation controls pop and fade-out */
        }
        @keyframes money-flash-pop { /* Pop and then fade */
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.7); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            60% { opacity: 1; transform: translate(-50%, -50%) scale(1); } /* Hold */
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.7); } /* Fade out */
        }


        .detention-bars {
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            height: 32px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            z-index: 2;
        }
        .detention-bar {
            width: 4px;
            height: 100%;
            background: #111;
            border-radius: 2px;
            opacity: 0.85;
        }
        .detention-arrow {
            position: absolute;
            bottom: 6px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2em;
            color: #e67e22;
            font-weight: bold;
            z-index: 2;
            pointer-events: none;
            text-shadow: 1px 1px 6px #000, 0 0 8px #fff;
        }

        #current-turn-display {
            text-align: center;
            width: 100%;
            color: #ecf0f1;
            font-weight: bold;
            padding-bottom: 5px;
        }
        #current-turn-display.pulsing {
            font-size: 1.2em;
            animation: pulse-text-animation 1.5s infinite ease-in-out;
        }
        @keyframes pulse-text-animation {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        #game-status-message-container {
            text-align: center;
        }
        #uk-gov-status {
            padding: 12px;
            background: #222d3a;
            border: 1px solid #7f8c8d;
            border-radius: 8px;
            color: #f7ca18;
            font-weight: bold;
            text-align: center;
        }
         #uk-gov-status-container {
            width: 100%;
            box-sizing: border-box;
        }


        #pre-game-roll-area {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .overlay {
          position: fixed;
          top: 0; left: 0; right: 0; bottom: 0;
          background: rgba(24,28,36,0.48);
          z-index: 2;
          pointer-events: none;
        }


        .die {
            width: 30px;
            height: 30px;
            border: 1px solid #ecf0f1;
            background-color: #fff;
            color: #2c3e50;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .dice-animation {
            animation: dice-roll-effect 0.4s ease-out;
        }
        @keyframes dice-roll-effect {
            0% { transform: scale(1) rotate(0deg); opacity: 0.5; }
            25% { transform: scale(1.3) rotate(90deg); opacity: 0.75; }
            50% { transform: scale(1.1) rotate(180deg); opacity: 1; }
            75% { transform: scale(1.3) rotate(270deg); opacity: 0.75; }
            100% { transform: scale(1) rotate(360deg); opacity: 1; }
        }

        .token-hop {
            animation: hop-animation 0.3s ease-out;
        }
        @keyframes hop-animation {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            30% { transform: translateY(-35px) scale(1.25); opacity: 0.9; }
            60% { transform: translateY(-35px) scale(1.25); opacity: 0.9; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }

        .token-arrive-step {
            animation: arrive-step-animation 0.15s ease-out;
        }
        @keyframes arrive-step-animation {
            0% { transform: scale(0.8) translateY(2px); opacity: 0.7; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }

        #dice-display-master-container {
            min-height: 32px;
            text-align: center;
            margin-bottom: 8px;
        }
        #actual-dice-faces {
            display: inline-flex;
            gap: 5px;
            margin-left: 5px;
            vertical-align: middle;
        }
        #dice-total-display-text {
            margin-left: 8px;
            font-weight: bold;
        }

        .token-flash {
            animation: token-flash-animation 0.7s infinite alternate;
        }
        @keyframes token-flash-animation {
            0% { opacity: 1; transform: scale(1.1); filter: drop-shadow(0 0 6px currentColor) drop-shadow(0 0 3px #fff); }
            100% { opacity: 0.6; transform: scale(1); filter: drop-shadow(0 0 3px currentColor); }
        }
        .token-move-flash {
            animation: token-move-flash-animation 0.2s infinite;
        }
        @keyframes token-move-flash-animation {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background-color: #2c3e50;
            margin: auto;
            padding: 25px 35px;
            border: 1px solid #7f8c8d;
            border-radius: 10px;
            width: 80%;
            max-width: 450px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            text-align: center;
        }
        .modal-content h3 {
            color: #1abc9c;
            margin-top: 0;
        }
        .modal-content p {
            margin-bottom: 20px;
        }
        .modal-content button {
             background-color: #e74c3c;
        }
         .modal-content button:hover:not(:disabled) {
             background-color: #c0392b;
        }

</style>
</head>
<body>
  <div class="overlay"></div>
  <div id="user-id-display">Your User ID: <span id="local-user-id">Not Signed In</span></div>
  <div class="main-content">
    <div id="online-setup-screen"> <h2>Migrantopoly Online</h2>
        <div class="setup-row">
            <label for="player-name-input">Your Name:</label>
            <input type="text" id="player-name-input" placeholder="Enter your name" value="Player">
        </div>
        <div class="setup-row">
            <label for="game-id-input">Game ID (for joining):</label>
            <input type="text" id="game-id-input" placeholder="Enter Game ID to join">
        </div>
        <button id="join-game-button">Join Game</button>
        <hr style="width:80%; margin: 20px 0; border-color: #7f8c8d;">
        <div class="setup-row">
            <label for="num-players-online-select">Total Players in Game:</label>
            <select id="num-players-online-select">
                <option value="2" selected>2 Players</option>
                <option value="3">3 Players</option>
                <option value="4">4 Players</option>
            </select>
        </div>
        <button id="create-game-button">Create New Game</button>
        <p id="online-setup-message"></p>
        <div id="game-id-display" style="display:none;">
            Share this Game ID: <span id="generated-game-id" title="Click to copy"></span>
        </div>
    </div>

    <div id="player-setup-screen" style="display: none;"> <h2>Player Setup (Local)</h2>
        </div>

    <div id="game-container" style="display: none;">
        <div id="board-container">
            </div>

        <div id="game-info-area">
            <div id="player-info">
                </div>

            <div id="controls">
                <h3 id="current-turn-display">Current Turn: Player 1</h3>
                <div id="pre-game-roll-area" style="display:none;">
                    <h4>Determine Starting Player</h4>
                    <button id="pre-game-roll-button">Roll to Start</button>
                    <div id="pre-game-roll-results"></div>
                </div>

                <div id="dice-display-master-container">
                    <span>Dice: </span>
                    <div id="actual-dice-faces">
                        <div class="die" id="die-face-1">--</div>
                        <div class="die" id="die-face-2">--</div>
                    </div>
                    <span id="dice-total-display-text"></span>
                </div>
                <button id="roll-dice-button" style="display:none;">Roll Dice</button>
                <button id="end-turn-button" style="display:none;">End Turn</button>

                <div id="other-actions-container" style="text-align: center; margin-top: 5px;">
                    <button id="develop-property-button" style="display:none;">Develop Property</button>
                    <button id="buy-property-button" style="display:none;">Buy Property (Â£<span id="buy-property-price"></span>)</button>
                </div>
                <div id="detention-actions" style="margin-top: 10px;">
                    </div>
            </div>

            <div id="develop-property-container" style="display:none;">
                <h3 id="develop-property-name">Develop Property</h3>
                <div id="develop-property-options">
                    </div>
                <button id="close-develop-button">Close</button>
            </div>


            <div id="card-display-container" style="display:none;">
                <h3 id="card-type-title">Card Drawn</h3>
                <p id="card-message"></p>
                <button id="card-ok-button">OK</button>
            </div>

            <div id="game-status-message-container">
                <h4>Game Status:</h4>
                <p id="game-status-message">Waiting for game to start...</p>
            </div>

            <div id="uk-gov-status-container">
                <div id="uk-gov-status">
                    UK Gov: Â£<span id="uk-gov-cash">20000</span>
                </div>
            </div>
        </div>
    </div>

    <div id="money-flash"></div>

    <div id="message-modal" class="modal">
        <div class="modal-content">
            <h3 id="modal-title">Notification</h3>
            <p id="modal-message">This is a sample message.</p>
            <button id="modal-ok-button">OK</button>
        </div>
    </div>

  </div>

    <script type="module">
        // --- Firebase Configuration ---
        const userProvidedFirebaseConfig = {
            apiKey: "AIzaSyARzlfhH_AC0YTxJ5fKvhz_SPDq1r6mWPA",
            authDomain: "migrantopoly.firebaseapp.com",
            projectId: "migrantopoly",
            storageBucket: "migrantopoly.firebasestorage.app",
            messagingSenderId: "649348280586",
            appId: "1:649348280586:web:2bd3be4d2de84c0ea8caf3",
            measurementId: "G-1TMRSC6KL8"
        };
        const firebaseConfigToUse = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : userProvidedFirebaseConfig;

        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Firebase SDK imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, serverTimestamp, arrayUnion, arrayRemove, runTransaction, writeBatch, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        let db, auth, currentUserId = null, localPlayerName = '';
        let currentGameId = null;
        let unsubscribeGameState = null;
        let localGameData = {};
        let aiAddTimerId = null;


        const onlineSetupScreen = document.getElementById('online-setup-screen');
        const gameContainer = document.getElementById('game-container');
        const playerNameInput = document.getElementById('player-name-input');
        const gameIdInput = document.getElementById('game-id-input');
        const createGameButton = document.getElementById('create-game-button');
        const joinGameButton = document.getElementById('join-game-button');
        const numPlayersOnlineSelect = document.getElementById('num-players-online-select');
        const onlineSetupMessage = document.getElementById('online-setup-message');
        const gameIdDisplayDiv = document.getElementById('game-id-display');
        const generatedGameIdSpan = document.getElementById('generated-game-id');
        const localUserIdSpan = document.getElementById('local-user-id');

        const boardContainer = document.getElementById('board-container');
        const playerInfoDiv = document.getElementById('player-info');
        const rollDiceButton = document.getElementById('roll-dice-button');
        const endTurnButton = document.getElementById('end-turn-button');
        const buyPropertyButton = document.getElementById('buy-property-button');
        const buyPropertyPriceSpan = document.getElementById('buy-property-price');
        const developPropertyButton = document.getElementById('develop-property-button');
        const diceFace1Elem = document.getElementById('die-face-1');
        const diceFace2Elem = document.getElementById('die-face-2');
        const diceTotalDisplayText = document.getElementById('dice-total-display-text');
        const currentTurnDisplay = document.getElementById('current-turn-display');

        const detentionActionsDiv = document.getElementById('detention-actions');
        const gameStatusMessageP = document.getElementById('game-status-message');
        const preGameRollArea = document.getElementById('pre-game-roll-area');
        const preGameRollButton = document.getElementById('pre-game-roll-button');
        const preGameRollResultsDiv = document.getElementById('pre-game-roll-results');
        const developPropertyContainer = document.getElementById('develop-property-container');
        const developPropertyNameH3 = document.getElementById('develop-property-name');
        const developPropertyOptionsDiv = document.getElementById('develop-property-options');
        const closeDevelopButton = document.getElementById('close-develop-button');
        const otherActionsContainer = document.getElementById('other-actions-container');
        const ukGovCashSpan = document.getElementById('uk-gov-cash');

        let onBoardCardDisplayDiv, onBoardCardTypeH4, onBoardCardTextP, onBoardCardOkButton;

        const messageModal = document.getElementById('message-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalOkButton = document.getElementById('modal-ok-button');
        const moneyFlashDiv = document.getElementById('money-flash');


        let initialBoardLayout = [
            { id: 0, name: "Dole", type: "go" },
            { id: 1, name: "Tent in Field 1", type: "property", price: 60, rent: [4, 10, 20, 40, 80], color: "brown", groupId: "brown" },
            { id: 2, name: "Welfare Card", type: "welfare" },
            { id: 3, name: "Tent in Field 2", type: "property", price: 80, rent: [8, 10, 20, 40, 80], color: "brown", groupId: "brown" },
            { id: 4, name: "Black Market Sales", type: "set_property", price: 200, rent_base: 200, groupId: "special_set" },
            { id: 5, name: "Fake PIP declined", type: "tax", amount: 100 },
            { id: 6, name: "Tesco Cardboard Skip 1", type: "property", price: 100, rent: [6, 15, 30, 60, 120], color: "light-blue", groupId: "lightblue" },
            { id: 7, name: "Tesco Cardboard Skip 2", type: "property", price: 120, rent: [8, 15, 30, 60, 120], color: "light-blue", groupId: "lightblue" },
            { id: 8, name: "Detention Center", type: "detention_visiting" },
            { id: 9, name: "Payout: Job Seeker's", type: "payout", amount: 100 },
            { id: 10, name: "Tesco Cardboard Skip 3", type: "property", price: 140, rent: [10, 15, 30, 60, 120], color: "light-blue", groupId: "lightblue" },
            { id: 11, name: "Council Highrise 1", type: "property", price: 160, rent: [12, 25, 50, 100, 200], color: "pink", groupId: "pink" },
            { id: 12, name: "Forced Marriage", type: "set_property", price: 200, rent_base: 200, groupId: "special_set" },
            { id: 13, name: "Welfare Card", type: "welfare" },
            { id: 14, name: "Council Highrise 2", type: "property", price: 180, rent: [14, 25, 50, 100, 200], color: "pink", groupId: "pink" },
            { id: 15, name: "Council Highrise 3", type: "property", price: 200, rent: [16, 25, 50, 100, 200], color: "pink", groupId: "pink" },
            { id: 16, name: "Crime Spree !!! Arrest", type: "crime_spree", amount: 150 },
            { id: 17, name: "Gypsy Estate 1", type: "property", price: 220, rent: [18, 35, 70, 140, 280], color: "orange", groupId: "orange" },
            { id: 18, name: "Opportunity Card", type: "opportunity" },
            { id: 19, name: "Gypsy Estate 2", type: "property", price: 240, rent: [20, 35, 70, 140, 280], color: "orange", groupId: "orange" },
            { id: 20, name: "Child Wives", type: "set_property", price: 200, rent_base: 200, groupId: "special_set" },
            { id: 21, name: "Fake ID Cards", type: "tax", amount: 100 },
            { id: 22, name: "Gypsy Estate 3", type: "property", price: 260, rent: [22, 35, 70, 140, 280], color: "orange", groupId: "orange" },
            { id: 23, name: "Holiday Inn 1", type: "property", price: 280, rent: [24, 45, 90, 180, 360], color: "red", groupId: "red" },
            { id: 24, name: "Go to Detention Center", type: "go_to_detention" },
            { id: 25, name: "Welfare Card", type: "welfare" },
            { id: 26, name: "Holiday Inn 2", type: "property", price: 300, rent: [26, 45, 90, 180, 360], color: "red", groupId: "red" },
            { id: 27, name: "Holiday Inn 3", type: "property", price: 320, rent: [28, 45, 90, 180, 360], color: "red", groupId: "red" },
            { id: 28, name: "I Dont speak English", type: "set_property", price: 200, rent_base: 200, groupId: "special_set" },
            { id: 29, name: "Luxury Flat 1", type: "property", price: 350, rent: [30, 60, 120, 240, 480], color: "green", groupId: "green" },
            { id: 30, name: "Opportunity Card", type: "opportunity" },
            { id: 31, name: "Luxury Flat 2", type: "property", price: 400, rent: [35, 60, 120, 240, 480], color: "green", groupId: "green" },
        ];
        let boardLayout = [];
        let detentionCenterSpaceId;
        const TENANCY_COST = 50;
        const PR_COST = 150;
        const MAX_TENANCIES = 3;

        const welfareCards = [
            { text: "Child Benefit: Collect Â£100.", action: "collect", amount: 100 },
            { text: "Free Health Service: Gain a health service (worth Â£100).", action: "gainHealthService" },
            { text: "Council House Grant: Collect Â£150.", action: "collect", amount: 150 },
            { text: "Social Worker Fee: Pay Â£50.", action: "pay", amount: 50 },
            { text: "Food Voucher: Collect Â£75.", action: "collect", amount: 75 },
            { text: "Education Grant: Collect Â£120.", action: "collect", amount: 120 },
            { text: "Housing Inspection: Pay Â£20 per tenancy owned.", action: "payPerTenancy", amountPer: 20 },
            { text: "Utility Subsidy: Collect Â£80.", action: "collect", amount: 80 },
            { text: "Legal Aid: Get out of Detention Center free.", action: "getOutOfDetentionFree" },
            { text: "Emergency bowels: Collect Â£100.", action: "collect", amount: 100 },
            { text: "Tax Audit: Pay Â£60.", action: "pay", amount: 60 },
            { text: "Welfare Review: Move to nearest Payout Space.", action: "moveToNearestPayout" }
        ];
        const opportunityCards = [
            { text: "Work Permit Granted: Collect Â£150.", action: "collect", amount: 150 },
            { text: "Language Subsidy: Collect Â£50.", action: "collect", amount: 50 },
            { text: "Community Grant: Collect Â£100.", action: "collect", amount: 100 },
            { text: "Deportation Threat: Go to Detention Center.", action: "goToDetentionDirect" },
            { text: "Legal Homosexuals: Get out of Detention Center free.", action: "getOutOfDetentionFree" },
            { text: "Job Offer: Collect Â£120.", action: "collect", amount: 120 },
            { text: "Housing Voucher: Next estate purchase is 25% off.", action: "housingVoucher" },
            { text: "Free Health Service: Gain a health service (worth Â£100).", action: "gainHealthService" },
            { text: "Bank Manager Shat His Load: Pay Â£50 to the bank.", action: "pay", amount: 50 },
            { text: "Tax Refund: Collect Â£75.", action: "collect", amount: 75 },
            { text: "Dogs Had An Abortion: Collect Â£40 from each player.", action: "collectFromPlayers", amount: 40 },
            { text: "Advance to Go: Collect Â£200.", action: "advanceToGo" }
        ];
        const playerEmojis = ['ðŸ•â€ðŸ¦º', 'ðŸˆ', 'ðŸ˜', 'ðŸ…', 'ðŸ’', 'ðŸ¦Š'];
        const playerColors = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6', '#1abc9c'];

        let toneSynth;
        let audioContextStarted = false;


        function logEvent(message, data = null) {
            if (data) {
                console.log(`[Game Log] ${new Date().toLocaleTimeString()}: ${message}`, data);
            } else {
                console.log(`[Game Log] ${new Date().toLocaleTimeString()}: ${message}`);
            }
        }

        function showMessageModal(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            messageModal.style.display = 'flex';
        }
        modalOkButton.onclick = () => {
            messageModal.style.display = 'none';
        };

        function generateGameId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function reformatBoardLayout() {
            const newBoardLocations = [
                { name: "Boat Sank After Renting", type: "set_property", price: 100, rent_base: 100, groupId: "special_set" },
                { name: "People Trafficking", type: "set_property", price: 100, rent_base: 100, groupId: "special_set" },
                { name: "More than 15 children", type: "set_property", price: 100, rent_base: 100, groupId: "special_set" },
                { name: "Crypto Scam from Iqbhal", type: "set_property", price: 100, rent_base: 100, groupId: "special_set" }
            ];
            let tempBoard = [];
            tempBoard.push(initialBoardLayout.find(s => s.id === 0));
            const welfareCardOriginalSide1 = initialBoardLayout.find(s => s.id === 2);
            const boatSankProperty = newBoardLocations[0];
            tempBoard.push(initialBoardLayout.find(s => s.id === 1));
            tempBoard.push(boatSankProperty);
            tempBoard.push(initialBoardLayout.find(s => s.id === 3));
            tempBoard.push(initialBoardLayout.find(s => s.id === 4));
            tempBoard.push(welfareCardOriginalSide1);
            tempBoard.push(...initialBoardLayout.filter(s => s.id >= 5 && s.id <= 7));
            tempBoard.push(initialBoardLayout.find(s => s.id === 8));
            const peopleTraffickingProperty = newBoardLocations[1];
            const payoutJobSeekersOriginal = initialBoardLayout.find(s => s.id === 9);
            tempBoard.push(peopleTraffickingProperty);
            tempBoard.push(...initialBoardLayout.filter(s => s.id >= 10 && s.id <= 12));
            tempBoard.push(payoutJobSeekersOriginal);
            tempBoard.push(...initialBoardLayout.filter(s => s.id === 13 || (s.id >= 14 && s.id <= 15)));
            tempBoard.push(initialBoardLayout.find(s => s.id === 16));
            const moreThan15ChildrenProperty = newBoardLocations[2];
            const opportunityCardSide3Original = initialBoardLayout.find(s => s.id === 18);
            tempBoard.push(initialBoardLayout.find(s => s.id === 17));
            tempBoard.push(moreThan15ChildrenProperty);
            tempBoard.push(initialBoardLayout.find(s => s.id === 19));
            tempBoard.push(initialBoardLayout.find(s => s.id === 20));
            tempBoard.push(opportunityCardSide3Original);
            tempBoard.push(...initialBoardLayout.filter(s => s.id >= 21 && s.id <= 23));
            tempBoard.push(initialBoardLayout.find(s => s.id === 24));
            const cryptoScamProperty = newBoardLocations[3];
            const opportunityCardSide4Original = initialBoardLayout.find(s => s.id === 30);
            tempBoard.push(...initialBoardLayout.filter(s => s.id === 25 || (s.id >= 26 && s.id <= 28)));
            tempBoard.push(opportunityCardSide4Original);
            tempBoard.push(initialBoardLayout.find(s => s.id === 29));
            tempBoard.push(cryptoScamProperty);
            tempBoard.push(initialBoardLayout.find(s => s.id === 31));

            boardLayout = tempBoard.map((space, index) => ({ ...space, id: index }));

            const dcSpace = boardLayout.find(s => s.name === "Detention Center");
            detentionCenterSpaceId = dcSpace ? dcSpace.id : (boardLayout.find(s => s.type === "detention_visiting")?.id || 8) ;
        }

        async function initializeFirebase() {
            if (!firebaseConfigToUse || !firebaseConfigToUse.apiKey || firebaseConfigToUse.apiKey === "YOUR_API_KEY" || !firebaseConfigToUse.projectId) {
                onlineSetupMessage.textContent = "Firebase configuration is missing or incomplete. Online features disabled.";
                console.error("Firebase config is not available or incomplete. Please update it in the script with your actual Firebase project details.");
                createGameButton.disabled = true;
                joinGameButton.disabled = true;
                showMessageModal("Setup Error", "Firebase is not configured. Please check the console for details. Online play is unavailable.");
                return;
            }
            try {
                const app = initializeApp(firebaseConfigToUse);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        localUserIdSpan.textContent = currentUserId;
                        logEvent(`Authenticated as: ${currentUserId}`);
                        onlineSetupMessage.textContent = "Connected. Ready to create or join a game.";
                        createGameButton.disabled = false;
                        joinGameButton.disabled = false;
                    } else {
                        currentUserId = null;
                        localUserIdSpan.textContent = "Not Signed In";
                        logEvent("User is signed out or initial authentication pending.");

                        if (initialAuthToken) {
                            try {
                                await signInWithCustomToken(auth, initialAuthToken);
                                logEvent("Signed in with custom token.");
                            } catch (error) {
                                console.error("Custom token sign-in error:", error);
                                logEvent("Custom token sign-in failed, trying anonymous.");
                                await signInAnonymously(auth);
                            }
                        } else {
                            logEvent("No custom token, trying anonymous sign-in.");
                            await signInAnonymously(auth);
                        }
                    }
                });
            } catch (error) {
                console.error("Firebase initialization error:", error);
                onlineSetupMessage.textContent = "Error connecting to Firebase: " + error.message;
                showMessageModal("Firebase Error", "Could not initialize Firebase: " + error.message);
                createGameButton.disabled = true;
                joinGameButton.disabled = true;
            }
        }

        async function handleCreateGame() {
            if (!currentUserId) {
                showMessageModal("Error", "You are not authenticated. Please wait or refresh.");
                return;
            }
            localPlayerName = playerNameInput.value.trim() || `Player ${currentUserId.substring(0,4)}`;
            if (!localPlayerName) {
                showMessageModal("Input Needed", "Please enter your player name.");
                return;
            }

            const newGameId = generateGameId();
            currentGameId = newGameId;
            const numPlayers = parseInt(numPlayersOnlineSelect.value);

            const gameDocRef = doc(db, "games", newGameId);

            reformatBoardLayout();

            const initialPropertyDataForFirestore = boardLayout
                .filter(s => s.type === 'property' || s.type === 'set_property')
                .map(p => ({
                    id: p.id,
                    name: p.name,
                    owner: null,
                    tenancies: 0,
                    permanentResidence: false,
                }));


            const initialPlayerData = {
                id: currentUserId,
                name: localPlayerName,
                money: 2000,
                position: 0,
                properties: [],
                healthServices: 0,
                getOutOfDetentionCards: 0,
                inDetention: false,
                missedTurnsInDetention: 0,
                hasHousingVoucher: false,
                isBankrupt: false,
                playerActionTakenThisTurn: false,
                doublesRolledInTurn: 0,
                order: 0,
                govReceived: 0,
                isAI: false
            };

            const initialGameState = {
                gameId: newGameId,
                status: "waiting",
                hostId: currentUserId,
                maxPlayers: numPlayers,
                players: { [currentUserId]: initialPlayerData },
                playerOrder: [currentUserId],
                currentPlayerIndex: 0,
                boardLayout: boardLayout,
                propertyData: initialPropertyDataForFirestore,
                bankMoney: 15000,
                ukGovMoney: 20000,
                shuffledWelfareCards: shuffleDeck([...welfareCards]),
                shuffledOpportunityCards: shuffleDeck([...opportunityCards]),
                welfareCardIndex: 0,
                opportunityCardIndex: 0,
                lastDiceRoll: null,
                lastActionMessage: `${localPlayerName} created the game. Waiting for players...`,
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp(),
                preGameRolls: {},
                preGamePlayersRolled: [],
                preGamePhase: true,
                gamePhase: "setup",
                currentCardDraw: null,
            };

            if (Object.keys(initialGameState.players).length < numPlayers) {
                if (currentUserId === initialGameState.hostId) {
                    if (aiAddTimerId) clearTimeout(aiAddTimerId);
                    logEvent(`Host starting 30s timer to add AI players if game not full.`);
                    aiAddTimerId = setTimeout(() => {
                        checkAndAddAIPlayers(newGameId, numPlayers);
                    }, 30000);
                }
            } else {
                 initialGameState.status = "active";
                 initialGameState.lastActionMessage = `${localPlayerName} created the game. Starting pre-game rolls.`;
            }


            try {
                await setDoc(gameDocRef, initialGameState);
                logEvent(`Game ${newGameId} created by ${localPlayerName}.`);
                onlineSetupMessage.textContent = `Game created! ID: ${newGameId}. Waiting for players...`;
                generatedGameIdSpan.textContent = newGameId;
                gameIdDisplayDiv.style.display = 'block';
                subscribeToGameState(newGameId);
            } catch (error) {
                console.error("Error creating game:", error);
                showMessageModal("Error", "Could not create game: " + error.message);
                onlineSetupMessage.textContent = "Failed to create game. " + error.message;
            }
        }

        async function handleJoinGame() {
            if (!currentUserId) {
                showMessageModal("Error", "You are not authenticated. Please wait or refresh.");
                return;
            }
            localPlayerName = playerNameInput.value.trim() || `Player ${currentUserId.substring(0,4)}`;
            if (!localPlayerName) {
                showMessageModal("Input Needed", "Please enter your player name.");
                return;
            }

            const gameIdToJoin = gameIdInput.value.trim().toUpperCase();
            if (!gameIdToJoin) {
                showMessageModal("Input Needed", "Please enter a Game ID to join.");
                return;
            }

            const gameDocRef = doc(db, "games", gameIdToJoin);

            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameDocRef);
                    if (!gameDoc.exists()) {
                        throw new Error("Game not found.");
                    }

                    const gameData = gameDoc.data();
                    if (gameData.boardLayout && gameData.boardLayout.length > 0) {
                        boardLayout = gameData.boardLayout;
                        const dcSpace = boardLayout.find(s => s.name === "Detention Center");
                        detentionCenterSpaceId = dcSpace ? dcSpace.id : (boardLayout.find(s => s.type === "detention_visiting")?.id || 8);
                    } else {
                        reformatBoardLayout();
                        logEvent("Warning: Joined game was missing boardLayout, reformatted locally.");
                    }


                    if (Object.keys(gameData.players).length >= gameData.maxPlayers) {
                        if (!gameData.players[currentUserId]) {
                             throw new Error("Game is full.");
                        } else {
                            logEvent("Already part of this game. Rejoining/Resubscribing...");
                        }
                    }

                    if (!gameData.players[currentUserId]) {
                        const newPlayerOrderIndex = gameData.playerOrder.length;
                        const newPlayerData = {
                            id: currentUserId, name: localPlayerName, money: 2000, position: 0, properties: [],
                            healthServices: 0, getOutOfDetentionCards: 0, inDetention: false, missedTurnsInDetention: 0,
                            hasHousingVoucher: false, isBankrupt: false, playerActionTakenThisTurn: false,
                            doublesRolledInTurn: 0, order: newPlayerOrderIndex, govReceived: 0, isAI: false
                        };

                        const updates = {};
                        updates[`players.${currentUserId}`] = newPlayerData;
                        updates.playerOrder = arrayUnion(currentUserId);
                        updates.updatedAt = serverTimestamp();

                        const newPlayerCount = gameData.playerOrder.length + 1;

                        if (newPlayerCount === gameData.maxPlayers) {
                            updates.preGamePhase = true;
                            updates.status = "active";
                            updates.lastActionMessage = `${localPlayerName} joined. All players present! Starting pre-game rolls.`;
                        } else {
                            updates.lastActionMessage = `${localPlayerName} joined the game. Waiting for ${gameData.maxPlayers - newPlayerCount} more.`;
                        }
                        transaction.update(gameDocRef, updates);
                        logEvent(`${localPlayerName} joining game ${gameIdToJoin}. Player order index: ${newPlayerOrderIndex}`);
                    }
                });

                currentGameId = gameIdToJoin;
                onlineSetupMessage.textContent = `Joined game ${gameIdToJoin}! Waiting for game to start...`;
                subscribeToGameState(gameIdToJoin);

            } catch (error) {
                console.error("Error joining game:", error);
                showMessageModal("Error", "Could not join game: " + error.message);
                onlineSetupMessage.textContent = "Failed to join game. " + error.message;
            }
        }

        async function checkAndAddAIPlayers(gameId, maxPlayersInGame) {
            if (aiAddTimerId) {
                clearTimeout(aiAddTimerId);
                aiAddTimerId = null;
            }
            logEvent(`checkAndAddAIPlayers called for game ${gameId}. Max players: ${maxPlayersInGame}`);

            const gameDocRef = doc(db, "games", gameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameDocRef);
                    if (!gameDoc.exists()) {
                        logEvent("checkAndAddAIPlayers: Game document no longer exists.");
                        return;
                    }
                    const gameData = gameDoc.data();

                    if (gameData.status !== "waiting" || Object.keys(gameData.players).length >= maxPlayersInGame) {
                        logEvent("checkAndAddAIPlayers: Game is no longer waiting or is full. No AI needed.", { status: gameData.status, playerCount: Object.keys(gameData.players).length });
                        return;
                    }

                    const numHumanPlayers = Object.keys(gameData.players).length;
                    const numAIToAdd = maxPlayersInGame - numHumanPlayers;

                    if (numAIToAdd <= 0) {
                        logEvent("checkAndAddAIPlayers: No AI players needed.");
                        return;
                    }

                    logEvent(`checkAndAddAIPlayers: Adding ${numAIToAdd} AI player(s).`);
                    let updates = {};
                    let newPlayerOrder = [...gameData.playerOrder];
                    let newPlayersObject = {...gameData.players};
                    let aiPlayerNames = [];

                    for (let i = 0; i < numAIToAdd; i++) {
                        const aiPlayerId = `AI-${crypto.randomUUID().substring(0, 8)}`;
                        const aiPlayerName = `AI Bot ${i + 1}`;
                        aiPlayerNames.push(aiPlayerName);
                        const aiOrderIndex = newPlayerOrder.length;
                        const aiPlayerData = {
                            id: aiPlayerId, name: aiPlayerName, money: 2000, position: 0, properties: [],
                            healthServices: 0, getOutOfDetentionCards: 0, inDetention: false, missedTurnsInDetention: 0,
                            hasHousingVoucher: false, isBankrupt: false, playerActionTakenThisTurn: false,
                            doublesRolledInTurn: 0, order: aiOrderIndex, govReceived: 0, isAI: true
                        };
                        newPlayersObject[aiPlayerId] = aiPlayerData;
                        newPlayerOrder.push(aiPlayerId);
                    }

                    updates.players = newPlayersObject;
                    updates.playerOrder = newPlayerOrder;
                    updates.preGamePhase = true;
                    updates.status = "active";
                    updates.lastActionMessage = `${aiPlayerNames.join(', ')} joined as AI. Starting pre-game rolls.`;
                    updates.updatedAt = serverTimestamp();

                    transaction.update(gameDocRef, updates);
                    logEvent(`checkAndAddAIPlayers: Successfully added ${numAIToAdd} AI player(s).`);
                });
            } catch (error) {
                console.error("Error in checkAndAddAIPlayers transaction:", error);
                showMessageModal("AI Add Error", "Could not add AI players: " + error.message);
            }
        }


        function subscribeToGameState(gameId) {
            if (unsubscribeGameState) {
                unsubscribeGameState();
            }
            const gameDocRef = doc(db, "games", gameId);
            unsubscribeGameState = onSnapshot(gameDocRef, async (docSnap) => {
                if (docSnap.exists()) {
                    const gameData = docSnap.data();

                    if (currentUserId === gameData.hostId && aiAddTimerId) {
                        if (gameData.status !== "waiting" || Object.keys(gameData.players).length >= gameData.maxPlayers) {
                            logEvent("Game filled or started, clearing AI add timer.");
                            clearTimeout(aiAddTimerId);
                            aiAddTimerId = null;
                        }
                    }

                    // MODIFIED: Money flash logic moved after localGameData update for accurate lastActionMessage check
                    let oldMoneyOfCurrentUser;
                    if (localGameData.players && localGameData.players[currentUserId]) {
                        oldMoneyOfCurrentUser = localGameData.players[currentUserId]?.money;
                    }

                    const previousCardDrawId = localGameData.currentCardDraw ? localGameData.currentCardDraw.id : null;
                    localGameData = gameData; // Update local cache to the new state from Firestore
                    logEvent("Game state updated from Firestore:", gameData.lastActionMessage || "No message", gameData.status);


                    if (currentUserId && localGameData.players && localGameData.players[currentUserId]) {
                        const currentPlayerNewState = localGameData.players[currentUserId];
                        const newMoney = currentPlayerNewState.money;
                        const lastAction = localGameData.lastActionMessage || "";

                        if (typeof oldMoneyOfCurrentUser !== 'undefined' && newMoney < oldMoneyOfCurrentUser) {
                            const amountLost = oldMoneyOfCurrentUser - newMoney;
                            if (amountLost > 0) {
                                let prefix = "";
                                if (lastAction.startsWith(currentPlayerNewState.name) && lastAction.includes(" paid Â£" + amountLost + " rent to")) {
                                    prefix = "Rent! ";
                                }
                                showMoneyChangeEffect(amountLost, 'loss', prefix);
                            }
                        } else if (typeof oldMoneyOfCurrentUser !== 'undefined' && newMoney > oldMoneyOfCurrentUser) {
                            const amountGained = newMoney - oldMoneyOfCurrentUser;
                             if (amountGained > 0) {
                                // No special prefix for rent gain needed per user request
                                showMoneyChangeEffect(amountGained, 'gain');
                            }
                        }
                    }


                    if (gameData.boardLayout && JSON.stringify(boardLayout) !== JSON.stringify(gameData.boardLayout)) {
                        logEvent("Board layout received from Firestore is different or not set, adopting it.");
                        boardLayout = gameData.boardLayout;
                        const dcSpace = boardLayout.find(s => s.name === "Detention Center");
                        detentionCenterSpaceId = dcSpace ? dcSpace.id : (boardLayout.find(s => s.type === "detention_visiting")?.id || 8);
                        if (boardContainer.innerHTML.trim() !== '') {
                            logEvent("Board was already drawn, re-setting up from new Firestore layout.");
                            setupBoardFromFirestore(gameData);
                        }
                    }

                    updateLocalUIFromFirestore(gameData); // This should be called after localGameData is updated

                    if (gameData.currentCardDraw && (!window._lastCardDrawIdShown || window._lastCardDrawIdShown !== gameData.currentCardDraw.id) ) {
                        logEvent("New card draw detected in Firestore for display:", gameData.currentCardDraw);
                        window._lastCardDrawIdShown = gameData.currentCardDraw.id;
                        showCardModalFromFirestore(gameData.currentCardDraw);
                    } else if (!gameData.currentCardDraw && window._lastCardDrawIdShown) {
                        if (onBoardCardDisplayDiv && onBoardCardDisplayDiv.style.display !== 'none') {
                            onBoardCardDisplayDiv.style.display = 'none';
                            logEvent("currentCardDraw is null in Firestore, hiding on-board card display.");
                        }
                        window._lastCardDrawIdShown = null;
                    }


                    if (currentGameId && onlineSetupScreen.style.display !== 'none' && (gameData.status === "active" || gameData.status === "finished")) {
                         onlineSetupScreen.style.display = 'none';
                         gameContainer.style.display = 'flex';
                         logEvent("Switched to game container as game status is active/finished and setup screen was visible.");
                    }
                    // AI Turn Logic (assuming handleAITurn exists)
                    if (
                        gameData.status === "active" &&
                        !gameData.preGamePhase &&
                        gameData.playerOrder &&
                        gameData.players &&
                        !gameData.currentCardDraw // MODIFIED: Don't let AI take turn if a card is being shown
                    ) {
                        const currentPlayerId = gameData.playerOrder[gameData.currentPlayerIndex];
                        const currentPlayer = gameData.players[currentPlayerId];
                        if (currentPlayer && currentPlayer.isAI && !currentPlayer.isBankrupt) {
                            if (!window._aiTurnInProgress) {
                                window._aiTurnInProgress = true;
                                setTimeout(async () => {
                                    // await handleAITurn(gameData, currentPlayerId); // Placeholder for AI logic
                                    logEvent("AI turn for " + currentPlayer.name + " would be handled here.");
                                    window._aiTurnInProgress = false;
                                }, 1000 + Math.random() * 1500); // Slightly randomized delay for AI
                            }
                        }
                    }
                } else {
                    logEvent(`Game ${gameId} no longer exists or access denied.`);
                    showMessageModal("Game Ended", "The game session has ended or is no longer available.");
                    if (unsubscribeGameState) unsubscribeGameState();
                    resetToSetupScreen();
                }
            }, (error) => {
                console.error("Error listening to game state:", error);
                showMessageModal("Connection Error", "Lost connection to the game: " + error.message);
                if (unsubscribeGameState) unsubscribeGameState();
                resetToSetupScreen();
            });
        }

        function resetToSetupScreen() {
            onlineSetupScreen.style.display = 'flex';
            gameContainer.style.display = 'none';
            currentGameId = null;
            localGameData = {};
            if (unsubscribeGameState) {
                unsubscribeGameState();
                unsubscribeGameState = null;
            }
            if (aiAddTimerId) {
                clearTimeout(aiAddTimerId);
                aiAddTimerId = null;
            }
            onlineSetupMessage.textContent = "Ready to create or join a new game.";
            gameIdDisplayDiv.style.display = 'none';
            generatedGameIdSpan.textContent = '';
            gameIdInput.value = '';
            boardLayout = [];
            if(boardContainer) boardContainer.innerHTML = '';
            if(playerInfoDiv) playerInfoDiv.innerHTML = '';
            if(diceFace1Elem) diceFace1Elem.textContent = '--';
            if(diceFace2Elem) diceFace2Elem.textContent = '--';
            if(diceTotalDisplayText) diceTotalDisplayText.textContent = '';
            if(currentTurnDisplay) currentTurnDisplay.textContent = 'Current Turn: Player 1';
            if(gameStatusMessageP) gameStatusMessageP.textContent = 'Waiting for game to start...';
             if(onBoardCardDisplayDiv) onBoardCardDisplayDiv.style.display = 'none';

        }

        async function finalizePreGameAsHost() {
            if (!currentGameId || !currentUserId || !db || !localGameData.hostId || localGameData.hostId !== currentUserId) {
                logEvent("finalizePreGameAsHost: Conditions not met.");
                return;
            }
            logEvent("Host attempting to finalize pre-game rolls.");

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) {
                        throw new Error("Game document not found during host finalization.");
                    }
                    const freshGameData = freshGameDoc.data();

                    if (!freshGameData.preGamePhase) {
                        logEvent("Host finalization: Pre-game phase already ended.");
                        return;
                    }
                     if (freshGameData.hostId !== currentUserId) {
                        logEvent("Host finalization check: Current user is NOT host in fresh data. Aborting.");
                        return;
                    }

                    const allPlayersInOrder = freshGameData.playerOrder || [];
                    const currentPreGameRolls = freshGameData.preGameRolls || {};
                    const allHaveRolled = allPlayersInOrder.length > 0 &&
                                        allPlayersInOrder.length === freshGameData.maxPlayers &&
                                        allPlayersInOrder.every(pid => currentPreGameRolls[pid] !== undefined);

                    if (!allHaveRolled) {
                        logEvent("Host finalization: Not all players have rolled or not all joined. Aborting.");
                        return;
                    }

                    logEvent("Host is proceeding with finalization of pre-game rolls.");
                    let updates = {};
                    const sortedPlayerIds = [...allPlayersInOrder].sort((a, b) => {
                        const rollA = currentPreGameRolls[a];
                        const rollB = currentPreGameRolls[b];
                        if (rollB === rollA) {
                            return (freshGameData.players[a]?.order || 0) - (freshGameData.players[b]?.order || 0);
                        }
                        return rollB - rollA;
                    });

                    updates.playerOrder = sortedPlayerIds;
                    updates.currentPlayerIndex = 0;
                    updates.preGamePhase = false;
                    updates.gamePhase = "main";
                    updates.status = "active";
                    updates.lastActionMessage = `Starting order determined by host. ${freshGameData.players[sortedPlayerIds[0]].name} starts!`;
                    updates.updatedAt = serverTimestamp();

                    transaction.update(gameDocRef, updates);
                    logEvent("Host successfully finalized pre-game starting order.");
                });
            } catch (error) {
                console.error("Error during host finalization of pre-game rolls:", error);
                showMessageModal("Host Finalization Error", "Could not finalize game start: " + error.message);
            }
        }

        function updateDiceUIDisplay(gameData) {
            const diceDisplayContainer = document.getElementById('actual-dice-faces');
            if (!diceFace1Elem || !diceFace2Elem || !diceTotalDisplayText || !diceDisplayContainer) return;

            if (gameData.lastDiceRoll && gameData.gamePhase === "main" && !gameData.preGamePhase) {
                diceFace1Elem.textContent = gameData.lastDiceRoll.die1;
                diceFace2Elem.textContent = gameData.lastDiceRoll.die2;
                diceTotalDisplayText.textContent = ` = ${gameData.lastDiceRoll.total}`;

                diceDisplayContainer.classList.remove('dice-animation');
                void diceDisplayContainer.offsetWidth;
                diceDisplayContainer.classList.add('dice-animation');
            } else {
                diceFace1Elem.textContent = '--';
                diceFace2Elem.textContent = '--';
                diceTotalDisplayText.textContent = '';
                diceDisplayContainer.classList.remove('dice-animation');
            }
        }

        function updatePlayerInfoPanel(gameData) {
            if (!playerInfoDiv) return;
            playerInfoDiv.innerHTML = '';
            if (!gameData.playerOrder || !gameData.players) {
                logEvent("updatePlayerInfoPanel: Missing playerOrder or players data.");
                return;
            }

            gameData.playerOrder.forEach(playerId => {
                const p = gameData.players[playerId];
                if (!p || typeof p.id === 'undefined' || typeof p.order === 'undefined') {
                    logEvent("updatePlayerInfoPanel: Invalid player data encountered for ID:", playerId, p);
                    return;
                };

                const playerColor = playerColors[p.order % playerColors.length];
                const pDiv = document.createElement('div');
                if (p.isBankrupt) {
                    pDiv.innerHTML = `<b style="color:${playerColor};">${p.name}</b>: BANKRUPT`;
                    pDiv.style.textDecoration = 'line-through';
                    pDiv.style.opacity = '0.6';
                } else {
                    pDiv.innerHTML = `<b style='color:${playerColor};'>${p.name}</b>: <span style='font-weight:bold;'>Â£${p.money}</span> | HS: ${p.healthServices} | LegalAids: ${p.getOutOfDetentionCards}`;
                    if (p.inDetention) pDiv.innerHTML += ` (In Detention - ${p.missedTurnsInDetention} missed)`;
                }
                if (!gameData.preGamePhase && gameData.status === "active" && gameData.playerOrder[gameData.currentPlayerIndex] === p.id && !p.isBankrupt) {
                    pDiv.style.border = `2px solid ${playerColor}`;
                    pDiv.style.padding = "3px";
                    pDiv.style.borderRadius = "4px";
                    pDiv.classList.add('player-highlight');
                } else {
                    pDiv.classList.remove('player-highlight');
                }
                playerInfoDiv.appendChild(pDiv);
            });
        }

        function updateGameStatusPanel(gameData) {
            if (!gameStatusMessageP || !currentTurnDisplay || !gameData.players || !gameData.playerOrder) return;

            if (gameData.preGamePhase) {
                 const joined = Object.keys(gameData.players).length;
                 if (joined < gameData.maxPlayers) {
                    gameStatusMessageP.textContent = `Waiting for players... (${joined}/${gameData.maxPlayers} joined)`;
                 } else {
                    const allRolled = gameData.playerOrder.every(pid => gameData.preGameRolls && gameData.preGameRolls[pid] !== undefined);
                    if (allRolled) {
                        gameStatusMessageP.textContent = "All players rolled. Host is determining start order...";
                    } else {
                        gameStatusMessageP.textContent = "Pre-game: Determine starting player by rolling.";
                    }
                 }
            } else if (gameData.status === "active" && gameData.gamePhase === "main") {
                gameStatusMessageP.textContent = gameData.lastActionMessage || "Game in progress...";
            } else if (gameData.status === "finished") {
                gameStatusMessageP.textContent = gameData.lastActionMessage || "Game Over!";
            } else {
                 gameStatusMessageP.textContent = `Waiting for players... (${Object.keys(gameData.players).length}/${gameData.maxPlayers} joined)`;
            }

            const currentPlayerIdInOrder = gameData.playerOrder[gameData.currentPlayerIndex];
            const currentPlayerInOrder = gameData.players[currentPlayerIdInOrder];

            if (currentPlayerInOrder && gameData.status === "active") {
                if (gameData.preGamePhase) {
                    let nextPlayerToRollForDisplayId = null;
                    for(const pid of gameData.playerOrder) {
                        if(!gameData.preGameRolls || gameData.preGameRolls[pid] === undefined) {
                            nextPlayerToRollForDisplayId = pid;
                            break;
                        }
                    }
                    const playerToRoll = gameData.players[nextPlayerToRollForDisplayId];

                    if (playerToRoll && typeof playerToRoll.name !== 'undefined' && typeof playerToRoll.order !== 'undefined') {
                         currentTurnDisplay.textContent = `Pre-Game Roll: ${playerToRoll.name}`;
                         currentTurnDisplay.style.color = playerColors[playerToRoll.order % playerColors.length];
                         currentTurnDisplay.classList.remove('pulsing');
                    } else if (Object.keys(gameData.players).length === gameData.maxPlayers) {
                        currentTurnDisplay.textContent = "Pre-Game Rolls Complete";
                        currentTurnDisplay.style.color = '#ecf0f1';
                        currentTurnDisplay.classList.remove('pulsing');
                    } else {
                        currentTurnDisplay.textContent = "Waiting for Players...";
                        currentTurnDisplay.style.color = '#ecf0f1';
                        currentTurnDisplay.classList.remove('pulsing');
                    }
                } else if (gameData.gamePhase === "main" && !currentPlayerInOrder.isBankrupt) {
                    currentTurnDisplay.textContent = `Current Turn: ${currentPlayerInOrder.name}`;
                    currentTurnDisplay.style.color = playerColors[currentPlayerInOrder.order % playerColors.length];
                    currentTurnDisplay.classList.add('pulsing');
                } else if (gameData.gamePhase === "main" && currentPlayerInOrder.isBankrupt) {
                    currentTurnDisplay.textContent = `Skipping Bankrupt: ${currentPlayerInOrder.name}`;
                    currentTurnDisplay.style.color = '#7f8c8d';
                    currentTurnDisplay.classList.remove('pulsing');
                }
            } else if (gameData.status === "finished") {
                currentTurnDisplay.textContent = "Game Over!";
                currentTurnDisplay.style.color = '#e74c3c';
                currentTurnDisplay.classList.remove('pulsing');
            } else {
                currentTurnDisplay.textContent = "Game Not Fully Started";
                currentTurnDisplay.style.color = '#ecf0f1';
                currentTurnDisplay.classList.remove('pulsing');
            }
        }

        function updateControlsBasedOnTurn(gameData) {
            if (!currentUserId || !gameData.players || !gameData.players[currentUserId]) {
                rollDiceButton.style.display = 'none';
                endTurnButton.style.display = 'none';
                buyPropertyButton.style.display = 'none';
                developPropertyButton.style.display = 'none';
                otherActionsContainer.style.display = 'none';
                detentionActionsDiv.innerHTML = '';
                return;
            }
            const amIBankrupt = gameData.players[currentUserId]?.isBankrupt;

            rollDiceButton.style.display = 'none';
            endTurnButton.style.display = 'none';
            buyPropertyButton.style.display = 'none';
            developPropertyButton.style.display = 'none';
            otherActionsContainer.style.display = 'none';
            detentionActionsDiv.innerHTML = '';

            if (amIBankrupt || gameData.status === "finished" || gameData.preGamePhase) {
                const playerToken = document.getElementById(`player-token-${currentUserId}`);
                if (playerToken) playerToken.classList.remove('token-flash');
                return;
            }

            if (gameData.status !== "active" || gameData.gamePhase !== "main") return;

            const isMyTurn = gameData.playerOrder[gameData.currentPlayerIndex] === currentUserId;
            const myPlayerState = gameData.players[currentUserId];
            const amIInDetention = myPlayerState.inDetention;
            const myPlayerActionTakenThisTurn = myPlayerState.playerActionTakenThisTurn;

            const playerToken = document.getElementById(`player-token-${currentUserId}`);
            if (isMyTurn) {
                if (playerToken && (!onBoardCardDisplayDiv || onBoardCardDisplayDiv.style.display === 'none') && developPropertyContainer.style.display === 'none' ) {
                    playerToken.classList.add('token-flash');
                } else if (playerToken) {
                    playerToken.classList.remove('token-flash');
                }
            } else {
                 if (playerToken) playerToken.classList.remove('token-flash');
            }


            if (isMyTurn) {
                if (amIInDetention) {
                    setupDetentionActionsUI(myPlayerState, gameData);
                    if (myPlayerActionTakenThisTurn) {
                        endTurnButton.style.display = 'block';
                        endTurnButton.disabled = false;
                        endTurnButton.classList.add('main-action-button');
                        detentionActionsDiv.innerHTML = '';
                    }
                } else {
                    const rolledDoubles = gameData.lastDiceRoll?.isDoubles;
                    const doublesCount = myPlayerState.doublesRolledInTurn || 0;

                    if (!myPlayerActionTakenThisTurn || (rolledDoubles && doublesCount > 0 && doublesCount < 3) ) {
                        rollDiceButton.style.display = 'block';
                        rollDiceButton.disabled = false;
                        rollDiceButton.classList.add('main-action-button');
                        if (rolledDoubles && doublesCount > 0 && doublesCount < 3 && gameStatusMessageP) {
                            gameStatusMessageP.textContent = `${myPlayerState.name} rolled doubles! Roll again.`;
                        }
                    }

                    let showOptionalActions = false;
                    if (gameData.lastDiceRoll || myPlayerActionTakenThisTurn) {
                        showOptionalActions = true;
                    }


                    if (showOptionalActions) {
                        otherActionsContainer.style.display = 'block';
                        const currentSpace = gameData.boardLayout[myPlayerState.position];
                        const propData = Array.isArray(gameData.propertyData) ? gameData.propertyData.find(p => p.id === currentSpace?.id) : null;

                        if (currentSpace && propData && (currentSpace.type === 'property' || currentSpace.type === 'set_property') && propData.owner === null) {
                            let price = currentSpace.price;
                            if (myPlayerState.hasHousingVoucher && currentSpace.type === 'property') {
                                price = Math.round(price * 0.75);
                            }
                            buyPropertyPriceSpan.textContent = price;
                            buyPropertyButton.style.display = (myPlayerState.money >= price) ? 'inline-block' : 'none';
                            if (buyPropertyButton.style.display === 'inline-block') buyPropertyButton.disabled = false;
                        } else {
                            buyPropertyButton.style.display = 'none';
                        }

                        developPropertyButton.style.display = canPlayerDevelopAnyProperty(myPlayerState, gameData) ? 'inline-block' : 'none';
                        if (developPropertyButton.style.display === 'inline-block') {
                            developPropertyButton.disabled = false;
                        }

                        if (buyPropertyButton.style.display === 'none' && developPropertyButton.style.display === 'none') {
                            otherActionsContainer.style.display = 'none';
                        }
                    } else {
                         otherActionsContainer.style.display = 'none';
                    }

                    if (myPlayerActionTakenThisTurn && !(rolledDoubles && doublesCount > 0 && doublesCount < 3) ) {
                        endTurnButton.style.display = 'block';
                        endTurnButton.disabled = false;
                        endTurnButton.classList.add('main-action-button');
                    }

                    const noMandatoryRollPending = !((myPlayerState.doublesRolledInTurn || 0) > 0 && (myPlayerState.doublesRolledInTurn || 0) < 3 && !myPlayerActionTakenThisTurn);
                    const noOptionalActionsAvailable = buyPropertyButton.style.display === 'none' && developPropertyButton.style.display === 'none';
                    const noCardActionPending = (!onBoardCardDisplayDiv || onBoardCardDisplayDiv.style.display === 'none');


                    if (myPlayerActionTakenThisTurn && noMandatoryRollPending && noOptionalActionsAvailable && noCardActionPending) {
                        logEvent("Auto-ending turn conditions met. Setting timeout.");
                        setTimeout(() => {
                            const freshLocalDataForAutoEnd = localGameData;
                            if (freshLocalDataForAutoEnd && freshLocalDataForAutoEnd.players && freshLocalDataForAutoEnd.players[currentUserId]) {
                                const stillMyTurnNow = freshLocalDataForAutoEnd.playerOrder[freshLocalDataForAutoEnd.currentPlayerIndex] === currentUserId;
                                const playerStateNow = freshLocalDataForAutoEnd.players[currentUserId];

                                const noRollPendingNow = !((playerStateNow.doublesRolledInTurn || 0) > 0 && (playerStateNow.doublesRolledInTurn || 0) < 3 && !playerStateNow.playerActionTakenThisTurn);
                                const noOptionsNow = document.getElementById('buy-property-button').style.display === 'none' &&
                                                     document.getElementById('develop-property-button').style.display === 'none';
                                const noCardNow = (!document.getElementById('on-board-card-display') || document.getElementById('on-board-card-display').style.display === 'none');


                                if (stillMyTurnNow && playerStateNow.playerActionTakenThisTurn && noRollPendingNow && noOptionsNow && noCardNow) {
                                    logEvent("Auto-end conditions still met in timeout. Calling handleEndTurnAction.");
                                    handleEndTurnAction();
                                } else {
                                    logEvent("Auto-end conditions changed during timeout or not my turn anymore. Not auto-ending.");
                                }
                            } else {
                                logEvent("Auto-end timeout: Could not get fresh player data. Not auto-ending.");
                            }
                        }, 1500);
                    }
                }
            }
        }

        function updatePreGameRollUI(gameData) {
            if (!preGameRollArea || !preGameRollButton || !preGameRollResultsDiv || !gameData.players) {
                logEvent("updatePreGameRollUI: Missing DOM elements or player data.");
                return;
            }

            if (!gameData.preGamePhase || gameData.status !== "active" || Object.keys(gameData.players).length < gameData.maxPlayers) {
                preGameRollArea.style.display = 'none';
                preGameRollButton.style.display = 'none';
                return;
            }

            preGameRollArea.style.display = 'flex';
            preGameRollResultsDiv.innerHTML = '';
            preGameRollButton.style.display = 'none';

            let allPlayerIdsInOrder = gameData.playerOrder || [];
            let preGameRollsData = gameData.preGameRolls || {};
            let numberOfPlayers = allPlayerIdsInOrder.length;

            let rolledPlayerCount = 0;
            allPlayerIdsInOrder.forEach(pid => {
                const playerName = gameData.players[pid]?.name || 'Unknown Player';
                const playerOrderForColor = gameData.players[pid]?.order;
                const playerColor = (typeof playerOrderForColor !== 'undefined') ? playerColors[playerOrderForColor % playerColors.length] : '#ecf0f1';

                if (preGameRollsData[pid] !== undefined) {
                    preGameRollResultsDiv.innerHTML += `<span style="color:${playerColor};">${playerName}</span> rolled: ${preGameRollsData[pid]}<br>`;
                    rolledPlayerCount++;
                } else {
                    preGameRollResultsDiv.innerHTML += `<span style="color:${playerColor};">${playerName}</span> has not rolled yet.<br>`;
                }
            });

            if (rolledPlayerCount === numberOfPlayers && numberOfPlayers > 0 && numberOfPlayers === gameData.maxPlayers) {
                preGameRollResultsDiv.innerHTML += "All players rolled. Host is determining start order...";
            } else if (numberOfPlayers > 0 && numberOfPlayers === gameData.maxPlayers) {
                let nextPlayerToRollId = null;
                const sortedByJoinOrder = [...allPlayerIdsInOrder].sort((a,b) => (gameData.players[a]?.order || 0) - (gameData.players[b]?.order || 0));

                for (const pid of sortedByJoinOrder) {
                    if (preGameRollsData[pid] === undefined) {
                        nextPlayerToRollId = pid;
                        break;
                    }
                }

                if (nextPlayerToRollId === currentUserId) {
                    preGameRollButton.style.display = 'block';
                    preGameRollButton.textContent = `Your turn, ${gameData.players[currentUserId]?.name || 'Player'}, Roll to Start`;
                    preGameRollButton.disabled = false;
                } else if (nextPlayerToRollId && gameData.players[nextPlayerToRollId]) {
                    preGameRollButton.style.display = 'block';
                    preGameRollButton.textContent = `Waiting for ${gameData.players[nextPlayerToRollId].name} to roll...`;
                    preGameRollButton.disabled = true;
                } else if (rolledPlayerCount < numberOfPlayers) {
                    preGameRollButton.style.display = 'block';
                    preGameRollButton.textContent = `Waiting for players to roll...`;
                    preGameRollButton.disabled = true;
                }
            } else {
                 preGameRollResultsDiv.innerHTML = "Waiting for all players to join before starting rolls...";
            }
        }

        function updateUkGovDisplay(govMoney) {
            if (ukGovCashSpan) {
                 ukGovCashSpan.textContent = govMoney !== undefined ? govMoney : (localGameData.ukGovMoney || 20000);
            }
        }

        function handleGameEndUI(gameData) {
            if (!gameStatusMessageP || !currentTurnDisplay || !rollDiceButton || !endTurnButton || !buyPropertyButton || !developPropertyButton || !preGameRollArea || !otherActionsContainer) return;

            gameStatusMessageP.textContent = gameData.lastActionMessage || "Game Over!";
            currentTurnDisplay.textContent = "Game Over!";
            currentTurnDisplay.style.color = '#e74c3c';

            rollDiceButton.style.display = 'none';
            endTurnButton.style.display = 'none';
            buyPropertyButton.style.display = 'none';
            developPropertyButton.style.display = 'none';
            preGameRollArea.style.display = 'none';
            detentionActionsDiv.innerHTML = '';

            otherActionsContainer.style.display = 'block';
            otherActionsContainer.innerHTML = '<button id="leave-game-button" style="background-color:#c0392b;">Back to Setup</button>';
            const leaveButton = document.getElementById('leave-game-button');
            if (leaveButton) {
                leaveButton.onclick = () => {
                    if (unsubscribeGameState) unsubscribeGameState();
                    resetToSetupScreen();
                };
            }
        }

        function setupBoardFromFirestore(gameData) {
            if (!boardContainer) {
                logEvent("Error: boardContainer DOM element not found in setupBoardFromFirestore.");
                return;
            }
            boardContainer.innerHTML = '';

            if (gameData.boardLayout && gameData.boardLayout.length > 0) {
                boardLayout = gameData.boardLayout;
            } else {
                logEvent("setupBoardFromFirestore: gameData.boardLayout is missing or empty. Cannot setup board.");
                return;
            }

            const dcSpace = boardLayout.find(s => s.name === "Detention Center");
            detentionCenterSpaceId = dcSpace ? dcSpace.id : (boardLayout.find(s => s.type === "detention_visiting")?.id || 8) ;

            const cardDecksCenter = document.createElement('div');
            cardDecksCenter.id = 'card-decks-center';
            const centerImage = document.createElement('img');
            centerImage.id = 'center-board-image';
            centerImage.src = 'migrant3.jpg';
            centerImage.alt = 'Migrantopoly Center';
            cardDecksCenter.appendChild(centerImage);
            boardContainer.appendChild(cardDecksCenter);

            const onBoardCardDivHTML = `
                <div id="on-board-card-display" style="display: none;">
                    <h4 id="on-board-card-type">Card Type</h4>
                    <p id="on-board-card-text">Card text will appear here.</p>
                    <button id="on-board-card-ok-button">OK</button>
                </div>
            `;
            boardContainer.insertAdjacentHTML('beforeend', onBoardCardDivHTML);


            onBoardCardDisplayDiv = document.getElementById('on-board-card-display');
            onBoardCardTypeH4 = document.getElementById('on-board-card-type');
            onBoardCardTextP = document.getElementById('on-board-card-text');
            onBoardCardOkButton = document.getElementById('on-board-card-ok-button');


            boardLayout.forEach((s) => {
                const spaceDiv = document.createElement('div');
                spaceDiv.id = `space-${s.id}`;
                spaceDiv.classList.add('space');
                if (s.type === 'go' || s.type === 'detention_visiting' || s.type === 'go_to_detention' || s.type === 'crime_spree') {
                    spaceDiv.classList.add('corner');
                }
                if (['Fake PIP declined', 'Fake ID Cards', "Payout: Job Seeker's"].includes(s.name)) {
                    spaceDiv.classList.add('yellow-boardname');
                }
                if (s.name === "Dole" && s.type === "go"){
                     spaceDiv.classList.add('dole-space');
                     const doleSign = document.createElement('div');
                     doleSign.classList.add('dole-sign');
                     doleSign.textContent = '$';
                     spaceDiv.appendChild(doleSign);
                }
                if (s.name === 'Detention Center') {
                    const bars = document.createElement('div'); bars.className = 'detention-bars';
                    for (let b = 0; b < 6; b++) { const bar = document.createElement('div'); bar.className = 'detention-bar'; bars.appendChild(bar); }
                    spaceDiv.appendChild(bars);
                }
                if (s.name === 'Go to Detention Center') {
                    const arrow = document.createElement('div'); arrow.className = 'detention-arrow'; arrow.textContent = 'â†’'; spaceDiv.appendChild(arrow);
                    const subLabel = document.createElement('div'); subLabel.className = 'sub-label'; subLabel.textContent = 'DO NOT PASS GO'; spaceDiv.appendChild(subLabel);
                }
                if (s.type === 'property') {
                    spaceDiv.classList.add('property', s.color || s.groupId);
                    const colorBar = document.createElement('div'); colorBar.classList.add('color-bar');
                    if (["Tesco Cardboard Skip 1", "Tesco Cardboard Skip 2", "Tesco Cardboard Skip 3"].includes(s.name)) {
                        colorBar.style.backgroundColor = '#2196f3';
                    }
                    spaceDiv.appendChild(colorBar);
                } else if (s.type === 'set_property') {
                    spaceDiv.classList.add('set-property');
                }
                const nameDiv = document.createElement('div'); nameDiv.classList.add('name');
                if (s.name === 'Detention Center') nameDiv.classList.add('detention-center-name');
                nameDiv.textContent = s.name;
                if (s.type === 'opportunity' || s.type === 'welfare') {
                    nameDiv.style.color = '#ff9800';
                }
                spaceDiv.appendChild(nameDiv);

                if (s.type === 'property' && s.rent) {
                    const devIndicator = document.createElement('div');
                    devIndicator.classList.add('development-indicator');
                    devIndicator.id = `dev-indicator-${s.id}`;
                    spaceDiv.appendChild(devIndicator);
                }
                if (s.price) {
                    const priceDiv = document.createElement('div'); priceDiv.classList.add('price');
                    priceDiv.textContent = `Â£${s.price}`; spaceDiv.appendChild(priceDiv);
                }
                if (s.type === 'property' || s.type === 'set_property') {
                    const ownerIndicator = document.createElement('div');
                    ownerIndicator.classList.add('owner-indicator');
                    ownerIndicator.id = `owner-indicator-${s.id}`;
                    spaceDiv.appendChild(ownerIndicator);
                }

                const currentId = s.id;
                if (currentId === 0) { spaceDiv.style.gridArea = `1 / 1`; }
                else if (currentId >= 1 && currentId <= 8) { spaceDiv.style.gridArea = `1 / ${currentId + 1}`; }
                else if (currentId === 9) { spaceDiv.style.gridArea = `1 / 10`; }
                else if (currentId >= 10 && currentId <= 17) { spaceDiv.style.gridArea = `${(currentId - 9) + 1} / 10`; }
                else if (currentId === 18) { spaceDiv.style.gridArea = `10 / 10`; }
                else if (currentId >= 19 && currentId <= 26) { spaceDiv.style.gridArea = `10 / ${10 - (currentId - 18)}`; }
                else if (currentId === 27) { spaceDiv.style.gridArea = `10 / 1`; }
                else if (currentId >= 28 && currentId <= 31) {
                     spaceDiv.style.gridArea = `${10 - (currentId - 27)} / 1`;
                }

                boardContainer.appendChild(spaceDiv);
            });

            if (gameData.players && gameData.playerOrder) {
                Object.values(gameData.players).forEach(player => {
                    if (player && typeof player.id !== 'undefined' && typeof player.order !== 'undefined') {
                        let token = document.getElementById(`player-token-${player.id}`);
                        if (!token) {
                            token = document.createElement('div');
                            token.id = `player-token-${player.id}`;
                            token.classList.add('player-token');
                        }
                        token.textContent = playerEmojis[player.order % playerEmojis.length];
                        const playerTokenColor = playerColors[player.order % playerColors.length];
                        token.style.color = playerTokenColor;
                        token.style.filter = `drop-shadow(0 0 3px ${playerTokenColor})`;

                        const spaceToPlace = document.getElementById(`space-${player.position}`);
                        if (spaceToPlace) {
                            spaceToPlace.appendChild(token);
                        } else {
                            logEvent(`Warning: Could not find space-${player.position} to place token for ${player.name}`);
                            const goSpace = document.getElementById('space-0');
                            if (goSpace) goSpace.appendChild(token);
                        }
                    } else {
                        logEvent("Warning: Invalid player data in setupBoardFromFirestore, skipping token creation/update.", player);
                    }
                });
            } else {
                logEvent("Warning: gameData.players or gameData.playerOrder is missing in setupBoardFromFirestore. Tokens not created.");
            }
            updateBoardDynamicElements(gameData);
        }

        function updateBoardDynamicElements(gameData) {
            if (!gameData || !gameData.players || !gameData.boardLayout) {
                logEvent("updateBoardDynamicElements: Missing critical gameData. Skipping updates.");
                return;
            }

            Object.values(gameData.players).forEach(player => {
                if (!player || typeof player.id === 'undefined') {
                    logEvent("updateBoardDynamicElements: Invalid player object in players list.", player);
                    return;
                }
                const token = document.getElementById(`player-token-${player.id}`);
                if (token) {
                    if (player.isBankrupt) {
                        token.style.display = 'none';
                    } else {
                        token.style.display = 'block';
                        const currentSpaceEl = document.getElementById(`space-${player.position}`);
                        if (currentSpaceEl) {
                            if (token.parentNode !== currentSpaceEl) {
                                currentSpaceEl.appendChild(token);
                            }
                        } else {
                            logEvent(`updateBoardDynamicElements: Could not find space-${player.position} for token ${player.id}`);
                        }
                    }
                } else {
                    logEvent(`updateBoardDynamicElements: Token not found for player ${player.id}. It should have been created.`);
                }
            });

            if (Array.isArray(gameData.propertyData)) {
                gameData.propertyData.forEach(propInPropertyData => {
                    if (!propInPropertyData || typeof propInPropertyData.id === 'undefined') {
                        logEvent("Warning: Invalid item in propertyData array during UI update, skipping this item.", propInPropertyData);
                        return;
                    }

                    const ownerIndicator = document.getElementById(`owner-indicator-${propInPropertyData.id}`);
                    if (ownerIndicator) {
                        if (propInPropertyData.owner && gameData.players[propInPropertyData.owner] && !gameData.players[propInPropertyData.owner].isBankrupt) {
                            const ownerData = gameData.players[propInPropertyData.owner];
                            if (ownerData && typeof ownerData.order !== 'undefined') {
                                const ownerColor = playerColors[ownerData.order % playerColors.length];
                                ownerIndicator.style.backgroundColor = ownerColor;
                            } else {
                                 ownerIndicator.style.backgroundColor = 'transparent';
                            }
                        } else {
                            ownerIndicator.style.backgroundColor = 'transparent';
                        }
                    }

                    const boardSpaceDetails = gameData.boardLayout.find(s => s.id === propInPropertyData.id);
                    if (boardSpaceDetails && boardSpaceDetails.type === 'property') {
                        const devIndicator = document.getElementById(`dev-indicator-${propInPropertyData.id}`);
                        if (devIndicator) {
                            if (propInPropertyData.permanentResidence) {
                                devIndicator.textContent = "ðŸ¢";
                            } else if (propInPropertyData.tenancies > 0) {
                                devIndicator.textContent = "ðŸ ".repeat(propInPropertyData.tenancies);
                            } else {
                                devIndicator.textContent = "";
                            }
                        }
                    }
                });
            } else {
                logEvent("updateBoardDynamicElements: gameData.propertyData is NOT an array. Property visual updates will be skipped.", gameData.propertyData);
            }
        }

        // MODIFIED: Added messagePrefix parameter
        function showMoneyChangeEffect(amount, type = 'loss', messagePrefix = '') {
            const moneyFlashDivLocal = document.getElementById('money-flash');
            if (!moneyFlashDivLocal) {
                logEvent("showMoneyChangeEffect: money-flash div not found.");
                return;
            }

            let displayText = '';
            if (type === 'loss') {
                displayText = `${messagePrefix}-Â£${Math.abs(amount)}`;
                moneyFlashDivLocal.style.color = '#e74c3c';
            } else { // 'gain'
                displayText = `${messagePrefix}+Â£${Math.abs(amount)}`;
                moneyFlashDivLocal.style.color = '#2ecc71';
            }
            moneyFlashDivLocal.textContent = displayText.trim();


            moneyFlashDivLocal.classList.remove('show');
            void moneyFlashDivLocal.offsetWidth;
            moneyFlashDivLocal.classList.add('show');

            setTimeout(() => {
                moneyFlashDivLocal.classList.remove('show');
            }, 1000); // Flash for 1 second (animation itself is 0.7s)

            if (audioContextStarted && toneSynth) {
                try {
                    if (type === 'loss') {
                        toneSynth.triggerAttackRelease("A3", "16n", Tone.now());
                        toneSynth.triggerAttackRelease("F#3", "16n", Tone.now() + 0.07);
                    } else {
                        toneSynth.triggerAttackRelease("C5", "16n", Tone.now());
                        toneSynth.triggerAttackRelease("E5", "16n", Tone.now() + 0.07);
                    }
                } catch (e) {
                    console.error("Money change sound error:", e);
                }
            }
        }


        function updateLocalUIFromFirestore(gameData) {
            if (!currentUserId) {
                logEvent("UpdateLocalUI: currentUserId not set yet, deferring UI update.");
                if(gameStatusMessageP) gameStatusMessageP.textContent = "Authenticating...";
                return;
            }

            if (!gameData || Object.keys(gameData).length === 0) {
                logEvent("UpdateLocalUI: No game data received. Cannot update UI.");
                return;
            }

            if (gameData.preGamePhase &&
                gameData.status === "active" &&
                gameData.hostId === currentUserId &&
                gameData.playerOrder && gameData.playerOrder.length === gameData.maxPlayers &&
                gameData.preGameRolls &&
                gameData.playerOrder.every(pid => gameData.preGameRolls[pid] !== undefined)
               ) {
                logEvent("Host detected conditions to finalize pre-game. Calling finalizePreGameAsHost.");
                finalizePreGameAsHost();
                return;
            }

            if (gameData.boardLayout && gameData.boardLayout.length > 0) {
                const boardIsMissingOrDifferent = boardLayout.length === 0 ||
                                                (boardContainer && boardContainer.innerHTML.trim() === '') ||
                                                JSON.stringify(boardLayout) !== JSON.stringify(gameData.boardLayout);
                if (boardIsMissingOrDifferent) {
                    logEvent("UpdateLocalUI: Setting up/refreshing board from Firestore data.");
                    setupBoardFromFirestore(gameData);
                } else {
                    updateBoardDynamicElements(gameData);
                }
            } else {
                logEvent("UpdateLocalUI: gameData.boardLayout is missing or empty. Board not set up/updated.");
            }

            updateDiceUIDisplay(gameData);
            updatePlayerInfoPanel(gameData);
            updateGameStatusPanel(gameData);
            updateControlsBasedOnTurn(gameData); // This must be called after DOM elements for cards are potentially updated by setupBoard
            updateUkGovDisplay(gameData.ukGovMoney);

            if (gameData.preGamePhase && gameData.status === "active") {
                updatePreGameRollUI(gameData);
            } else {
                if(preGameRollArea) preGameRollArea.style.display = 'none';
            }

            if (gameData.status === "finished") {
                handleGameEndUI(gameData);
            }
        }

        async function animatePlayerMove(playerId, startPos, steps, currentBoardLayout) {
            const token = document.getElementById(`player-token-${playerId}`);
            if (!token || !currentBoardLayout || currentBoardLayout.length === 0) return;

            let currentVisualPos = startPos;
            const stepDelay = 200;

            for (let i = 0; i < steps; i++) {
                currentVisualPos = (currentVisualPos + 1) % currentBoardLayout.length;
                const nextSpaceEl = document.getElementById(`space-${currentVisualPos}`);

                if (nextSpaceEl) {
                    nextSpaceEl.appendChild(token);
                    token.classList.remove('token-arrive-step');
                    void token.offsetWidth;
                    token.classList.add('token-arrive-step');
                }

                if (audioContextStarted && toneSynth) {
                    try {
                        toneSynth.triggerAttackRelease("A5", "32n", Tone.now() + (i * 0.02));
                    } catch (e) {
                        console.error("Token move sound error:", e);
                    }
                }
                await new Promise(resolve => setTimeout(resolve, stepDelay));
            }
        }


        async function handleRollDiceAction() {
            if (!currentGameId || !localGameData || !localGameData.playerOrder || localGameData.playerOrder[localGameData.currentPlayerIndex] !== currentUserId) {
                showMessageModal("Not your turn", "It's not your turn to roll the dice.");
                return;
            }
             if (localGameData.preGamePhase) {
                showMessageModal("Game Phase Error", "Cannot roll main dice during pre-game roll phase. Use 'Roll to Start'.");
                return;
            }
            if (localGameData.gamePhase !== "main") {
                showMessageModal("Game Phase Error", "Cannot roll dice before the main game has started.");
                return;
            }
            if (!localGameData.players || !localGameData.players[currentUserId]) {
                 showMessageModal("Error", "Player data not found."); return;
            }

            const currentPlayerStateFromLocal = localGameData.players[currentUserId];
            if (currentPlayerStateFromLocal.playerActionTakenThisTurn && !(localGameData.lastDiceRoll?.isDoubles && currentPlayerStateFromLocal.doublesRolledInTurn < 3 && currentPlayerStateFromLocal.doublesRolledInTurn > 0)) {
                 showMessageModal("Action Taken", "You've already completed your roll action for this part of the turn.");
                return;
            }
             if (currentPlayerStateFromLocal.inDetention) {
                 showMessageModal("In Detention", "You are in detention. Use detention actions (roll for doubles, pay, or use card).");
                return;
            }

            if(rollDiceButton) rollDiceButton.disabled = true;

            const die1 = Math.floor(Math.random() * 6) + 1;
            const die2 = Math.floor(Math.random() * 6) + 1;
            const totalRoll = die1 + die2;
            let isDoubles = die1 === die2;

            if (audioContextStarted && toneSynth) {
                try {
                    toneSynth.triggerAttackRelease("C4", "16n", Tone.now());
                    setTimeout(() => { if (toneSynth) toneSynth.triggerAttackRelease("E4", "16n", Tone.now() + 0.1); }, 100);
                } catch (e) { console.error("Dice roll sound error:", e); }
            }

            const playerStartPosForAnim = localGameData.players[currentUserId].position;
            await animatePlayerMove(currentUserId, playerStartPosForAnim, totalRoll, localGameData.boardLayout);


            const gameDocRef = doc(db, "games", currentGameId);
            let landedPropertyIdForRentCheck = -1; // Store property ID if rent needs to be checked after move

            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game document not found during roll.");
                    const freshGameData = freshGameDoc.data();

                    const playerState = freshGameData.players[currentUserId];
                    if (!playerState || playerState.isBankrupt) throw new Error("Player data missing or bankrupt in Firestore during roll.");
                    if (freshGameData.playerOrder[freshGameData.currentPlayerIndex] !== currentUserId) {
                        throw new Error("Not your turn (checked in transaction).");
                    }
                     if (playerState.inDetention) {
                        throw new Error("Still in detention (checked in transaction).");
                    }

                    let newPosition = playerState.position;
                    let messages = [];
                    let updates = {};

                    let currentDoublesCount = playerState.doublesRolledInTurn || 0;
                    if (isDoubles) {
                        currentDoublesCount++;
                    } else {
                        currentDoublesCount = 0;
                    }
                    updates[`players.${currentUserId}.doublesRolledInTurn`] = currentDoublesCount;

                    if (isDoubles && currentDoublesCount === 3) {
                        messages.push(`${playerState.name} rolled 3 doubles! Sent to Detention.`);
                        newPosition = detentionCenterSpaceId;
                        updates[`players.${currentUserId}.position`] = newPosition;
                        updates[`players.${currentUserId}.inDetention`] = true;
                        updates[`players.${currentUserId}.missedTurnsInDetention`] = 0;
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = true;
                        updates[`players.${currentUserId}.doublesRolledInTurn`] = 0;
                    } else {
                        newPosition = (playerState.position + totalRoll) % freshGameData.boardLayout.length;
                        updates[`players.${currentUserId}.position`] = newPosition;
                        const landedSpace = freshGameData.boardLayout[newPosition];
                        messages.push(`${playerState.name} rolled ${totalRoll} (${die1}, ${die2})${isDoubles ? " (Doubles!)" : ""}. Moved to ${landedSpace.name}.`);

                        let passedGo = false;
                        if (playerState.position + totalRoll >= freshGameData.boardLayout.length && !(isDoubles && currentDoublesCount ===3) && !playerState.inDetention ) {
                             passedGo = true;
                        }
                        if (passedGo) {
                            const goPayout = 400;
                            updates[`players.${currentUserId}.money`] = (playerState.money || 0) + goPayout;
                            updates.ukGovMoney = (freshGameData.ukGovMoney || 0) - goPayout;
                            updates[`players.${currentUserId}.govReceived`] = (playerState.govReceived || 0) + goPayout;
                            messages.push(`${playerState.name} passed Dole and collected Â£${goPayout}.`);
                        }

                        if (landedSpace.type === 'payout' && landedSpace.amount) {
                            updates[`players.${currentUserId}.money`] = (updates[`players.${currentUserId}.money`] || playerState.money) + landedSpace.amount;
                            updates.ukGovMoney = (updates.ukGovMoney || freshGameData.ukGovMoney) - landedSpace.amount;
                            updates[`players.${currentUserId}.govReceived`] = (updates[`players.${currentUserId}.govReceived`] || playerState.govReceived || 0) + landedSpace.amount;
                            messages.push(`${playerState.name} collected Â£${landedSpace.amount} from ${landedSpace.name}.`);
                        } else if (landedSpace.type === 'tax' && landedSpace.amount) {
                            updates[`players.${currentUserId}.money`] = (playerState.money || 0) - landedSpace.amount;
                            updates.bankMoney = (freshGameData.bankMoney || 0) + landedSpace.amount;
                            messages.push(`${playerState.name} paid Â£${landedSpace.amount} for ${landedSpace.name}.`);
                        } else if (landedSpace.type === 'crime_spree' && landedSpace.amount) {
                            updates[`players.${currentUserId}.money`] = (playerState.money || 0) - landedSpace.amount;
                            updates.bankMoney = (freshGameData.bankMoney || 0) + landedSpace.amount;
                            messages.push(`${playerState.name} landed on Crime Spree and was fined Â£${landedSpace.amount}!`);
                        } else if (landedSpace.type === 'go_to_detention') {
                            updates[`players.${currentUserId}.position`] = detentionCenterSpaceId;
                            updates[`players.${currentUserId}.inDetention`] = true;
                            updates[`players.${currentUserId}.missedTurnsInDetention`] = 0;
                            messages.push(`${playerState.name} was sent to Detention!`);
                            isDoubles = false;
                            currentDoublesCount = 0;
                            updates[`players.${currentUserId}.doublesRolledInTurn`] = 0;
                        } else if (landedSpace.type === 'property' || landedSpace.type === 'set_property') {
                            const propertyDataEntry = freshGameData.propertyData.find(p => p.id === landedSpace.id);
                            if (propertyDataEntry && propertyDataEntry.owner && propertyDataEntry.owner !== currentUserId) {
                                landedPropertyIdForRentCheck = landedSpace.id; // Mark for rent check after transaction
                            }
                        }


                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = !isDoubles;
                    }

                    updates.lastDiceRoll = { die1, die2, total: totalRoll, isDoubles };
                    updates.lastActionMessage = messages.join(" ");
                    updates.updatedAt = serverTimestamp();
                    transaction.update(gameDocRef, updates);
                });

                // After successful transaction, check for card draw or rent payment
                setTimeout(async () => {
                    // Use localGameData which would have been updated by onSnapshot due to the transaction
                    const gameDataForPostMoveActions = localGameData;
                    if (!gameDataForPostMoveActions || !gameDataForPostMoveActions.players || !gameDataForPostMoveActions.players[currentUserId]) return;

                    const playerAfterMove = gameDataForPostMoveActions.players[currentUserId];
                    const boardForPostMoveActions = gameDataForPostMoveActions.boardLayout;

                    if (!boardForPostMoveActions || playerAfterMove.isBankrupt) return;
                    if (playerAfterMove.inDetention && !(isDoubles && currentDoublesCount === 3) ) return; // If sent to jail by card/space, don't process other landing actions like cards

                    const landedSpaceAfterMove = boardForPostMoveActions[playerAfterMove.position];
                    if (!landedSpaceAfterMove) return;

                    // Condition to draw card: player's turn, not bankrupt, not in jail (unless just sent), no card already showing
                    if (gameDataForPostMoveActions.playerOrder[gameDataForPostMoveActions.currentPlayerIndex] === currentUserId &&
                        !gameDataForPostMoveActions.currentCardDraw) {

                        if (landedSpaceAfterMove.type === 'opportunity') {
                            drawAndShowOpportunityCard(currentUserId);
                        } else if (landedSpaceAfterMove.type === 'welfare') {
                            drawAndShowWelfareCard(currentUserId);
                        } else if (landedPropertyIdForRentCheck !== -1 && (landedSpaceAfterMove.type === 'property' || landedSpaceAfterMove.type === 'set_property')) {
                            // If rent was marked for checking and we didn't draw a card (cards take precedence)
                            await processRentPayment(currentUserId, landedPropertyIdForRentCheck);
                        }
                    }
                }, 300); // Short delay for state propagation


            } catch (error) {
                console.error("Error during roll dice action transaction:", error);
                showMessageModal("Roll Error", "Could not process roll transaction: " + error.message);
                if (rollDiceButton && localGameData && localGameData.playerOrder && localGameData.playerOrder[localGameData.currentPlayerIndex] === currentUserId) {
                    rollDiceButton.disabled = false;
                }
            }
        }

        async function handleEndTurnAction() {
            logEvent("handleEndTurnAction called.");

            if (!currentGameId || !localGameData || !currentUserId || !db) {
                logEvent("EndTurn: Exiting - Missing critical global vars.");
                showMessageModal("Error", "Game data or connection issue.");
                return;
            }

            const gameDataForCheck = localGameData;
            const currentPlayerId = gameDataForCheck.playerOrder[gameDataForCheck.currentPlayerIndex];

            if (gameDataForCheck.players && gameDataForCheck.players[currentUserId]) {
                const pState = gameDataForCheck.players[currentUserId];
                // logEvent(`EndTurn Initial Check...`); // Simplified log
            }


            if (currentPlayerId !== currentUserId) {
                logEvent(`EndTurn: ERROR - It's not your turn! Expected: ${currentPlayerId}, You are: ${currentUserId}.`);
                showMessageModal("Error", "It's not your turn to end.");
                return;
            }

            const playerState = gameDataForCheck.players[currentUserId];
            if (!playerState || playerState.isBankrupt) {
                logEvent(`EndTurn: Exiting - Player state error or bankrupt.`);
                showMessageModal("Error", "Cannot end turn (player state error or bankrupt).");
                return;
            }

            if (gameDataForCheck.lastDiceRoll?.isDoubles &&
                (playerState.doublesRolledInTurn || 0) > 0 &&
                (playerState.doublesRolledInTurn || 0) < 3 &&
                !playerState.inDetention &&
                !playerState.playerActionTakenThisTurn) {
                logEvent("EndTurn: Exiting - Player must roll again (doubles).");
                showMessageModal("Doubles!", "You rolled doubles, please roll again before ending your turn!");
                return;
            }
            if (!playerState.playerActionTakenThisTurn && !playerState.inDetention) {
                logEvent("EndTurn: Exiting - Player has not taken their main action (e.g., rolled dice). playerActionTakenThisTurn is false.");
                showMessageModal("Action Required", "You must take an action (e.g., roll dice) before ending your turn.");
                return;
            }

            logEvent("EndTurn: Proceeding to transaction.");
            if(endTurnButton) endTurnButton.disabled = true;

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game not found for end turn.");
                    const freshGameData = freshGameDoc.data();

                    if (freshGameData.playerOrder[freshGameData.currentPlayerIndex] !== currentUserId) {
                        logEvent("EndTurn TXN: Turn already changed. Aborting.");
                        return;
                    }
                    const freshPlayerState = freshGameData.players[currentUserId];
                     if (!freshPlayerState || freshPlayerState.isBankrupt) {
                        logEvent("EndTurn TXN: Player bankrupt/missing. Aborting.");
                        return;
                    }
                    if (freshGameData.lastDiceRoll?.isDoubles &&
                        (freshPlayerState.doublesRolledInTurn || 0) > 0 &&
                        (freshPlayerState.doublesRolledInTurn || 0) < 3 &&
                        !freshPlayerState.inDetention &&
                        !freshPlayerState.playerActionTakenThisTurn) {
                        logEvent("EndTurn TXN: Must roll again (doubles) based on fresh data. Aborting.");
                        return;
                    }
                     if (!freshPlayerState.playerActionTakenThisTurn && !freshPlayerState.inDetention) {
                        logEvent("EndTurn TXN: Player action not taken in fresh data. Aborting. playerActionTakenThisTurn is false.");
                        return;
                    }


                    let updates = {};
                    updates[`players.${currentUserId}.playerActionTakenThisTurn`] = false;
                    updates[`players.${currentUserId}.doublesRolledInTurn`] = 0;

                    let nextPlayerIndex = (freshGameData.currentPlayerIndex + 1) % freshGameData.playerOrder.length;
                    let nextPlayerId = freshGameData.playerOrder[nextPlayerIndex];
                    let attempts = 0;
                    const maxAttempts = freshGameData.playerOrder.length;

                    while (freshGameData.players[nextPlayerId]?.isBankrupt && attempts < maxAttempts) {
                        nextPlayerIndex = (nextPlayerIndex + 1) % freshGameData.playerOrder.length;
                        nextPlayerId = freshGameData.playerOrder[nextPlayerIndex];
                        attempts++;
                    }

                    const nonBankruptPlayers = freshGameData.playerOrder.filter(pid => !freshGameData.players[pid]?.isBankrupt);

                    if (nonBankruptPlayers.length <= 1 && freshGameData.playerOrder.length > 1) {
                         updates.status = "finished";
                         const winnerName = nonBankruptPlayers.length === 1 ? freshGameData.players[nonBankruptPlayers[0]].name : "No one";
                         updates.lastActionMessage = `Game Over! ${winnerName} is the winner!`;
                         logEvent(`Game ended. Winner: ${winnerName}`);
                    } else if (attempts >= maxAttempts && nonBankruptPlayers.length > 1) {
                        logEvent("Error in turn progression: Loop completed but non-bankrupt players should exist.");
                        updates.status = "finished";
                        updates.lastActionMessage = "Error finding next player. Game Over.";
                    } else if (nonBankruptPlayers.length === 0 && freshGameData.playerOrder.length >=1){
                        updates.status = "finished";
                        updates.lastActionMessage = "All players are bankrupt! Game Over!";
                    }
                    else {
                        updates.currentPlayerIndex = nextPlayerIndex;
                        updates.lastActionMessage = `${freshPlayerState.name} ended their turn. It's now ${freshGameData.players[nextPlayerId].name}'s turn.`;
                        updates.lastDiceRoll = null;
                    }

                    updates.updatedAt = serverTimestamp();
                    transaction.update(gameDocRef, updates);
                    logEvent(`EndTurn TXN: ${freshPlayerState.name} ended turn. Next is ${nextPlayerId || 'N/A'}.`);
                });
            } catch (error) {
                console.error("Error ending turn (transaction phase):", error);
                showMessageModal("End Turn Error", "Could not end turn: " + error.message);
            }
        }

        async function handleBuyPropertyAction() {
            logEvent("BuyProp: Action initiated by user: " + currentUserId);

            if (!currentGameId || !localGameData || !currentUserId || !db) {
                logEvent("BuyProp: Exiting - Missing critical global vars.");
                showMessageModal("Error", "Game data or connection issue.");
                return;
            }

            const currentSnapshotGameData = localGameData;
            const currentPlayerIdFromOrder = currentSnapshotGameData.playerOrder[currentSnapshotGameData.currentPlayerIndex];
            // logEvent("BuyProp: Current turn player from order: " + currentPlayerIdFromOrder);

            if (currentPlayerIdFromOrder !== currentUserId) {
                logEvent(`BuyProp: Exiting - Not current player's turn.`);
                showMessageModal("Error", "Not your turn to buy property.");
                return;
            }

            const playerState = currentSnapshotGameData.players[currentUserId];
            if (!playerState) {
                logEvent("BuyProp: Exiting - Player state not found for user: " + currentUserId);
                showMessageModal("Error", "Player data not found.");
                return;
            }
            if (playerState.isBankrupt) {
                logEvent(`BuyProp: Exiting - Player ${currentUserId} is bankrupt.`);
                showMessageModal("Error", "Cannot buy property (player is bankrupt).");
                return;
            }

            // logEvent("BuyProp: Player state check passed.");

            if (!currentSnapshotGameData.lastDiceRoll && !playerState.playerActionTakenThisTurn) {
                 logEvent("BuyProp: Exiting - Player has not rolled/landed yet.");
                 showMessageModal("Action Required", "You must roll and land on a space before buying property.");
                 return;
            }

            const currentPosition = playerState.position;
            const spaceDetails = currentSnapshotGameData.boardLayout[currentPosition];
            // logEvent("BuyProp: Attempting to buy space:", { position: currentPosition, spaceDetails });

            const propertyDataEntry = Array.isArray(currentSnapshotGameData.propertyData) ?
                                      currentSnapshotGameData.propertyData.find(p => p.id === currentPosition) : null;

            if (!spaceDetails || !propertyDataEntry || (spaceDetails.type !== 'property' && spaceDetails.type !== 'set_property')) {
                logEvent(`BuyProp: Exiting - Not a buyable property.`);
                showMessageModal("Invalid Space", "Not a buyable property space.");
                return;
            }

            if (propertyDataEntry.owner) {
                logEvent(`BuyProp: Exiting - Property already owned by ${propertyDataEntry.owner}`);
                showMessageModal("Owned", `This property (${spaceDetails.name}) is already owned by ${currentSnapshotGameData.players[propertyDataEntry.owner]?.name || 'another player'}.`);
                return;
            }

            let price = spaceDetails.price;
            let usedVoucher = false;
            if (playerState.hasHousingVoucher && spaceDetails.type === 'property') {
                price = Math.round(price * 0.75);
                usedVoucher = true;
                logEvent("BuyProp: Housing voucher applied. New price: " + price);
            }

            if (playerState.money < price) {
                logEvent(`BuyProp: Exiting - Insufficient funds.`);
                showMessageModal("Insufficient Funds", `You need Â£${price} to buy ${spaceDetails.name}, but you only have Â£${playerState.money}.`);
                return;
            }

            logEvent("BuyProp: All pre-transaction checks passed.");
            if(buyPropertyButton) buyPropertyButton.disabled = true;

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    // logEvent("BuyProp TXN: Inside transaction.");
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) {
                        logEvent("BuyProp TXN: Game doc not found.");
                        throw new Error("Game not found for buying property.");
                    }
                    const freshGameData = freshGameDoc.data();
                    // logEvent("BuyProp TXN: Fetched fresh game data.");

                    if (freshGameData.playerOrder[freshGameData.currentPlayerIndex] !== currentUserId) {
                        logEvent("BuyProp TXN: Not player's turn in fresh data.");
                        throw new Error("Not your turn (checked in transaction).");
                    }
                    const freshPlayerState = freshGameData.players[currentUserId];
                    if (!freshPlayerState || freshPlayerState.isBankrupt) {
                        logEvent("BuyProp TXN: Player state error/bankrupt in fresh data.");
                        throw new Error("Player error in transaction.");
                    }

                    if (!freshGameData.lastDiceRoll && !freshPlayerState.playerActionTakenThisTurn) {
                         logEvent("BuyProp TXN: Player has not rolled/landed (fresh data).");
                         throw new Error("Player action not completed (checked in transaction).");
                    }

                    const freshCurrentPosition = freshPlayerState.position;
                    const actualSpaceDetails = freshGameData.boardLayout[freshCurrentPosition];
                    // logEvent("BuyProp TXN: Fresh player position: " + freshCurrentPosition);

                    if (!Array.isArray(freshGameData.propertyData)) {
                        logEvent("BuyProp TXN: propertyData is not an array in fresh data.");
                        throw new Error("Property data in Firestore is not an array. Cannot buy.");
                    }
                    const freshPropertyDataEntry = freshGameData.propertyData.find(p => p.id === freshCurrentPosition);

                    if (!actualSpaceDetails || !freshPropertyDataEntry || (actualSpaceDetails.type !== 'property' && actualSpaceDetails.type !== 'set_property')) {
                         logEvent("BuyProp TXN: Not a buyable space in fresh data.");
                         throw new Error("Not a buyable property space (checked in transaction).");
                    }
                    if (freshPropertyDataEntry.owner) {
                        logEvent("BuyProp TXN: Property already owned in fresh data by " + freshPropertyDataEntry.owner);
                        throw new Error(`Property (${actualSpaceDetails.name}) already owned by ${freshGameData.players[freshPropertyDataEntry.owner]?.name || 'another player'} (checked in transaction).`);
                    }

                    let actualPrice = actualSpaceDetails.price;
                    let actualUsedVoucher = false;
                    if (freshPlayerState.hasHousingVoucher && actualSpaceDetails.type === 'property') {
                        actualPrice = Math.round(actualPrice * 0.75);
                        actualUsedVoucher = true;
                    }
                    if (freshPlayerState.money < actualPrice) {
                         logEvent("BuyProp TXN: Insufficient funds in fresh data.");
                         throw new Error(`Insufficient funds (Â£${freshPlayerState.money} vs Â£${actualPrice}) for ${actualSpaceDetails.name} (checked in transaction).`);
                    }

                    let updates = {};
                    updates[`players.${currentUserId}.money`] = freshPlayerState.money - actualPrice;
                    updates[`players.${currentUserId}.properties`] = arrayUnion(freshCurrentPosition);
                    if (actualUsedVoucher) {
                        updates[`players.${currentUserId}.hasHousingVoucher`] = false;
                    }

                    const updatedPropertyData = freshGameData.propertyData.map(prop => {
                        if (prop.id === freshCurrentPosition) {
                            return { ...prop, owner: currentUserId };
                        }
                        return prop;
                    });
                    updates.propertyData = updatedPropertyData;

                    updates.lastActionMessage = `${freshPlayerState.name} bought ${actualSpaceDetails.name} for Â£${actualPrice}${actualUsedVoucher ? " (with voucher)" : ""}.`;
                    updates.updatedAt = serverTimestamp();

                    if (!freshGameData.lastDiceRoll?.isDoubles) {
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = true;
                         // logEvent("BuyProp TXN: Non-doubles roll, setting playerActionTakenThisTurn to true.");
                    } else {
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = false;
                        // logEvent("BuyProp TXN: Doubles roll, playerActionTakenThisTurn explicitly set to false to ensure re-roll.");
                    }


                    transaction.update(gameDocRef, updates);
                    // logEvent("BuyProp TXN: Transaction update successful.");

                    if (audioContextStarted && toneSynth) {
                        try {
                            toneSynth.triggerAttackRelease("A3", "16n", Tone.now());
                            toneSynth.triggerAttackRelease("F#3", "16n", Tone.now() + 0.07);
                        } catch(e){ console.error("Buy property sound error:", e); }
                    }
                });
                logEvent("BuyProp: Transaction completed successfully.");
            } catch (error) {
                console.error("Error buying property (transaction phase):", error);
                showMessageModal("Buy Property Error", "Could not buy property: " + error.message);
            } finally {
                 logEvent("BuyProp: Action finished.");
            }
        }

        async function handlePreGameRollAction() {
            if (!currentGameId || !localGameData || !localGameData.preGamePhase) {
                showMessageModal("Error", "Not in pre-game roll phase.");
                return;
            }
             if (Object.keys(localGameData.players).length < localGameData.maxPlayers) {
                showMessageModal("Waiting", "Waiting for all players to join before rolling.");
                return;
            }
            if (localGameData.preGameRolls && localGameData.preGameRolls[currentUserId] !== undefined) {
                showMessageModal("Already Rolled", "You have already rolled for starting position.");
                return;
            }

            let nextToRollInPreGame = null;
            const sortedByJoinOrderForPreGame = [...localGameData.playerOrder].sort((a,b) => (localGameData.players[a]?.order || 0) - (localGameData.players[b]?.order || 0));
            for (const pid of sortedByJoinOrderForPreGame) {
                if (!localGameData.preGameRolls || localGameData.preGameRolls[pid] === undefined) {
                    nextToRollInPreGame = pid;
                    break;
                }
            }
            if (nextToRollInPreGame !== currentUserId) {
                showMessageModal("Wait", "It's not your turn to roll for starting position.");
                return;
            }


            if(preGameRollButton) preGameRollButton.disabled = true;
            const roll = Math.floor(Math.random() * 6) + 1 + Math.floor(Math.random() * 6) + 1;

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game not found for pre-game roll.");
                    const freshGameData = freshGameDoc.data();
                     if (!freshGameData.players || !freshGameData.players[currentUserId]) throw new Error("Player data missing in Firestore for pre-game roll.");
                     if (!freshGameData.preGamePhase) throw new Error("Pre-game phase ended.");
                     if (freshGameData.preGameRolls && freshGameData.preGameRolls[currentUserId] !== undefined) {
                         throw new Error("Already rolled (checked in transaction).");
                     }

                    let updates = {};
                    updates[`preGameRolls.${currentUserId}`] = roll;
                    updates.lastActionMessage = `${freshGameData.players[currentUserId].name} rolled ${roll} for starting order.`;
                    updates.updatedAt = serverTimestamp();

                    const currentPreGameRollsWithThis = { ...(freshGameData.preGameRolls || {}), [currentUserId]: roll };
                    const allPlayersInOrder = freshGameData.playerOrder || [];
                    const allHaveRolled = allPlayersInOrder.length > 0 &&
                                          allPlayersInOrder.length === freshGameData.maxPlayers &&
                                          allPlayersInOrder.every(pid => currentPreGameRollsWithThis[pid] !== undefined);


                    if (allHaveRolled) {
                        updates.lastActionMessage += " All players rolled.";
                        if (currentUserId === freshGameData.hostId) {
                            logEvent("Host is the last to roll (or among the last) in pre-game, finalizing directly.");
                            const sortedPlayerIds = [...allPlayersInOrder].sort((a, b) => {
                                const rollA = currentPreGameRollsWithThis[a];
                                const rollB = currentPreGameRollsWithThis[b];
                                if (rollB === rollA) {
                                    return (freshGameData.players[a]?.order || 0) - (freshGameData.players[b]?.order || 0);
                                }
                                return rollB - rollA;
                            });
                            updates.playerOrder = sortedPlayerIds;
                            updates.currentPlayerIndex = 0;
                            updates.preGamePhase = false;
                            updates.gamePhase = "main";
                            updates.status = "active";
                            updates.lastActionMessage = `Starting order determined. ${freshGameData.players[sortedPlayerIds[0]].name} starts!`;
                        } else {
                            updates.lastActionMessage += " Waiting for host to finalize starting order.";
                        }
                    }
                    transaction.update(gameDocRef, updates);
                });
            } catch (error) {
                console.error("Error during pre-game roll:", error);
                showMessageModal("Roll Error", "Could not process pre-game roll: " + error.message);
                if(preGameRollButton) preGameRollButton.disabled = false;
            }
        }


        createGameButton.onclick = handleCreateGame;
        joinGameButton.onclick = handleJoinGame;
        rollDiceButton.onclick = handleRollDiceAction;
        preGameRollButton.onclick = handlePreGameRollAction;
        endTurnButton.onclick = handleEndTurnAction;
        buyPropertyButton.onclick = handleBuyPropertyAction;
        developPropertyButton.onclick = () => {
            if (localGameData && currentUserId && localGameData.players && localGameData.players[currentUserId]) {
                showDevelopPropertyOptions(localGameData.players[currentUserId], localGameData);
            }
        };
        closeDevelopButton.onclick = () => {
            if(developPropertyContainer) developPropertyContainer.style.display = 'none';
        };

        generatedGameIdSpan.onclick = () => {
            if (generatedGameIdSpan.textContent) {
                navigator.clipboard.writeText(generatedGameIdSpan.textContent)
                    .then(() => showMessageModal("Copied!", "Game ID copied to clipboard."))
                    .catch(err => {
                        console.error('Failed to copy Game ID: ', err);
                        showMessageModal("Copy Failed", "Could not copy Game ID automatically. Please select and copy manually.");
                    });
            }
        };

        function shuffleDeck(deck) {
            let newDeck = [...deck];
            for (let i = newDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
            }
            return newDeck;
        }

        function canPlayerDevelopAnyProperty(playerState, gameData) {
            if (!playerState || playerState.isBankrupt || !gameData || !Array.isArray(gameData.propertyData) || !gameData.boardLayout) return false;

            return playerState.properties.some(propId => {
                const propDetails = gameData.propertyData.find(p => p.id === propId);
                const propLayout = gameData.boardLayout.find(s => s.id === propId);

                if (!propDetails || !propLayout || propLayout.type !== 'property') return false;
                if (propDetails.owner !== playerState.id || propDetails.permanentResidence) return false;

                const groupPropertiesLayout = gameData.boardLayout.filter(s => s.groupId === propLayout.groupId && s.type === 'property');
                const ownsAllInGroup = groupPropertiesLayout.every(gpLayout => {
                    const gpDataForCheck = gameData.propertyData.find(pd => pd.id === gpLayout.id);
                    return gpDataForCheck && gpDataForCheck.owner === playerState.id;
                });
                if (!ownsAllInGroup) return false;

                return (propDetails.tenancies < MAX_TENANCIES) || (propDetails.tenancies === MAX_TENANCIES && !propDetails.permanentResidence);
            });
        }

        function setupDetentionActionsUI(playerState, gameData) {
            if (!playerState || !playerState.inDetention || !detentionActionsDiv) return;
            detentionActionsDiv.innerHTML = '';

            const canTakeAction = gameData.playerOrder[gameData.currentPlayerIndex] === currentUserId && !playerState.playerActionTakenThisTurn;

            if (playerState.getOutOfDetentionCards > 0) {
                const useCardBtn = document.createElement('button');
                useCardBtn.textContent = "Use Legal Aid Card";
                useCardBtn.disabled = !canTakeAction;
                useCardBtn.onclick = async () => {
                    const gameDocRef = doc(db, "games", currentGameId);
                    try {
                        await updateDoc(gameDocRef, {
                            [`players.${currentUserId}.getOutOfDetentionCards`]: playerState.getOutOfDetentionCards - 1,
                            [`players.${currentUserId}.inDetention`]: false,
                            [`players.${currentUserId}.missedTurnsInDetention`]: 0,
                            [`players.${currentUserId}.playerActionTakenThisTurn`]: false,
                            lastActionMessage: `${playerState.name} used a Legal Aid card and is free. Roll to move.`,
                            updatedAt: serverTimestamp()
                        });
                    } catch (e) { showMessageModal("Error", "Failed to use card: " + e.message); }
                };
                detentionActionsDiv.appendChild(useCardBtn);
            }

            const fineAmount = 50;
            if (playerState.money >= fineAmount) {
                const payFineBtn = document.createElement('button');
                payFineBtn.textContent = `Pay Â£${fineAmount} Fine`;
                payFineBtn.disabled = !canTakeAction;
                payFineBtn.onclick = async () => {
                    const gameDocRef = doc(db, "games", currentGameId);
                     try {
                        await updateDoc(gameDocRef, {
                            [`players.${currentUserId}.money`]: playerState.money - fineAmount,
                            [`players.${currentUserId}.inDetention`]: false,
                            [`players.${currentUserId}.missedTurnsInDetention`]: 0,
                            [`players.${currentUserId}.playerActionTakenThisTurn`]: false,
                            bankMoney: (gameData.bankMoney || 0) + fineAmount,
                            lastActionMessage: `${playerState.name} paid Â£${fineAmount} fine and is free. Roll to move.`,
                            updatedAt: serverTimestamp()
                        });
                    } catch (e) { showMessageModal("Error", "Failed to pay fine: " + e.message); }
                };
                detentionActionsDiv.appendChild(payFineBtn);
            }

            const rollDoublesBtn = document.createElement('button');
            rollDoublesBtn.textContent = "Roll for Doubles (Exit Jail)";
            rollDoublesBtn.disabled = !canTakeAction;
            rollDoublesBtn.onclick = async () => {
                const die1 = Math.floor(Math.random() * 6) + 1;
                const die2 = Math.floor(Math.random() * 6) + 1;
                const isDoubles = die1 === die2;
                const totalRoll = die1 + die2;

                const gameDocRef = doc(db, "games", currentGameId);
                let updates = { updatedAt: serverTimestamp(), lastDiceRoll: {die1, die2, total: totalRoll, isDoubles: isDoubles} };
                let missedTurns = playerState.missedTurnsInDetention || 0;

                if (isDoubles) {
                    updates[`players.${currentUserId}.inDetention`] = false;
                    updates[`players.${currentUserId}.missedTurnsInDetention`] = 0;
                    updates[`players.${currentUserId}.playerActionTakenThisTurn`] = false;
                    updates.lastActionMessage = `${playerState.name} rolled doubles (${die1},${die2}) and is out of Detention! Roll again to move.`;
                } else {
                    missedTurns++;
                    updates[`players.${currentUserId}.missedTurnsInDetention`] = missedTurns;
                    updates[`players.${currentUserId}.playerActionTakenThisTurn`] = true;
                    if (missedTurns >= 3) {
                        updates[`players.${currentUserId}.inDetention`] = false;
                        updates[`players.${currentUserId}.missedTurnsInDetention`] = 0;
                        updates[`players.${currentUserId}.money`] = (playerState.money || 0) - fineAmount;
                        updates.bankMoney = (gameData.bankMoney || 0) + fineAmount;
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = false;
                        updates.lastActionMessage = `${playerState.name} failed to roll doubles for 3 turns, paid Â£${fineAmount} fine and is out. Must roll to move on their next turn.`;
                    } else {
                        updates.lastActionMessage = `${playerState.name} failed to roll doubles (${die1},${die2}) in detention. Still in detention. ${3 - missedTurns} attempt(s) left.`;
                    }
                }
                 try {
                    await updateDoc(gameDocRef, updates);
                } catch (e) { showMessageModal("Error", "Failed to roll for doubles in detention: " + e.message); }
            };
            detentionActionsDiv.appendChild(rollDoublesBtn);
        }

        function showDevelopPropertyOptions(playerState, gameData) {
            if (!developPropertyContainer || !developPropertyOptionsDiv || !developPropertyNameH3) return;

            developPropertyOptionsDiv.innerHTML = '';
            developPropertyNameH3.textContent = "Develop Property";

            let canDevelopAnything = false;

            playerState.properties.forEach(propId => {
                const propLayout = gameData.boardLayout.find(s => s.id === propId);
                const propData = gameData.propertyData.find(p => p.id === propId);

                if (propLayout && propData && propLayout.type === 'property' && propData.owner === playerState.id) {
                    const groupPropertiesLayout = gameData.boardLayout.filter(s => s.groupId === propLayout.groupId && s.type === 'property');
                    const ownsAllInGroup = groupPropertiesLayout.every(gpLayout => {
                        const gpDataForCheck = gameData.propertyData.find(pd => pd.id === gpLayout.id);
                        return gpDataForCheck && gpDataForCheck.owner === playerState.id;
                    });

                    if (ownsAllInGroup) {
                        if (!propData.permanentResidence && propData.tenancies < MAX_TENANCIES) {
                            const addTenancyButton = document.createElement('button');
                            addTenancyButton.textContent = `Add Tenancy to ${propLayout.name} (Â£${TENANCY_COST})`;
                            addTenancyButton.disabled = playerState.money < TENANCY_COST;
                            addTenancyButton.onclick = () => handleConfirmDevelopment(propId, 'tenancy');
                            developPropertyOptionsDiv.appendChild(addTenancyButton);
                            canDevelopAnything = true;
                        }
                        if (!propData.permanentResidence && propData.tenancies === MAX_TENANCIES) {
                            const buildPRButton = document.createElement('button');
                            buildPRButton.textContent = `Build PR on ${propLayout.name} (Â£${PR_COST})`;
                            buildPRButton.disabled = playerState.money < PR_COST;
                            buildPRButton.onclick = () => handleConfirmDevelopment(propId, 'pr');
                            developPropertyOptionsDiv.appendChild(buildPRButton);
                            canDevelopAnything = true;
                        }
                    }
                }
            });

            if (!canDevelopAnything) {
                developPropertyOptionsDiv.innerHTML = '<p>No properties currently eligible for development.</p>';
            }
            developPropertyContainer.style.display = 'block';
        }

        async function handleConfirmDevelopment(propertyId, developmentType) {
            logEvent(`handleConfirmDevelopment called for prop: ${propertyId}, type: ${developmentType}`);
            if (!currentGameId || !localGameData || !currentUserId || !db) {
                showMessageModal("Error", "Game data or connection issue.");
                return;
            }

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game not found for development.");

                    const freshGameData = freshGameDoc.data();
                    const playerState = freshGameData.players[currentUserId];
                    const propLayout = freshGameData.boardLayout.find(s => s.id === propertyId);
                    const propDataIndex = freshGameData.propertyData.findIndex(p => p.id === propertyId);

                    if (propDataIndex === -1 || !propLayout || !playerState) {
                        throw new Error("Property or player data not found for development.");
                    }
                    const propData = freshGameData.propertyData[propDataIndex];

                    if (freshGameData.playerOrder[freshGameData.currentPlayerIndex] !== currentUserId) {
                        throw new Error("Not your turn to develop.");
                    }
                    if (propData.owner !== currentUserId) {
                        throw new Error("You do not own this property.");
                    }
                    if (propLayout.type !== 'property') {
                        throw new Error("This type of property cannot be developed.");
                    }

                    const groupPropertiesLayout = freshGameData.boardLayout.filter(s => s.groupId === propLayout.groupId && s.type === 'property');
                    const ownsAllInGroup = groupPropertiesLayout.every(gpLayout => {
                        const gpDataForCheck = freshGameData.propertyData.find(pd => pd.id === gpLayout.id);
                        return gpDataForCheck && gpDataForCheck.owner === currentUserId;
                    });
                    if (!ownsAllInGroup) {
                        throw new Error(`You must own all properties in the ${propLayout.color || propLayout.groupId} group to develop.`);
                    }

                    let cost = 0;
                    let newTenancies = propData.tenancies;
                    let newPR = propData.permanentResidence;
                    let developmentMessage = "";

                    if (developmentType === 'tenancy') {
                        if (propData.permanentResidence) throw new Error("Cannot add tenancies to a property with Permanent Residence.");
                        if (propData.tenancies >= MAX_TENANCIES) throw new Error("Maximum tenancies reached.");
                        cost = TENANCY_COST;
                        newTenancies++;
                        developmentMessage = `added a tenancy to ${propLayout.name}`;
                    } else if (developmentType === 'pr') {
                        if (propData.permanentResidence) throw new Error("Permanent Residence already built.");
                        if (propData.tenancies < MAX_TENANCIES) throw new Error(`Must have ${MAX_TENANCIES} tenancies to build PR.`);
                        cost = PR_COST;
                        newPR = true;
                        developmentMessage = `built Permanent Residence on ${propLayout.name}`;
                    } else {
                        throw new Error("Invalid development type.");
                    }

                    if (playerState.money < cost) {
                        throw new Error(`Insufficient funds. Need Â£${cost}.`);
                    }

                    const updates = {};
                    updates[`players.${currentUserId}.money`] = playerState.money - cost;

                    const updatedPropertyDataArray = freshGameData.propertyData.map((p, index) => {
                        if (index === propDataIndex) {
                            return { ...p, tenancies: newTenancies, permanentResidence: newPR };
                        }
                        return p;
                    });
                    updates.propertyData = updatedPropertyDataArray;

                    updates.lastActionMessage = `${playerState.name} ${developmentMessage} for Â£${cost}.`;
                    updates.updatedAt = serverTimestamp();

                    transaction.update(gameDocRef, updates);
                    logEvent("Development successful in transaction:", updates);
                });

                developPropertyContainer.style.display = 'none';

            } catch (error) {
                console.error("Error confirming development:", error);
                showMessageModal("Development Error", error.message);
            }
        }


        document.addEventListener('DOMContentLoaded', async () => {
            if (firebaseConfigToUse.apiKey === "YOUR_API_KEY" || !firebaseConfigToUse.projectId) {
                 onlineSetupMessage.textContent = "CRITICAL: Firebase is not configured. Please update firebaseConfigToUse in the script.";
                 console.error("CRITICAL: Firebase configuration is a placeholder. Update it with your actual Firebase project details.");
                 createGameButton.disabled = true;
                 joinGameButton.disabled = true;
                 showMessageModal("SETUP REQUIRED", "Firebase is not configured. Online features are disabled. See console for details.");
                 return;
            }
            reformatBoardLayout();
            await initializeFirebase();

            const overlay = document.querySelector('.overlay');
            if(overlay) overlay.style.display = 'none';
        });

        document.body.addEventListener('click', async () => {
            if (!audioContextStarted && typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                try {
                    await Tone.start();
                    audioContextStarted = true;
                    logEvent("AudioContext started by user interaction.");
                    if (!toneSynth) {
                        toneSynth = new Tone.Synth({
                            oscillator: { type: "triangle" },
                            envelope: { attack: 0.005, decay: 0.1, sustain: 0.2, release: 0.3 }
                        }).toDestination();
                        logEvent("Tone.Synth initialized.");
                    }
                } catch (e) {
                    console.error("Error starting Tone.js AudioContext or initializing synth:", e);
                }
            }
        }, { once: true });

        async function setCurrentCardDraw(card, type, playerId) {
            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await updateDoc(gameDocRef, {
                    currentCardDraw: {
                        id: `${Date.now()}_${Math.random().toString(36).substr(2,5)}`,
                        type: type,
                        text: card.text,
                        action: card.action,
                        amount: card.amount || null,
                        amountPer: card.amountPer || null,
                        playerId: playerId,
                        timestamp: serverTimestamp()
                    },
                    updatedAt: serverTimestamp(),
                });
                logEvent(`Card draw set in Firestore: ${type} - ${card.text} for player ${playerId}`);
            } catch (error)
            {
                console.error("Error setting current card draw in Firestore:", error);
                showMessageModal("Card Error", "Could not register card draw online: " + error.message);
            }
        }

        function drawAndShowOpportunityCard(playerId) {
            const gameData = localGameData;
            if (!gameData || !gameData.shuffledOpportunityCards) return;
            let cardIndex = gameData.opportunityCardIndex || 0;
            let deck = gameData.shuffledOpportunityCards;
            if (cardIndex >= deck.length) {
                deck = shuffleDeck([...opportunityCards]);
                cardIndex = 0;
            }
            const card = deck[cardIndex];

            setCurrentCardDraw(card, 'Opportunity', playerId);

            updateDoc(doc(db, "games", currentGameId), {
                opportunityCardIndex: cardIndex + 1,
                shuffledOpportunityCards: deck,
                updatedAt: serverTimestamp()
            });
        }

        function drawAndShowWelfareCard(playerId) {
            const gameData = localGameData;
            if (!gameData || !gameData.shuffledWelfareCards) return;
            let cardIndex = gameData.welfareCardIndex || 0;
            let deck = gameData.shuffledWelfareCards;
            if (cardIndex >= deck.length) {
                deck = shuffleDeck([...welfareCards]);
                cardIndex = 0;
            }
            const card = deck[cardIndex];

            setCurrentCardDraw(card, 'Welfare', playerId);

            updateDoc(doc(db, "games", currentGameId), {
                welfareCardIndex: cardIndex + 1,
                shuffledWelfareCards: deck,
                updatedAt: serverTimestamp()
            });
        }


        // MODIFIED: Card display timing and button enabling
        function showCardModalFromFirestore(cardDrawData) {
            if (!onBoardCardDisplayDiv || !onBoardCardTypeH4 || !onBoardCardTextP || !onBoardCardOkButton) {
                console.error("On-board card display elements not found! Cannot show card.");
                return;
            }
            logEvent(`Displaying card modal for all: ${cardDrawData.type} - "${cardDrawData.text}" for player ${cardDrawData.playerId}`);

            onBoardCardTypeH4.textContent = `${cardDrawData.type} Card`;
            onBoardCardTextP.textContent = cardDrawData.text;
            onBoardCardDisplayDiv.style.display = 'flex';

            onBoardCardOkButton.disabled = true; // Disable button initially
            onBoardCardOkButton.textContent = 'Viewing Card...';
            onBoardCardOkButton.style.cursor = 'default';


            if (audioContextStarted && toneSynth) {
                try {
                    toneSynth.triggerAttackRelease("G4", "8n", Tone.now());
                    toneSynth.triggerAttackRelease("C5", "8n", Tone.now() + 0.15);
                } catch(e) { console.error("Card display sound error:", e); }
            }

            setTimeout(() => {
                // Only enable if the card display is still active and this specific card is being shown
                if (onBoardCardDisplayDiv.style.display === 'flex' && window._lastCardDrawIdShown === cardDrawData.id) {
                    onBoardCardOkButton.disabled = false;
                    onBoardCardOkButton.textContent = 'OK';
                    onBoardCardOkButton.style.cursor = 'pointer';
                    logEvent(`Card OK button enabled for card ID ${cardDrawData.id} after 2s delay.`);
                }
            }, 2000); // 2 seconds delay

            onBoardCardOkButton.onclick = async () => {
                logEvent(`On-board card OK clicked by: ${currentUserId}. Card was drawn by: ${cardDrawData.playerId}. Action: ${cardDrawData.action}`);
                onBoardCardDisplayDiv.style.display = 'none';

                if (currentUserId === cardDrawData.playerId) {
                    logEvent(`Player ${currentUserId} is the one who drew the card. Applying action.`);
                    const gameDocRef = doc(db, "games", currentGameId);
                    try {
                        const currentGlobalGameSnapshot = await getDoc(gameDocRef);
                        if (currentGlobalGameSnapshot.exists()) {
                            const currentGlobalGameData = currentGlobalGameSnapshot.data();
                            await applyCardAction(cardDrawData, cardDrawData.playerId, cardDrawData.type.toLowerCase(), currentGlobalGameData);
                        } else {
                            console.error("Game document missing when trying to apply card action.");
                            showMessageModal("Error", "Game data is unavailable. Cannot apply card effect.");
                            return;
                        }

                        await updateDoc(gameDocRef, {
                            currentCardDraw: null,
                            updatedAt: serverTimestamp()
                        });
                        logEvent("currentCardDraw cleared from Firestore by " + currentUserId);
                        window._lastCardDrawIdShown = null;
                    } catch (error) {
                        console.error("Error during card OK click processing:", error);
                        showMessageModal("Card Error", "Failed to process card action: " + error.message);
                    }
                }
            };
        }

        async function applyCardAction(drawnCard, playerId, deckType, currentGlobalGameData) {
            logEvent(`Applying card action: ${drawnCard.action} for player ${playerId} from ${deckType} deck. Card text: "${drawnCard.text}"`);
            if (!currentGameId || !db) {
                console.error("applyCardAction: Missing gameId or db connection.");
                return;
            }
            const gameDocRef = doc(db, "games", currentGameId);
            let updates = { updatedAt: serverTimestamp() };

            const playerState = currentGlobalGameData.players[playerId];
            if (!playerState) {
                console.error(`applyCardAction: Player ${playerId} not found in game data.`);
                showMessageModal("Error", `Player data for ${playerId} is missing.`);
                return;
            }

            let message = `${playerState.name} drew ${deckType} card: "${drawnCard.text}". `;

            switch(drawnCard.action) {
                case 'collect':
                    updates[`players.${playerId}.money`] = (playerState.money || 0) + (drawnCard.amount || 0);
                    if (drawnCard.text.toLowerCase().includes("benefit") || drawnCard.text.toLowerCase().includes("grant") || drawnCard.text.toLowerCase().includes("subsidy") || drawnCard.text.toLowerCase().includes("refund") || drawnCard.text.toLowerCase().includes("advance to go")) {
                        updates[`players.${playerId}.govReceived`] = (playerState.govReceived || 0) + (drawnCard.amount || 0);
                        updates.ukGovMoney = (currentGlobalGameData.ukGovMoney || 0) - (drawnCard.amount || 0);
                    }
                    message += `Collected Â£${drawnCard.amount}.`;
                    break;
                case 'pay':
                    updates[`players.${playerId}.money`] = (playerState.money || 0) - (drawnCard.amount || 0);
                    updates.bankMoney = (currentGlobalGameData.bankMoney || 0) + (drawnCard.amount || 0);
                    message += `Paid Â£${drawnCard.amount}.`;
                    break;
                case 'getOutOfDetentionFree':
                    updates[`players.${playerId}.getOutOfDetentionCards`] = (playerState.getOutOfDetentionCards || 0) + 1;
                    message += `Received a Legal Aid card.`;
                    break;
                case 'goToDetentionDirect':
                    updates[`players.${playerId}.position`] = detentionCenterSpaceId;
                    updates[`players.${playerId}.inDetention`] = true;
                    updates[`players.${playerId}.missedTurnsInDetention`] = 0;
                    updates[`players.${playerId}.doublesRolledInTurn`] = 0;
                    updates[`players.${playerId}.playerActionTakenThisTurn`] = true;
                    message += `Sent to Detention Center.`;
                    break;
                case 'gainHealthService':
                     updates[`players.${playerId}.healthServices`] = (playerState.healthServices || 0) + 1;
                     message += `Gained a health service.`;
                     break;
                case 'payPerTenancy':
                    let totalTenancyFine = 0;
                    if (Array.isArray(playerState.properties) && Array.isArray(currentGlobalGameData.propertyData)) {
                        playerState.properties.forEach(propId => {
                            const propData = currentGlobalGameData.propertyData.find(p => p.id === propId);
                            if (propData && propData.owner === playerId && propData.tenancies > 0 && !propData.permanentResidence) {
                                totalTenancyFine += (propData.tenancies * (drawnCard.amountPer || 0));
                            }
                        });
                    }
                    updates[`players.${playerId}.money`] = (playerState.money || 0) - totalTenancyFine;
                    updates.bankMoney = (currentGlobalGameData.bankMoney || 0) + totalTenancyFine;
                    message += `Paid Â£${totalTenancyFine} for housing inspection (${drawnCard.amountPer || 0} per tenancy).`;
                    break;
                case 'moveToNearestPayout':
                    let currentPos = playerState.position;
                    let nearestPayoutDist = Infinity;
                    let nearestPayoutId = -1;
                    let passedGoOnCardMove = false;

                    if (Array.isArray(currentGlobalGameData.boardLayout)) {
                        currentGlobalGameData.boardLayout.forEach((space, idx) => {
                            if (space.type === 'payout') {
                                let distForward = (idx - currentPos + currentGlobalGameData.boardLayout.length) % currentGlobalGameData.boardLayout.length;
                                if (distForward === 0) distForward = currentGlobalGameData.boardLayout.length;

                                if (distForward < nearestPayoutDist) {
                                    nearestPayoutDist = distForward;
                                    nearestPayoutId = idx;
                                }
                            }
                        });
                    }

                    if (nearestPayoutId !== -1) {
                        if (nearestPayoutId < currentPos && nearestPayoutDist > currentGlobalGameData.boardLayout.length / 2) { // Passed Go if new position is smaller and distance is large
                            passedGoOnCardMove = true;
                        }
                        updates[`players.${playerId}.position`] = nearestPayoutId;
                        const payoutSpace = currentGlobalGameData.boardLayout[nearestPayoutId];
                        let collectedAmount = (payoutSpace.amount || 0);
                        updates[`players.${playerId}.money`] = (playerState.money || 0) + collectedAmount;
                        updates[`players.${playerId}.govReceived`] = (playerState.govReceived || 0) + collectedAmount;
                        updates.ukGovMoney = (currentGlobalGameData.ukGovMoney || 0) - collectedAmount;
                        message += `Moved to ${payoutSpace.name} and collected Â£${collectedAmount}.`;

                        if (passedGoOnCardMove) {
                            const goPayout = 400;
                            updates[`players.${playerId}.money`] = (updates[`players.${playerId}.money`] || playerState.money || 0) + goPayout; // Add to already updated money
                            updates.ukGovMoney = (updates.ukGovMoney || currentGlobalGameData.ukGovMoney || 0) - goPayout;
                            updates[`players.${playerId}.govReceived`] = (updates[`players.${playerId}.govReceived`]  || playerState.govReceived || 0) + goPayout;
                            message += ` Passed Dole and collected an additional Â£${goPayout}.`;
                        }
                    } else {
                        message += `Could not find a Payout space.`;
                    }
                    updates[`players.${playerId}.playerActionTakenThisTurn`] = true;
                    break;
                case 'housingVoucher':
                    updates[`players.${playerId}.hasHousingVoucher`] = true;
                    message += `Received a housing voucher (25% off next estate).`;
                    break;
                case 'collectFromPlayers':
                    let totalCollectedFromOthers = 0;
                    Object.keys(currentGlobalGameData.players).forEach(otherPlayerId => {
                        if (otherPlayerId !== playerId && !currentGlobalGameData.players[otherPlayerId].isBankrupt) {
                            const otherPlayer = currentGlobalGameData.players[otherPlayerId];
                            const amountToPayByOther = Math.min(otherPlayer.money, (drawnCard.amount || 0));
                            updates[`players.${otherPlayerId}.money`] = otherPlayer.money - amountToPayByOther;
                            totalCollectedFromOthers += amountToPayByOther;
                        }
                    });
                    updates[`players.${playerId}.money`] = (playerState.money || 0) + totalCollectedFromOthers;
                    message += `Collected Â£${drawnCard.amount} from each other player (total: Â£${totalCollectedFromOthers}).`;
                    break;
                case 'advanceToGo':
                    updates[`players.${playerId}.position`] = 0;
                    const goPayoutAmount = drawnCard.amount || 400; // Use card amount or default
                    updates[`players.${playerId}.money`] = (playerState.money || 0) + goPayoutAmount;
                    updates[`players.${playerId}.govReceived`] = (playerState.govReceived || 0) + goPayoutAmount;
                    updates.ukGovMoney = (currentGlobalGameData.ukGovMoney || 0) - goPayoutAmount;
                    message += `Advanced to Dole and collected Â£${goPayoutAmount}.`;
                    updates[`players.${playerId}.playerActionTakenThisTurn`] = true;
                    break;

                default:
                    logEvent(`Unknown card action: ${drawnCard.action}`);
            }
            updates.lastActionMessage = message.trim();

            if (!updates.hasOwnProperty(`players.${playerId}.playerActionTakenThisTurn`)) {
                 updates[`players.${playerId}.playerActionTakenThisTurn`] = true;
            }


            try {
                await updateDoc(gameDocRef, updates);
                logEvent(`Card action ${drawnCard.action} applied and game state updated. Message: ${updates.lastActionMessage}`);
            } catch (error) {
                console.error("Error applying card action updates to Firestore:", error);
                showMessageModal("Card Action Error", "Could not apply card effect online: " + error.message);
            }
        }

        async function processRentPayment(landingPlayerId, propertyId) {
            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game not found for rent payment.");
                    const gameData = freshGameDoc.data();

                    const landingPlayer = gameData.players[landingPlayerId];
                    const propertyOnBoard = gameData.boardLayout.find(s => s.id === propertyId);
                    const propertyDataEntry = gameData.propertyData.find(p => p.id === propertyId);

                    if (!landingPlayer || landingPlayer.isBankrupt || !propertyOnBoard || !propertyDataEntry || !propertyDataEntry.owner || propertyDataEntry.owner === landingPlayerId) {
                        logEvent("Rent payment not applicable or owner is self/bankrupt.");
                        return;
                    }

                    const ownerPlayer = gameData.players[propertyDataEntry.owner];
                    if (!ownerPlayer || ownerPlayer.isBankrupt) {
                        logEvent("Owner is bankrupt or not found, no rent collected.");
                        return;
                    }

                    let rentAmount = 0;
                    if (propertyOnBoard.type === 'property') {
                        if (propertyDataEntry.permanentResidence) {
                            const rentTier = propertyOnBoard.rent.length -1; // Max rent for PR
                            rentAmount = propertyOnBoard.rent[rentTier] || 0;
                        } else if (propertyDataEntry.tenancies > 0) {
                            rentAmount = propertyOnBoard.rent[propertyDataEntry.tenancies] || 0; // Rent for specific number of tenancies
                        } else { // Unimproved
                            const groupPropertiesLayout = gameData.boardLayout.filter(s => s.groupId === propertyOnBoard.groupId && s.type === 'property');
                            const ownsAllInGroup = groupPropertiesLayout.every(gpLayout => {
                                const gpData = gameData.propertyData.find(pd => pd.id === gpLayout.id);
                                return gpData && gpData.owner === propertyDataEntry.owner;
                            });
                            rentAmount = propertyOnBoard.rent[0] || 0;
                            if (ownsAllInGroup) {
                                rentAmount *= 2;
                            }
                        }
                    } else if (propertyOnBoard.type === 'set_property') {
                        rentAmount = calculateSpecialSetRent(propertyOnBoard, ownerPlayer, gameData.propertyData, gameData.players);
                    }

                    if (rentAmount > 0) {
                        let updates = { updatedAt: serverTimestamp() };
                        const actualPayment = Math.min(landingPlayer.money, rentAmount);

                        updates[`players.${landingPlayerId}.money`] = landingPlayer.money - actualPayment;
                        updates[`players.${propertyDataEntry.owner}.money`] = ownerPlayer.money + actualPayment;
                        updates.lastActionMessage = `${landingPlayer.name} paid Â£${actualPayment} rent to ${ownerPlayer.name} for ${propertyOnBoard.name}.`;

                        if (landingPlayer.money < rentAmount && actualPayment < rentAmount) { // Check if couldn't afford full amount
                             updates[`players.${landingPlayerId}.isBankrupt`] = true; // Simplified bankruptcy
                             updates.lastActionMessage += ` ${landingPlayer.name} went bankrupt trying to pay rent!`;
                             // More complex bankruptcy (asset selling) would be needed for a full game
                        }
                        transaction.update(gameDocRef, updates);
                        logEvent(updates.lastActionMessage);
                    }
                });
            } catch (error) {
                console.error("Error processing rent payment:", error);
                showMessageModal("Rent Error", "Could not process rent: " + error.message);
            }
        }


    </script>
  </div>
</body>
</html>
