<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Migrantopoly - Online Multiplayer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            padding: 20px;
            color: #ecf0f1;
            position: relative;
            overflow-x: hidden;
            font-family: 'Inter', Arial, sans-serif;
            min-height: 100vh;
            background: #2c3e50;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .main-content {
          position: relative;
          z-index: 3; /* Ensures main content is above body::before and overlay */
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          min-height: 100vh;
          width: 100%;
          padding-top: 20px;
          padding-bottom: 20px;
          background-color: #2c3e50; 
        }

        #player-setup-screen, #online-setup-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #2c3e50;
            padding: 30px 40px;
            border-radius: 12px;
            border: 2px solid #7f8c8d;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
            color: #ecf0f1;
            text-align: center;
            width: auto;
            max-width: 450px; /* Adjusted for better layout with game list */
        }
        #online-setup-screen {
             max-width: 600px; /* Wider for game list */
        }

        #player-setup-screen h2, #online-setup-screen h2 {
            color: #1abc9c;
            margin-top: 0;
            margin-bottom: 25px;
            font-size: 1.8em;
        }
        .setup-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 18px;
        }
        #player-setup-screen label, #online-setup-screen label {
            font-size: 1em;
            margin-right: 15px;
            flex-basis: 40%;
            text-align: left;
        }
        #player-setup-screen select, #online-setup-screen select, #online-setup-screen input {
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size: 1em;
            flex-grow: 1;
        }
        #online-setup-screen input {
            width: calc(100% - 22px); /* Account for padding */
        }
        #player-setup-screen button, #online-setup-screen button {
            background-color: #27ae60;
            color: white;
            padding: 12px 25px;
            font-size: 1.1em;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 15px;
            margin-right: 10px;
        }
        #player-setup-screen button:last-child, #online-setup-screen button:last-child {
            margin-right: 0;
        }
        #player-setup-screen button:hover, #online-setup-screen button:hover {
            background-color: #2ecc71;
        }
         #online-setup-screen button.secondary {
            background-color: #3498db;
        }
        #online-setup-screen button.secondary:hover {
            background-color: #2980b9;
        }
        #player-setup-message, #online-setup-message {
            color: #f1c40f;
            font-size: 0.9em;
            margin-top: 15px;
            min-height: 1.2em;
        }
        #game-id-display {
            margin-top: 15px;
            font-size: 1.1em;
            color: #1abc9c;
        }
        #game-id-display span {
            font-weight: bold;
            background-color: #34495e;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
         #user-id-display {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.5);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            z-index: 1000;
        }
        #active-games-list-container {
            margin-top: 20px;
            width: 100%;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #7f8c8d;
            border-radius: 6px;
            padding: 10px;
            background-color: #34495e;
        }
        #active-games-list-container h4 {
            margin-top: 0;
            color: #1abc9c;
        }
        .game-list-item {
            background-color: #2c3e50;
            padding: 8px;
            margin-bottom: 8px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .game-list-item button {
            padding: 5px 10px;
            font-size: 0.8em;
            margin-left: 10px;
            background-color: #3498db;
        }
         .game-list-item button:hover {
            background-color: #2980b9;
        }


        #game-container, #game-info-area, #board-container {
            position: relative;
            z-index: 1;
        }

        #game-container {
            display: none; /* Initially hidden */
            flex-wrap: wrap;
            justify-content: center;
            gap: 25px;
            padding-top: 0px;
        }

        #board-container {
            display: grid;
            grid-template-columns: 100px repeat(8, 70px) 100px;
            grid-template-rows: 100px repeat(8, 70px) 100px;
            border: 3px solid #7f8c8d;
            width: 760px; /* Fixed width */
            height: 760px; /* Fixed height */
            position: relative;
            /* Updated background properties */
            background-image: url('migrant3.jpg'); /* Replace with your image path */
            background-size: cover; /* Or 'contain' or specific dimensions */
            background-position: center center;
            background-repeat: no-repeat;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            overflow: visible; /* Changed from hidden to visible if tokens were clipped */
            margin-top: 20px;
        }

        #card-decks-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 18px;
            z-index: 2; /* Ensure this is above the board background/overlay */
        }
      
        .card-deck { /* This style is now unused if decks are removed */
            width: 110px;
            height: 60px;
            background: linear-gradient(135deg, #f7ca18 60%, #f1c40f 100%);
            border: 2px solid #7f8c8d;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.18);
            display: none; /* Hide card decks */
            align-items: center;
            justify-content: center;
            font-size: 1.1em;
            font-weight: bold;
            color: #2c3e50;
            cursor: pointer;
            user-select: none;
            transition: transform 0.1s;
        }
        .card-deck.opportunity {
            background: linear-gradient(135deg, #6dd5ed 60%, #2193b0 100%);
            color: #fff;
        }
        .card-deck.welfare {
            background: linear-gradient(135deg, #f7ca18 60%, #f1c40f 100%);
            color: #2c3e50;
        }
        .card-deck:active {
            transform: scale(0.96);
        }

        #on-board-card-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 280px;
            min-height: 190px; /* Use min-height to allow content to expand */
            background-color: #fdf5e6;
            border: 3px solid #c0392b;
            border-radius: 15px;
            box-shadow: 0 6px 22px rgba(0,0,0,0.35);
            z-index: 50; /* Ensure it's above tokens and other board elements */
            display: none; /* Initially hidden */
            flex-direction: column;
            align-items: center;
            justify-content: space-around;
            padding: 15px;
            box-sizing: border-box;
            text-align: center;
            color: #2c3e50;
        }

        #on-board-card-display h4 {
            margin: 5px 0;
            font-size: 1.4em;
            color: #c0392b;
            font-weight: bold;
        }

        #on-board-card-display p {
            margin: 10px 0; /* Increased margin */
            font-size: 1em;
            line-height: 1.45;
            overflow-y: auto;
            max-height: 100px;
            width: 100%;
            color: #34495e;
        }
        #on-board-card-ok-button { /* Specific ID for this OK button */
            background-color: #27ae60;
            margin-top: 10px;
        }
        #on-board-card-ok-button:hover {
            background-color: #2ecc71;
        }


        .space {
            border: 1px solid #7f8c8d;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 10px;
            position: relative; /* Needed for z-index to work if using board overlay */
            z-index: 1; /* Ensure spaces are above board overlay */
            padding: 3px;
            box-sizing: border-box;
            background-color: #4a6378; /* Solid background for readability over board image */
            color: #ecf0f1;
            border-radius: 5px;
        }
        .space .name {
            font-weight: bold;
            font-size: 10px;
            margin-bottom: 2px;
            line-height: 1.2;
        }
        .space .price {
            font-size: 9px;
            color: #bdc3c7;
            font-weight: normal;
        }
        .space .owner-indicator {
            width: 90%;
            height: 6px;
            margin-top: 3px;
            background-color: transparent;
            border-radius: 3px;
            position: absolute;
            bottom: 3px;
            left: 5%;
        }
         .space .development-indicator {
            font-size: 12px;
            color: #fff;
            position: absolute;
            top: 15px;
            width: 100%;
            text-align: center;
            line-height: 1;
            text-shadow: 0 0 2px #000;
        }
        .space .sub-label {
            font-size: 10px;
            color: #e74c3c;
            font-weight: bold;
            margin-top: 2px;
            letter-spacing: 0.04em;
            text-align: center;
            line-height: 1.1;
        }

        .corner {
            font-weight: bold;
            background-color: #527a78;
        }
        .corner .name {
            font-size: 16px !important;
            color: #e74c3c !important;
            font-weight: bold !important;
            margin-top: 0;
        }
        .corner .name.detention-center-name {
            margin-top: 35px;
            position: relative;
            z-index: 1;
        }


        .property .color-bar {
            width: 100%;
            height: 12px;
            border-bottom: 1px solid #7f8c8d;
            position: absolute;
            top: 0;
            left: 0;
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
        }
        .space.property .name { margin-top: 14px; }

        .welfare .name, .opportunity .name {
            margin-top: 0;
            color: black !important; /* Changed to black */
            font-size: 11px !important; /* Slightly larger */
            font-weight: bold !important;
        }
        .tax .name, .payout .name, .neutral:not(.corner) .name {
            margin-top: 0;
        }
        
        .set-property {
            background-color: #303F4D;
        }
        .set-property .name {
            margin-top: 0;
            font-size: 11px;
            font-weight: bold;
        }


        .brown .color-bar { background-color: #8B4513; }
        .light-blue .color-bar { background-color: #ADD8E6; }
        .pink .color-bar { background-color: #FFC0CB; }
        .orange .color-bar { background-color: #FFA500; }
        .red .color-bar { background-color: #FF0000; }
        .green .color-bar { background-color: #008000; }


        .player-token {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            position: absolute;
            border: none;
            font-size: 26px;
            line-height: 28px;
            text-align: center;
            background: none;
            z-index: 10;
            user-select: none;
            pointer-events: none;
        }

        #game-info-area {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #player-info, #controls, #card-display-container, #game-status-message-container, #develop-property-container {
            padding: 15px;
            background-color: #34495e;
            border: 1px solid #7f8c8d;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            color: #ecf0f1;
        }
        #player-info div { margin-bottom: 8px; font-size: 14px; }
        /* #card-message is now #on-board-card-display p */

        button {
            padding: 10px 15px;
            font-size: 14px;
            cursor: pointer;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 6px;
            transition: background-color 0.2s;
            margin-top: 5px;
            margin-right: 5px;
        }
        button:last-child { margin-right: 0; }
        button:hover {
            background-color: #c0392b;
        }
        button:disabled {
            background-color: #7f8c8d;
            color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .main-action-button {
            display: block !important;
            margin: 8px auto !important;
        }

        #end-turn-button {
            background-color: #d35400;
        }
        #end-turn-button:hover {
            background-color: #e67e22;
        }
        #develop-property-button {
            background-color: #2980b9;
        }
        #develop-property-button:hover {
            background-color: #3498db;
        }

        /* card-display-container is no longer used, #on-board-card-display is used instead */
        #develop-property-container {
            display: none; /* Initially hidden */
        }
        #develop-property-container h3 {
             margin-top: 0; color: #1abc9c;
        }

        #detention-actions button {
            background-color: #f39c12;
            margin-right: 5px;
        }
        #detention-actions button:hover {
            background-color: #e67e22;
        }
        #game-status-message {
            font-weight: bold;
            color: #e74c3c;
            min-height: 20px;
        }
        #pre-game-roll-area button {
            background-color: #f1c40f;
            color: #2c3e50;
        }
        #pre-game-roll-area button:hover {
            background-color: #f39c12;
        }
        #pre-game-roll-results { margin-top: 10px; font-size: 13px; }
        #develop-property-options button {
            display: block;
            width: calc(100% - 10px);
            margin-bottom: 8px;
            background-color: #2980b9;
        }
        #develop-property-options button:hover {
            background-color: #3498db;
        }

        .space.dole-space .name {
            font-size: 26px !important;
            font-weight: bold;
            letter-spacing: 0.08em;
            color: red !important; /* Changed DOLE to red */
            text-transform: uppercase;
            position: absolute;
            top: 15px;
            left: 0;
            width: 100%;
            text-align: center;
            transform: rotate(-36deg);
            transform-origin: center center;
            white-space: nowrap;
            pointer-events: none;
        }
        .dole-sign {
            position: absolute;
            bottom: 8px;
            right: 8px;
            font-size: 28px;
            color: #f1c40f;
            font-weight: bold;
            z-index: 3;
        }

        .space.red-boardname .name {
            color: #e74c3c !important;
            font-weight: bold;
        }
        .space.yellow-boardname .name {
            color: #f1c40f !important;
            font-weight: bold;
        }


        .player-highlight {
            animation: player-highlight-flash 1s;
            background: #ffeaa7;
            color: #222d3a !important;
        }
        @keyframes player-highlight-flash {
            0% { background: #ffeaa7; }
            60% { background: #ffeaa7; }
            100% { background: transparent; }
        }

        #money-flash {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 7vw;
            font-family: 'Impact', 'Arial Black', Arial, sans-serif;
            color: #e74c3c; /* Red for loss, maybe green for gain later */
            font-weight: bold;
            opacity: 0;
            pointer-events: none;
            z-index: 1000;
            text-shadow: 2px 2px 16px #000, 0 0 32px #fff;
            transition: opacity 0.2s;
        }
        #money-flash.show {
            opacity: 1;
            animation: money-flash-pop 0.7s;
        }
        @keyframes money-flash-pop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.7); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            60% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.7); }
        }

        .detention-bars {
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            height: 32px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            z-index: 2;
        }
        .detention-bar {
            width: 4px;
            height: 100%;
            background: #111;
            border-radius: 2px;
            opacity: 0.85;
        }
        .detention-arrow {
            position: absolute;
            bottom: 6px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2em;
            color: #e67e22;
            font-weight: bold;
            z-index: 2;
            pointer-events: none;
            text-shadow: 1px 1px 6px #000, 0 0 8px #fff;
        }

        #current-turn-display {
            text-align: center;
            width: 100%;
            color: #ecf0f1;
            font-weight: bold;
            padding-bottom: 5px;
        }
        #current-turn-display.pulsing { /* New class for pulsing effect */
            font-size: 1.2em; /* Slightly larger font */
            animation: pulse-text-animation 1.5s infinite ease-in-out;
        }
        @keyframes pulse-text-animation { /* New animation for current turn text */
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        #game-status-message-container {
            text-align: center;
        }
        #uk-gov-status {
            padding: 12px;
            background: #222d3a;
            border: 1px solid #7f8c8d;
            border-radius: 8px;
            color: #f7ca18;
            font-weight: bold;
            text-align: center;
        }
         #uk-gov-status-container {
            width: 100%;
            box-sizing: border-box;
        }


        #pre-game-roll-area {
            display: none; /* Initially hidden */
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .overlay {
          position: fixed;
          top: 0; left: 0; right: 0; bottom: 0;
          background: rgba(24,28,36,0.48);
          z-index: 2; /* Ensure it's above body::before but below main content modals */
          pointer-events: none;
        }


        .die {
            width: 30px;
            height: 30px;
            border: 1px solid #ecf0f1;
            background-color: #fff;
            color: #2c3e50;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .dice-animation {
            animation: dice-roll-effect 0.4s ease-out;
        }
        @keyframes dice-roll-effect {
            0% { transform: scale(1) rotate(0deg); opacity: 0.5; }
            25% { transform: scale(1.3) rotate(90deg); opacity: 0.75; }
            50% { transform: scale(1.1) rotate(180deg); opacity: 1; }
            75% { transform: scale(1.3) rotate(270deg); opacity: 0.75; }
            100% { transform: scale(1) rotate(360deg); opacity: 1; }
        }

        .token-hop { /* General hop for landing, can be reused or a new one for steps */
            animation: hop-animation 0.3s ease-out;
        }
        @keyframes hop-animation {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            30% { transform: translateY(-35px) scale(1.25); opacity: 0.9; }
            60% { transform: translateY(-35px) scale(1.25); opacity: 0.9; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }

        .token-arrive-step { /* Short animation for each step */
            animation: arrive-step-animation 0.15s ease-out;
        }
        @keyframes arrive-step-animation {
            0% { transform: scale(0.8) translateY(2px); opacity: 0.7; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }

        #dice-display-master-container {
            min-height: 32px;
            text-align: center; /* Center the inline-flex child */
            margin-bottom: 8px;
        }
        #actual-dice-faces {
            display: inline-flex; /* Allows centering via text-align on parent */
            gap: 5px;
            /* margin-left: 5px; Removed as parent will center it */
            vertical-align: middle;
        }
        #dice-total-display-text {
            margin-left: 8px;
            font-weight: bold;
        }

        .token-flash {
            animation: token-flash-animation 0.7s infinite alternate;
        }
        @keyframes token-flash-animation {
            0% { opacity: 1; transform: scale(1.1); filter: drop-shadow(0 0 6px currentColor) drop-shadow(0 0 3px #fff); }
            100% { opacity: 0.6; transform: scale(1); filter: drop-shadow(0 0 3px currentColor); }
        }
        .token-move-flash {
            animation: token-move-flash-animation 0.2s infinite;
        }
        @keyframes token-move-flash-animation {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 1001; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background-color: #2c3e50;
            margin: auto;
            padding: 25px 35px;
            border: 1px solid #7f8c8d;
            border-radius: 10px;
            width: 80%;
            max-width: 450px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            text-align: center;
        }
        .modal-content h3 {
            color: #1abc9c;
            margin-top: 0;
        }
        .modal-content p {
            margin-bottom: 20px;
        }
        .modal-content button {
             background-color: #e74c3c;
        }
         .modal-content button:hover {
             background-color: #c0392b;
        }

</style>
</head>
<body>
  <div class="overlay"></div>
  <div id="user-id-display">Your User ID: <span id="local-user-id">Not Signed In</span></div>
  <div class="main-content">
    <div id="online-setup-screen"> <h2>Migrantopoly Online</h2>
        <div class="setup-row">
            <label for="player-name-input">Your Name:</label>
            <input type="text" id="player-name-input" placeholder="Enter your name" value="Player">
        </div>
        <div class="setup-row">
            <label for="game-id-input">Game ID (for joining):</label>
            <input type="text" id="game-id-input" placeholder="Enter Game ID to join">
        </div>
        <button id="join-game-button">Join Game</button>
        <button id="refresh-games-list-button" class="secondary" style="margin-left:10px;">Refresh Games</button>
        <hr style="width:80%; margin: 20px 0; border-color: #7f8c8d;">
        <div id="active-games-list-container" style="display:none;">
            <h4>Active Games:</h4>
            <div id="active-games-list">
                <p>No active games found or list not refreshed.</p>
            </div>
        </div>
        <hr style="width:80%; margin: 20px 0; border-color: #7f8c8d;">
        <div class="setup-row">
            <label for="num-players-online-select">Total Players in Game:</label>
            <select id="num-players-online-select">
                <option value="2" selected>2 Players</option>
                <option value="3">3 Players</option>
                <option value="4">4 Players</option>
            </select>
        </div>
        <button id="create-game-button">Create New Game</button>
        <p id="online-setup-message"></p>
        <div id="game-id-display" style="display:none;">
            Share this Game ID: <span id="generated-game-id" title="Click to copy"></span>
        </div>
    </div>

    <div id="player-setup-screen" style="display: none;"> <h2>Player Setup (Local)</h2>
        </div>

    <div id="game-container" style="display: none;">
        <div id="board-container">
            </div>

        <div id="game-info-area">
            <div id="player-info">
                </div>

            <div id="controls">
                <h3 id="current-turn-display">Current Turn: Player 1</h3>
                <div id="pre-game-roll-area" style="display:none;">
                    <h4>Determine Starting Player</h4>
                    <button id="pre-game-roll-button">Roll to Start</button>
                    <div id="pre-game-roll-results"></div>
                </div>

                <div id="dice-display-master-container">
                    <span>Dice: </span>
                    <div id="actual-dice-faces">
                        <div class="die" id="die-face-1">--</div>
                        <div class="die" id="die-face-2">--</div>
                    </div>
                    <span id="dice-total-display-text"></span>
                </div>
                <button id="roll-dice-button" style="display:none;">Roll Dice</button>
                <button id="end-turn-button" style="display:none;">End Turn</button>

                <div id="other-actions-container" style="text-align: center; margin-top: 5px;">
                    <button id="develop-property-button" style="display:none;">Develop Property</button>
                    <button id="buy-property-button" style="display:none;">Buy Property (£<span id="buy-property-price"></span>)</button>
                </div>
                <div id="detention-actions" style="margin-top: 10px;">
                    </div>
            </div>

            <div id="develop-property-container" style="display:none;">
                <h3 id="develop-property-name">Develop Property</h3>
                <div id="develop-property-options">
                    </div>
                <button id="close-develop-button">Close</button>
            </div>

            <div id="game-status-message-container">
                <h4>Game Status:</h4>
                <p id="game-status-message">Waiting for game to start...</p>
            </div>

            <div id="uk-gov-status-container">
                <div id="uk-gov-status">
                    UK Gov: £<span id="uk-gov-cash">20000</span>
                </div>
            </div>
        </div>
    </div>

    <div id="money-flash"></div>

    <div id="message-modal" class="modal">
        <div class="modal-content">
            <h3 id="modal-title">Notification</h3>
            <p id="modal-message">This is a sample message.</p>
            <button id="modal-ok-button">OK</button>
        </div>
    </div>

  </div>

    <script type="module">
        // --- Firebase Configuration ---
        const userProvidedFirebaseConfig = {
            // This is a placeholder, ensure it's replaced by the actual config or __firebase_config
            apiKey: "YOUR_API_KEY", // IMPORTANT: Replace with your actual API key
            authDomain: "YOUR_AUTH_DOMAIN",
            projectId: "YOUR_PROJECT_ID",
            storageBucket: "YOUR_STORAGE_BUCKET",
            messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
            appId: "YOUR_APP_ID",
            measurementId: "YOUR_MEASUREMENT_ID" 
        };
        // Use global config if available, otherwise fallback to userProvided (or your defaults)
        const firebaseConfigToUse = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : userProvidedFirebaseConfig;
        
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Firebase SDK imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, serverTimestamp, arrayUnion, arrayRemove, runTransaction, writeBatch, deleteDoc, getDocs, query, where } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        let db, auth, currentUserId = null, localPlayerName = '';
        let currentGameId = null; 
        let unsubscribeGameState = null; 
        let localGameData = {}; // Local cache of the game state
        let aiAddTimerId = null; 

        // --- DOM Elements ---
        const onlineSetupScreen = document.getElementById('online-setup-screen');
        const gameContainer = document.getElementById('game-container');
        const playerNameInput = document.getElementById('player-name-input');
        const gameIdInput = document.getElementById('game-id-input');
        const createGameButton = document.getElementById('create-game-button');
        const joinGameButton = document.getElementById('join-game-button');
        const numPlayersOnlineSelect = document.getElementById('num-players-online-select');
        const onlineSetupMessage = document.getElementById('online-setup-message');
        const gameIdDisplayDiv = document.getElementById('game-id-display');
        const generatedGameIdSpan = document.getElementById('generated-game-id');
        const localUserIdSpan = document.getElementById('local-user-id');
        const activeGamesListDiv = document.getElementById('active-games-list');
        const activeGamesListContainer = document.getElementById('active-games-list-container');
        const refreshGamesListButton = document.getElementById('refresh-games-list-button');


        const boardContainer = document.getElementById('board-container');
        const playerInfoDiv = document.getElementById('player-info');
        const rollDiceButton = document.getElementById('roll-dice-button');
        const endTurnButton = document.getElementById('end-turn-button');
        const buyPropertyButton = document.getElementById('buy-property-button');
        const buyPropertyPriceSpan = document.getElementById('buy-property-price');
        const developPropertyButton = document.getElementById('develop-property-button');
        const diceFace1Elem = document.getElementById('die-face-1');
        const diceFace2Elem = document.getElementById('die-face-2');
        const diceTotalDisplayText = document.getElementById('dice-total-display-text');
        const currentTurnDisplay = document.getElementById('current-turn-display');
        // cardDisplayContainer is no longer used from the side panel
        const detentionActionsDiv = document.getElementById('detention-actions');
        const gameStatusMessageP = document.getElementById('game-status-message');
        const preGameRollArea = document.getElementById('pre-game-roll-area');
        const preGameRollButton = document.getElementById('pre-game-roll-button');
        const preGameRollResultsDiv = document.getElementById('pre-game-roll-results');
        const developPropertyContainer = document.getElementById('develop-property-container');
        const developPropertyNameH3 = document.getElementById('develop-property-name');
        const developPropertyOptionsDiv = document.getElementById('develop-property-options');
        const closeDevelopButton = document.getElementById('close-develop-button');
        const otherActionsContainer = document.getElementById('other-actions-container');
        const ukGovCashSpan = document.getElementById('uk-gov-cash');
        
        // These will be assigned when the board is built in setupBoardFromFirestore
        let onBoardCardDisplayDiv, onBoardCardTypeH4, onBoardCardTextP, onBoardCardOkButton; 

        const messageModal = document.getElementById('message-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalOkButton = document.getElementById('modal-ok-button');
        const moneyFlashDiv = document.getElementById('money-flash');


        // --- Game Data Definitions ---
        let initialBoardLayout = [ 
            { id: 0, name: "Dole", type: "go" },
            { id: 1, name: "Tent in Field 1", type: "property", price: 60, rent: [4, 10, 20, 40, 80], color: "brown", groupId: "brown" },
            { id: 2, name: "Welfare", type: "welfare" }, 
            { id: 3, name: "Tent in Field 2", type: "property", price: 80, rent: [8, 10, 20, 40, 80], color: "brown", groupId: "brown" },
            { id: 4, name: "Black Market Sales", type: "set_property", price: 200, rent_base: 200, groupId: "special_set" }, // Rent for set_property needs separate logic if based on count
            { id: 5, name: "Fake PIP declined", type: "tax", amount: 100 },
            { id: 6, name: "Tesco Cardboard Skip 1", type: "property", price: 100, rent: [6, 15, 30, 60, 120], color: "light-blue", groupId: "lightblue" },
            { id: 7, name: "Tesco Cardboard Skip 2", type: "property", price: 120, rent: [8, 15, 30, 60, 120], color: "light-blue", groupId: "lightblue" },
            { id: 8, name: "Detention Center", type: "detention_visiting" },
            { id: 9, name: "Payout: Job Seeker's", type: "payout", amount: 100 },
            { id: 10, name: "Tesco Cardboard Skip 3", type: "property", price: 140, rent: [10, 15, 30, 60, 120], color: "light-blue", groupId: "lightblue" },
            { id: 11, name: "Council Highrise 1", type: "property", price: 160, rent: [12, 25, 50, 100, 200], color: "pink", groupId: "pink" },
            { id: 12, name: "Forced Marriage", type: "set_property", price: 200, rent_base: 200, groupId: "special_set" },
            { id: 13, name: "Welfare", type: "welfare" }, 
            { id: 14, name: "Council Highrise 2", type: "property", price: 180, rent: [14, 25, 50, 100, 200], color: "pink", groupId: "pink" },
            { id: 15, name: "Council Highrise 3", type: "property", price: 200, rent: [16, 25, 50, 100, 200], color: "pink", groupId: "pink" },
            { id: 16, name: "Crime Spree !!! Arrest", type: "crime_spree", amount: 150 }, 
            { id: 17, name: "Gypsy Estate 1", type: "property", price: 220, rent: [18, 35, 70, 140, 280], color: "orange", groupId: "orange" },
            { id: 18, name: "Opportunity", type: "opportunity" }, 
            { id: 19, name: "Gypsy Estate 2", type: "property", price: 240, rent: [20, 35, 70, 140, 280], color: "orange", groupId: "orange" },
            { id: 20, name: "Child Wives", type: "set_property", price: 200, rent_base: 200, groupId: "special_set" },
            { id: 21, name: "Fake ID Cards", type: "tax", amount: 100 },
            { id: 22, name: "Gypsy Estate 3", type: "property", price: 260, rent: [22, 35, 70, 140, 280], color: "orange", groupId: "orange" },
            { id: 23, name: "Holiday Inn 1", type: "property", price: 280, rent: [24, 45, 90, 180, 360], color: "red", groupId: "red" },
            { id: 24, name: "Go to Detention Center", type: "go_to_detention" }, 
            { id: 25, name: "Welfare", type: "welfare" }, 
            { id: 26, name: "Holiday Inn 2", type: "property", price: 300, rent: [26, 45, 90, 180, 360], color: "red", groupId: "red" },
            { id: 27, name: "Holiday Inn 3", type: "property", price: 320, rent: [28, 45, 90, 180, 360], color: "red", groupId: "red" },
            { id: 28, name: "I Dont speak English", type: "set_property", price: 200, rent_base: 200, groupId: "special_set" },
            { id: 29, name: "Luxury Flat 1", type: "property", price: 350, rent: [30, 60, 120, 240, 480], color: "green", groupId: "green" },
            { id: 30, name: "Opportunity", type: "opportunity" }, 
            { id: 31, name: "Luxury Flat 2", type: "property", price: 400, rent: [35, 60, 120, 240, 480], color: "green", groupId: "green" },
        ];
        let boardLayout = []; 
        let detentionCenterSpaceId;
        const TENANCY_COST = 50;
        const PR_COST = 150; // Permanent Residence cost
        const MAX_TENANCIES = 3; // Max tenancies before PR can be built

        const welfareCards = [
            { text: "Child Benefit: Collect £100.", action: "collect", amount: 100, deckType: "welfare" },
            { text: "Free Health Service: Gain a health service (worth £100).", action: "gainHealthService", deckType: "welfare" },
            { text: "Council House Grant: Collect £150.", action: "collect", amount: 150, deckType: "welfare" },
            { text: "Social Worker Fee: Pay £50.", action: "pay", amount: 50, deckType: "welfare" },
            { text: "Food Voucher: Collect £75.", action: "collect", amount: 75, deckType: "welfare" },
            { text: "Education Grant: Collect £120.", action: "collect", amount: 120, deckType: "welfare" },
            { text: "Housing Inspection: Pay £20 per tenancy owned.", action: "payPerTenancy", amountPer: 20, deckType: "welfare" },
            { text: "Utility Subsidy: Collect £80.", action: "collect", amount: 80, deckType: "welfare" },
            { text: "Legal Aid: Get out of Detention Center free.", action: "getOutOfDetentionFree", deckType: "welfare" },
            { text: "Emergency bowels: Collect £100.", action: "collect", amount: 100, deckType: "welfare" }, // Typo "bowels" kept as per original data
            { text: "Tax Audit: Pay £60.", action: "pay", amount: 60, deckType: "welfare" },
            { text: "Welfare Review: Move to nearest Payout Space.", action: "moveToNearestPayout", deckType: "welfare" }
        ];
        const opportunityCards = [
            { text: "Work Permit Granted: Collect £150.", action: "collect", amount: 150, deckType: "opportunity" },
            { text: "Language Subsidy: Collect £50.", action: "collect", amount: 50, deckType: "opportunity" },
            { text: "Community Grant: Collect £100.", action: "collect", amount: 100, deckType: "opportunity" },
            { text: "Deportation Threat: Go to Detention Center.", action: "goToDetentionDirect", deckType: "opportunity" },
            { text: "Legal Homosexuals: Get out of Detention Center free.", action: "getOutOfDetentionFree", deckType: "opportunity" }, // Content note: "Legal Homosexuals" is unusual phrasing.
            { text: "Job Offer: Collect £120.", action: "collect", amount: 120, deckType: "opportunity" },
            { text: "Housing Voucher: Next estate purchase is 25% off.", action: "housingVoucher", deckType: "opportunity" },
            { text: "Free Health Service: Gain a health service (worth £100).", action: "gainHealthService", deckType: "opportunity" },
            { text: "Bank Manager Shat His Load: Pay £50 to the bank.", action: "pay", amount: 50, deckType: "opportunity" }, // Content note: "Bank Manager Shat His Load" is highly inappropriate. Kept for data consistency but flagged.
            { text: "Tax Refund: Collect £75.", action: "collect", amount: 75, deckType: "opportunity" },
            { text: "Dogs Had An Abortion: Collect £40 from each player.", action: "collectFromPlayers", amount: 40, deckType: "opportunity" }, // Content note: "Dogs Had An Abortion" is highly inappropriate. Kept for data consistency but flagged.
            { text: "Advance to Dole: Collect £400.", action: "advanceToGo", deckType: "opportunity" } // Assuming Dole is GO and pays 400
        ];
        const playerEmojis = ['🐕‍🦺', '🐈', '🐘', '🐅', '🐒', '🦊']; 
        const playerColors = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6', '#1abc9c']; 

        let toneSynth;
        let audioContextStarted = false;
        // currentCardBeingExecuted is not strictly needed globally if drawnCard in Firestore is the source of truth

        // --- Utility Functions ---
        function logEvent(message, data = null) {
            if (data) {
                console.log(`[Game Log] ${new Date().toLocaleTimeString()}: ${message}`, data);
            } else {
                console.log(`[Game Log] ${new Date().toLocaleTimeString()}: ${message}`);
            }
        }

        function showMessageModal(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            messageModal.style.display = 'flex';
        }
        modalOkButton.onclick = () => {
            messageModal.style.display = 'none';
        };

        function generateGameId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function reformatBoardLayout() { 
            const newBoardLocations = [
                { name: "Boat Sank After Renting", type: "set_property", price: 100, rent_base: 100, groupId: "special_set" },
                { name: "People Trafficking", type: "set_property", price: 100, rent_base: 100, groupId: "special_set" },
                { name: "More than 15 children", type: "set_property", price: 100, rent_base: 100, groupId: "special_set" },
                { name: "Crypto Scam from Iqbhal", type: "set_property", price: 100, rent_base: 100, groupId: "special_set" }
            ];
            let tempBoard = [];
            tempBoard.push(initialBoardLayout.find(s => s.id === 0)); 
            const welfareCardOriginalSide1 = initialBoardLayout.find(s => s.id === 2);
            const boatSankProperty = newBoardLocations[0];
            tempBoard.push(initialBoardLayout.find(s => s.id === 1));
            tempBoard.push(boatSankProperty);
            tempBoard.push(initialBoardLayout.find(s => s.id === 3));
            tempBoard.push(initialBoardLayout.find(s => s.id === 4));
            tempBoard.push(welfareCardOriginalSide1);
            tempBoard.push(...initialBoardLayout.filter(s => s.id >= 5 && s.id <= 7));
            tempBoard.push(initialBoardLayout.find(s => s.id === 8)); 
            const peopleTraffickingProperty = newBoardLocations[1];
            const payoutJobSeekersOriginal = initialBoardLayout.find(s => s.id === 9);
            tempBoard.push(peopleTraffickingProperty);
            tempBoard.push(...initialBoardLayout.filter(s => s.id >= 10 && s.id <= 12));
            tempBoard.push(payoutJobSeekersOriginal);
            tempBoard.push(...initialBoardLayout.filter(s => s.id === 13 || (s.id >= 14 && s.id <= 15))); 
            tempBoard.push(initialBoardLayout.find(s => s.id === 16)); 
            const moreThan15ChildrenProperty = newBoardLocations[2];
            const opportunityCardSide3Original = initialBoardLayout.find(s => s.id === 18);
            tempBoard.push(initialBoardLayout.find(s => s.id === 17));
            tempBoard.push(moreThan15ChildrenProperty);
            tempBoard.push(initialBoardLayout.find(s => s.id === 19));
            tempBoard.push(initialBoardLayout.find(s => s.id === 20));
            tempBoard.push(opportunityCardSide3Original);
            tempBoard.push(...initialBoardLayout.filter(s => s.id >= 21 && s.id <= 23));
            tempBoard.push(initialBoardLayout.find(s => s.id === 24)); 
            const cryptoScamProperty = newBoardLocations[3];
            const opportunityCardSide4Original = initialBoardLayout.find(s => s.id === 30);
            tempBoard.push(...initialBoardLayout.filter(s => s.id === 25 || (s.id >= 26 && s.id <= 28))); 
            tempBoard.push(opportunityCardSide4Original);
            tempBoard.push(initialBoardLayout.find(s => s.id === 29));
            tempBoard.push(cryptoScamProperty);
            tempBoard.push(initialBoardLayout.find(s => s.id === 31));
            
            boardLayout = tempBoard.map((space, index) => ({ ...space, id: index })); 
            
            const dcSpace = boardLayout.find(s => s.name === "Detention Center");
            detentionCenterSpaceId = dcSpace ? dcSpace.id : (boardLayout.find(s => s.type === "detention_visiting")?.id || 8) ; 
        }


        // --- Firebase Setup ---
        async function initializeFirebase() {
            if (!firebaseConfigToUse || !firebaseConfigToUse.apiKey || firebaseConfigToUse.apiKey === "YOUR_API_KEY" || !firebaseConfigToUse.projectId) { 
                onlineSetupMessage.textContent = "Firebase configuration is missing or incomplete. Online features disabled.";
                console.error("Firebase config is not available or incomplete. Please update it in the script with your actual Firebase project details.");
                createGameButton.disabled = true;
                joinGameButton.disabled = true;
                showMessageModal("Setup Error", "Firebase is not configured. Please check the console for details. Online play is unavailable.");
                return;
            }
            try {
                const app = initializeApp(firebaseConfigToUse); 
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        localUserIdSpan.textContent = currentUserId;
                        logEvent(`Authenticated as: ${currentUserId}`);
                        onlineSetupMessage.textContent = "Connected. Ready to create or join a game.";
                        createGameButton.disabled = false;
                        joinGameButton.disabled = false;
                        // await displayActiveGames(); // Consider if this is needed on every auth change
                    } else {
                        currentUserId = null;
                        localUserIdSpan.textContent = "Not Signed In";
                        logEvent("User is signed out or initial authentication pending.");
                        
                        if (initialAuthToken) {
                            try {
                                await signInWithCustomToken(auth, initialAuthToken);
                                logEvent("Signed in with custom token.");
                            } catch (error) {
                                console.error("Custom token sign-in error:", error);
                                logEvent("Custom token sign-in failed, trying anonymous.");
                                await signInAnonymously(auth);
                            }
                        } else {
                            logEvent("No custom token, trying anonymous sign-in.");
                            await signInAnonymously(auth);
                        }
                    }
                });
            } catch (error) {
                console.error("Firebase initialization error:", error);
                onlineSetupMessage.textContent = "Error connecting to Firebase: " + error.message;
                showMessageModal("Firebase Error", "Could not initialize Firebase: " + error.message);
                createGameButton.disabled = true;
                joinGameButton.disabled = true;
            }
        }

        // --- Game Management Functions (Create, Join, Sync) ---
        async function handleCreateGame() {
            if (!currentUserId) {
                showMessageModal("Error", "You are not authenticated. Please wait or refresh.");
                return;
            }
            localPlayerName = playerNameInput.value.trim() || `Player ${currentUserId.substring(0,4)}`;
            if (!localPlayerName) {
                showMessageModal("Input Needed", "Please enter your player name.");
                return;
            }

            const newGameId = generateGameId();
            currentGameId = newGameId; 
            const numPlayers = parseInt(numPlayersOnlineSelect.value);

            const gameDocRef = doc(db, "games", newGameId);

            reformatBoardLayout(); 

            const initialPropertyDataForFirestore = boardLayout
                .filter(s => s.type === 'property' || s.type === 'set_property')
                .map(p => ({
                    id: p.id, 
                    name: p.name,
                    owner: null, 
                    tenancies: 0,
                    permanentResidence: false,
                    isMortgaged: false, // Added for mortgage feature
                }));


            const initialPlayerData = {
                id: currentUserId, 
                name: localPlayerName,
                money: 2000,
                position: 0,
                properties: [], 
                healthServices: 0,
                getOutOfDetentionCards: 0,
                inDetention: false,
                missedTurnsInDetention: 0,
                hasHousingVoucher: false,
                isBankrupt: false,
                playerActionTakenThisTurn: false, 
                doublesRolledInTurn: 0, 
                order: 0, 
                govReceived: 0,
                isAI: false 
            };

            const initialGameState = {
                gameId: newGameId,
                status: "waiting", 
                hostId: currentUserId,
                maxPlayers: numPlayers,
                players: { [currentUserId]: initialPlayerData }, 
                playerOrder: [currentUserId], 
                currentPlayerIndex: 0, 
                boardLayout: boardLayout, 
                propertyData: initialPropertyDataForFirestore, 
                bankMoney: 15000, // Starting bank money
                ukGovMoney: 20000, // Starting UK Gov money
                shuffledWelfareCards: shuffleDeck([...welfareCards]), 
                shuffledOpportunityCards: shuffleDeck([...opportunityCards]),
                welfareCardIndex: 0, 
                opportunityCardIndex: 0,
                lastDiceRoll: null, 
                lastActionMessage: `${localPlayerName} created the game. Waiting for players...`,
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp(),
                preGameRolls: {}, 
                preGamePlayersRolled: [], 
                preGamePhase: true, 
                gamePhase: "setup", 
                drawnCard: null 
            };
            
            if (Object.keys(initialGameState.players).length < numPlayers) {
                if (currentUserId === initialGameState.hostId) {
                    if (aiAddTimerId) clearTimeout(aiAddTimerId); 
                    logEvent(`Host starting 30s timer to add AI players if game not full.`);
                    aiAddTimerId = setTimeout(() => {
                        checkAndAddAIPlayers(newGameId, numPlayers);
                    }, 30000); 
                }
            } else {
                 initialGameState.status = "active"; 
                 initialGameState.lastActionMessage = `${localPlayerName} created the game. Starting pre-game rolls.`;
            }


            try {
                await setDoc(gameDocRef, initialGameState);
                logEvent(`Game ${newGameId} created by ${localPlayerName}.`);
                onlineSetupMessage.textContent = `Game created! ID: ${newGameId}. Waiting for players...`;
                generatedGameIdSpan.textContent = newGameId;
                gameIdDisplayDiv.style.display = 'block';
                subscribeToGameState(newGameId);
            } catch (error) {
                console.error("Error creating game:", error);
                showMessageModal("Error", "Could not create game: " + error.message);
                onlineSetupMessage.textContent = "Failed to create game. " + error.message;
            }
        }

        async function handleJoinGame() {
            if (!currentUserId) {
                showMessageModal("Error", "You are not authenticated. Please wait or refresh.");
                return;
            }
            localPlayerName = playerNameInput.value.trim() || `Player ${currentUserId.substring(0,4)}`;
            if (!localPlayerName) {
                showMessageModal("Input Needed", "Please enter your player name.");
                return;
            }

            const gameIdToJoin = gameIdInput.value.trim().toUpperCase();
            if (!gameIdToJoin) {
                showMessageModal("Input Needed", "Please enter a Game ID to join.");
                return;
            }

            const gameDocRef = doc(db, "games", gameIdToJoin);

            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameDocRef);
                    if (!gameDoc.exists()) {
                        throw new Error("Game not found.");
                    }

                    const gameData = gameDoc.data();
                    if (gameData.boardLayout && gameData.boardLayout.length > 0) {
                        boardLayout = gameData.boardLayout; // Adopt board layout from existing game
                        const dcSpace = boardLayout.find(s => s.name === "Detention Center");
                        detentionCenterSpaceId = dcSpace ? dcSpace.id : (boardLayout.find(s => s.type === "detention_visiting")?.id || 8);
                    } else {
                        reformatBoardLayout(); // Should ideally not happen if game was created correctly
                        logEvent("Warning: Joined game was missing boardLayout, reformatted locally.");
                    }


                    if (Object.keys(gameData.players).length >= gameData.maxPlayers) {
                        if (!gameData.players[currentUserId]) { 
                             throw new Error("Game is full.");
                        } else {
                            logEvent("Already part of this game. Rejoining/Resubscribing...");
                        }
                    }
                    
                    if (!gameData.players[currentUserId]) { 
                        const newPlayerOrderIndex = gameData.playerOrder.length; 
                        const newPlayerData = {
                            id: currentUserId, name: localPlayerName, money: 2000, position: 0, properties: [],
                            healthServices: 0, getOutOfDetentionCards: 0, inDetention: false, missedTurnsInDetention: 0,
                            hasHousingVoucher: false, isBankrupt: false, playerActionTakenThisTurn: false,
                            doublesRolledInTurn: 0, order: newPlayerOrderIndex, govReceived: 0, isAI: false
                        };

                        const updates = {};
                        updates[`players.${currentUserId}`] = newPlayerData;
                        updates.playerOrder = arrayUnion(currentUserId); 
                        updates.updatedAt = serverTimestamp();

                        const newPlayerCount = gameData.playerOrder.length + 1; 

                        if (newPlayerCount === gameData.maxPlayers) {
                            updates.preGamePhase = true; 
                            updates.status = "active";   
                            updates.lastActionMessage = `${localPlayerName} joined. All players present! Starting pre-game rolls.`;
                        } else {
                            updates.lastActionMessage = `${localPlayerName} joined the game. Waiting for ${gameData.maxPlayers - newPlayerCount} more.`;
                        }
                        transaction.update(gameDocRef, updates);
                        logEvent(`${localPlayerName} joining game ${gameIdToJoin}. Player order index: ${newPlayerOrderIndex}`);
                    }
                });

                currentGameId = gameIdToJoin;
                onlineSetupMessage.textContent = `Joined game ${gameIdToJoin}! Waiting for game to start...`;
                subscribeToGameState(gameIdToJoin);

            } catch (error) {
                console.error("Error joining game:", error);
                showMessageModal("Error", "Could not join game: " + error.message);
                onlineSetupMessage.textContent = "Failed to join game. " + error.message;
            }
        }

        async function checkAndAddAIPlayers(gameId, maxPlayersInGame) {
            if (aiAddTimerId) { 
                clearTimeout(aiAddTimerId);
                aiAddTimerId = null;
            }
            logEvent(`checkAndAddAIPlayers called for game ${gameId}. Max players: ${maxPlayersInGame}`);

            const gameDocRef = doc(db, "games", gameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameDocRef);
                    if (!gameDoc.exists()) {
                        logEvent("checkAndAddAIPlayers: Game document no longer exists.");
                        return;
                    }
                    const gameData = gameDoc.data();

                    if (gameData.status !== "waiting" || Object.keys(gameData.players).length >= maxPlayersInGame) {
                        logEvent("checkAndAddAIPlayers: Game is no longer waiting or is full. No AI needed.", { status: gameData.status, playerCount: Object.keys(gameData.players).length });
                        return;
                    }

                    const numHumanPlayers = Object.keys(gameData.players).length;
                    const numAIToAdd = maxPlayersInGame - numHumanPlayers;

                    if (numAIToAdd <= 0) {
                        logEvent("checkAndAddAIPlayers: No AI players needed.");
                        return;
                    }

                    logEvent(`checkAndAddAIPlayers: Adding ${numAIToAdd} AI player(s).`);
                    let updates = {};
                    let newPlayerOrder = [...gameData.playerOrder];
                    let newPlayersObject = {...gameData.players};
                    let aiPlayerNames = [];

                    for (let i = 0; i < numAIToAdd; i++) {
                        const aiPlayerId = `AI-${crypto.randomUUID().substring(0, 8)}`;
                        const aiPlayerName = `AI Bot ${i + 1}`;
                        aiPlayerNames.push(aiPlayerName);
                        const aiOrderIndex = newPlayerOrder.length; 
                        const aiPlayerData = {
                            id: aiPlayerId, name: aiPlayerName, money: 2000, position: 0, properties: [],
                            healthServices: 0, getOutOfDetentionCards: 0, inDetention: false, missedTurnsInDetention: 0,
                            hasHousingVoucher: false, isBankrupt: false, playerActionTakenThisTurn: false,
                            doublesRolledInTurn: 0, order: aiOrderIndex, govReceived: 0, isAI: true
                        };
                        newPlayersObject[aiPlayerId] = aiPlayerData;
                        newPlayerOrder.push(aiPlayerId);
                    }

                    updates.players = newPlayersObject;
                    updates.playerOrder = newPlayerOrder;
                    updates.preGamePhase = true; 
                    updates.status = "active";   
                    updates.lastActionMessage = `${aiPlayerNames.join(', ')} joined as AI. Starting pre-game rolls.`;
                    updates.updatedAt = serverTimestamp();
                    
                    transaction.update(gameDocRef, updates);
                    logEvent(`checkAndAddAIPlayers: Successfully added ${numAIToAdd} AI player(s).`);
                });
            } catch (error) {
                console.error("Error in checkAndAddAIPlayers transaction:", error);
                showMessageModal("AI Add Error", "Could not add AI players: " + error.message);
            }
        }


        function subscribeToGameState(gameId) {
            if (unsubscribeGameState) {
                unsubscribeGameState(); 
            }
            const gameDocRef = doc(db, "games", gameId);
            unsubscribeGameState = onSnapshot(gameDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const gameData = docSnap.data(); 
                    
                    if (currentUserId === gameData.hostId && aiAddTimerId) {
                        if (gameData.status !== "waiting" || Object.keys(gameData.players).length >= gameData.maxPlayers) {
                            logEvent("Game filled or started, clearing AI add timer.");
                            clearTimeout(aiAddTimerId);
                            aiAddTimerId = null;
                        }
                    }
                    
                    if (localGameData.players && gameData.players && currentUserId && 
                        localGameData.players[currentUserId] && gameData.players[currentUserId]) {
                        
                        const oldMoney = localGameData.players[currentUserId].money;
                        const newMoney = gameData.players[currentUserId].money;

                        if (typeof oldMoney !== 'undefined' && newMoney < oldMoney) {
                            const amountLost = oldMoney - newMoney;
                            if (amountLost > 0) { 
                                showMoneyChangeEffect(amountLost, 'loss');
                            }
                        } else if (typeof oldMoney !== 'undefined' && newMoney > oldMoney) {
                            const amountGained = newMoney - oldMoney;
                             if (amountGained > 0) { 
                                showMoneyChangeEffect(amountGained, 'gain');
                            }
                        }
                    }
                    
                    localGameData = gameData; 
                    logEvent("Game state updated from Firestore:", gameData.lastActionMessage || "No message", gameData.status);
                    
                    if (gameData.boardLayout && JSON.stringify(boardLayout) !== JSON.stringify(gameData.boardLayout)) {
                        logEvent("Board layout received from Firestore is different or not set, adopting it.");
                        boardLayout = gameData.boardLayout;
                        const dcSpace = boardLayout.find(s => s.name === "Detention Center");
                        detentionCenterSpaceId = dcSpace ? dcSpace.id : (boardLayout.find(s => s.type === "detention_visiting")?.id || 8);
                        if (boardContainer.innerHTML.trim() !== '') { 
                            logEvent("Board was already drawn, re-setting up from new Firestore layout.");
                            setupBoardFromFirestore(gameData); 
                        }
                    }
                    
                    updateLocalUIFromFirestore(gameData); 
                    
                    if (currentGameId && onlineSetupScreen.style.display !== 'none' && (gameData.status === "active" || gameData.status === "finished")) {
                         onlineSetupScreen.style.display = 'none';
                         gameContainer.style.display = 'flex';
                         logEvent("Switched to game container as game status is active/finished and setup screen was visible.");
                    }
                } else {
                    logEvent(`Game ${gameId} no longer exists or access denied.`);
                    showMessageModal("Game Ended", "The game session has ended or is no longer available.");
                    if (unsubscribeGameState) unsubscribeGameState();
                    resetToSetupScreen();
                }
            }, (error) => {
                console.error("Error listening to game state:", error);
                showMessageModal("Connection Error", "Lost connection to the game: " + error.message);
                if (unsubscribeGameState) unsubscribeGameState();
                resetToSetupScreen();
            });
        }
        
        function resetToSetupScreen() {
            onlineSetupScreen.style.display = 'flex';
            gameContainer.style.display = 'none';
            currentGameId = null;
            localGameData = {};
            if (unsubscribeGameState) {
                unsubscribeGameState();
                unsubscribeGameState = null;
            }
            if (aiAddTimerId) { 
                clearTimeout(aiAddTimerId);
                aiAddTimerId = null;
            }
            onlineSetupMessage.textContent = "Ready to create or join a new game.";
            gameIdDisplayDiv.style.display = 'none';
            generatedGameIdSpan.textContent = '';
            gameIdInput.value = '';
            boardLayout = []; 
            if(boardContainer) boardContainer.innerHTML = ''; 
            if(playerInfoDiv) playerInfoDiv.innerHTML = '';
            if(diceFace1Elem) diceFace1Elem.textContent = '--';
            if(diceFace2Elem) diceFace2Elem.textContent = '--';
            if(diceTotalDisplayText) diceTotalDisplayText.textContent = '';
            if(currentTurnDisplay) currentTurnDisplay.textContent = 'Current Turn: Player 1';
            if(gameStatusMessageP) gameStatusMessageP.textContent = 'Waiting for game to start...';
            if(onBoardCardDisplayDiv) onBoardCardDisplayDiv.style.display = 'none'; // Hide card display

        }

        async function finalizePreGameAsHost() {
            if (!currentGameId || !currentUserId || !db || !localGameData.hostId || localGameData.hostId !== currentUserId) {
                logEvent("finalizePreGameAsHost: Conditions not met.");
                return;
            }
            logEvent("Host attempting to finalize pre-game rolls.");

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) {
                        throw new Error("Game document not found during host finalization.");
                    }
                    const freshGameData = freshGameDoc.data();

                    if (!freshGameData.preGamePhase) {
                        logEvent("Host finalization: Pre-game phase already ended.");
                        return; 
                    }
                     if (freshGameData.hostId !== currentUserId) { 
                        logEvent("Host finalization check: Current user is NOT host in fresh data. Aborting.");
                        return;
                    }

                    const allPlayersInOrder = freshGameData.playerOrder || [];
                    const currentPreGameRolls = freshGameData.preGameRolls || {};
                    const allHaveRolled = allPlayersInOrder.length > 0 &&
                                        allPlayersInOrder.length === freshGameData.maxPlayers && 
                                        allPlayersInOrder.every(pid => currentPreGameRolls[pid] !== undefined);

                    if (!allHaveRolled) {
                        logEvent("Host finalization: Not all players have rolled or not all joined. Aborting.");
                        return; 
                    }
                    
                    logEvent("Host is proceeding with finalization of pre-game rolls.");
                    let updates = {};
                    const sortedPlayerIds = [...allPlayersInOrder].sort((a, b) => {
                        const rollA = currentPreGameRolls[a];
                        const rollB = currentPreGameRolls[b];
                        if (rollB === rollA) { 
                            return (freshGameData.players[a]?.order || 0) - (freshGameData.players[b]?.order || 0);
                        }
                        return rollB - rollA; 
                    });

                    updates.playerOrder = sortedPlayerIds; 
                    updates.currentPlayerIndex = 0;
                    updates.preGamePhase = false;
                    updates.gamePhase = "main";
                    updates.status = "active"; 
                    updates.lastActionMessage = `Starting order determined by host. ${freshGameData.players[sortedPlayerIds[0]].name} starts!`;
                    updates.updatedAt = serverTimestamp();
                    
                    transaction.update(gameDocRef, updates);
                    logEvent("Host successfully finalized pre-game starting order.");
                });
            } catch (error) {
                console.error("Error during host finalization of pre-game rolls:", error);
                showMessageModal("Host Finalization Error", "Could not finalize game start: " + error.message);
            }
        }

        // --- UI HELPER FUNCTION DEFINITIONS ---
        function updateDiceUIDisplay(gameData) {
            const diceDisplayContainer = document.getElementById('actual-dice-faces');
            if (!diceFace1Elem || !diceFace2Elem || !diceTotalDisplayText || !diceDisplayContainer) return;

            if (gameData.lastDiceRoll && gameData.gamePhase === "main" && !gameData.preGamePhase) {
                diceFace1Elem.textContent = gameData.lastDiceRoll.die1;
                diceFace2Elem.textContent = gameData.lastDiceRoll.die2;
                diceTotalDisplayText.textContent = ` = ${gameData.lastDiceRoll.total}`;
                
                diceDisplayContainer.classList.remove('dice-animation');
                void diceDisplayContainer.offsetWidth; 
                diceDisplayContainer.classList.add('dice-animation');
            } else { 
                diceFace1Elem.textContent = '--';
                diceFace2Elem.textContent = '--';
                diceTotalDisplayText.textContent = '';
                diceDisplayContainer.classList.remove('dice-animation');
            }
        }

        function updatePlayerInfoPanel(gameData) {
            if (!playerInfoDiv) return;
            playerInfoDiv.innerHTML = ''; 
            if (!gameData.playerOrder || !gameData.players) {
                logEvent("updatePlayerInfoPanel: Missing playerOrder or players data.");
                return;
            }

            gameData.playerOrder.forEach(playerId => {
                const p = gameData.players[playerId];
                if (!p || typeof p.id === 'undefined' || typeof p.order === 'undefined') { 
                    logEvent("updatePlayerInfoPanel: Invalid player data encountered for ID:", playerId, p);
                    return; 
                };

                const playerColor = playerColors[p.order % playerColors.length];
                const pDiv = document.createElement('div');
                if (p.isBankrupt) {
                    pDiv.innerHTML = `<b style="color:${playerColor};">${p.name}</b>: BANKRUPT`;
                    pDiv.style.textDecoration = 'line-through';
                    pDiv.style.opacity = '0.6';
                } else {
                    pDiv.innerHTML = `<b style="color:${playerColor};">${p.name}</b>: <span style='font-weight:bold;'>£${p.money}</span> | HS: ${p.healthServices} | LegalAids: ${p.getOutOfDetentionCards}`;
                    if (p.inDetention) pDiv.innerHTML += ` (In Detention - ${p.missedTurnsInDetention} missed)`;
                }
                if (!gameData.preGamePhase && gameData.status === "active" && gameData.playerOrder[gameData.currentPlayerIndex] === p.id && !p.isBankrupt) { 
                    pDiv.style.border = `2px solid ${playerColor}`;
                    pDiv.style.padding = "3px";
                    pDiv.style.borderRadius = "4px";
                    pDiv.classList.add('player-highlight'); 
                } else {
                    pDiv.classList.remove('player-highlight');
                }
                playerInfoDiv.appendChild(pDiv);
            });
        }
        
        function updateGameStatusPanel(gameData) {
            if (!gameStatusMessageP || !currentTurnDisplay || !gameData.players || !gameData.playerOrder) return;

            if (gameData.preGamePhase) {
                 const joined = Object.keys(gameData.players).length;
                 if (joined < gameData.maxPlayers) {
                    gameStatusMessageP.textContent = `Waiting for players... (${joined}/${gameData.maxPlayers} joined)`;
                 } else { 
                    const allRolled = gameData.playerOrder.every(pid => gameData.preGameRolls && gameData.preGameRolls[pid] !== undefined);
                    if (allRolled) {
                        gameStatusMessageP.textContent = "All players rolled. Host is determining start order...";
                    } else {
                        gameStatusMessageP.textContent = "Pre-game: Determine starting player by rolling.";
                    }
                 }
            } else if (gameData.status === "active" && gameData.gamePhase === "main") {
                gameStatusMessageP.textContent = gameData.lastActionMessage || "Game in progress...";
            } else if (gameData.status === "finished") {
                gameStatusMessageP.textContent = gameData.lastActionMessage || "Game Over!";
            } else { 
                 gameStatusMessageP.textContent = `Waiting for players... (${Object.keys(gameData.players).length}/${gameData.maxPlayers} joined)`;
            }

            const currentPlayerIdInOrder = gameData.playerOrder[gameData.currentPlayerIndex];
            const currentPlayerInOrder = gameData.players[currentPlayerIdInOrder];

            if (currentPlayerInOrder && gameData.status === "active") { 
                if (gameData.preGamePhase) {
                    let nextPlayerToRollForDisplayId = null;
                    for(const pid of gameData.playerOrder) { 
                        if(!gameData.preGameRolls || gameData.preGameRolls[pid] === undefined) {
                            nextPlayerToRollForDisplayId = pid;
                            break;
                        }
                    }
                    const playerToRoll = gameData.players[nextPlayerToRollForDisplayId];

                    if (playerToRoll && typeof playerToRoll.name !== 'undefined' && typeof playerToRoll.order !== 'undefined') {
                         currentTurnDisplay.textContent = `Pre-Game Roll: ${playerToRoll.name}`;
                         currentTurnDisplay.style.color = playerColors[playerToRoll.order % playerColors.length];
                         currentTurnDisplay.classList.remove('pulsing'); 
                    } else if (Object.keys(gameData.players).length === gameData.maxPlayers) { 
                        currentTurnDisplay.textContent = "Pre-Game Rolls Complete";
                        currentTurnDisplay.style.color = '#ecf0f1'; 
                        currentTurnDisplay.classList.remove('pulsing');
                    } else {
                        currentTurnDisplay.textContent = "Waiting for Players...";
                        currentTurnDisplay.style.color = '#ecf0f1';
                        currentTurnDisplay.classList.remove('pulsing');
                    }
                } else if (gameData.gamePhase === "main" && !currentPlayerInOrder.isBankrupt) { 
                    currentTurnDisplay.textContent = `Current Turn: ${currentPlayerInOrder.name}`;
                    currentTurnDisplay.style.color = playerColors[currentPlayerInOrder.order % playerColors.length];
                    currentTurnDisplay.classList.add('pulsing'); 
                } else if (gameData.gamePhase === "main" && currentPlayerInOrder.isBankrupt) {
                    currentTurnDisplay.textContent = `Skipping Bankrupt: ${currentPlayerInOrder.name}`;
                    currentTurnDisplay.style.color = '#7f8c8d'; 
                    currentTurnDisplay.classList.remove('pulsing');
                }
            } else if (gameData.status === "finished") {
                currentTurnDisplay.textContent = "Game Over!";
                currentTurnDisplay.style.color = '#e74c3c';
                currentTurnDisplay.classList.remove('pulsing');
            } else { 
                currentTurnDisplay.textContent = "Game Not Fully Started";
                currentTurnDisplay.style.color = '#ecf0f1';
                currentTurnDisplay.classList.remove('pulsing');
            }
        }

        function updateControlsBasedOnTurn(gameData) {
            if (!currentUserId || !gameData.players || !gameData.players[currentUserId]) {
                rollDiceButton.style.display = 'none';
                endTurnButton.style.display = 'none';
                buyPropertyButton.style.display = 'none';
                developPropertyButton.style.display = 'none';
                otherActionsContainer.style.display = 'none'; 
                detentionActionsDiv.innerHTML = ''; 
                return;
            }
            const amIBankrupt = gameData.players[currentUserId]?.isBankrupt;

            rollDiceButton.style.display = 'none';
            endTurnButton.style.display = 'none';
            buyPropertyButton.style.display = 'none';
            developPropertyButton.style.display = 'none';
            otherActionsContainer.style.display = 'none'; 
            detentionActionsDiv.innerHTML = ''; 

            // If a card is displayed, no other actions should be available until it's resolved.
            if (onBoardCardDisplayDiv && onBoardCardDisplayDiv.style.display === 'flex') {
                const playerToken = document.getElementById(`player-token-${currentUserId}`);
                if (playerToken) playerToken.classList.remove('token-flash');
                return; 
            }


            if (amIBankrupt || gameData.status === "finished" || gameData.preGamePhase) {
                const playerToken = document.getElementById(`player-token-${currentUserId}`);
                if (playerToken) playerToken.classList.remove('token-flash');
                return;
            }
            
            if (gameData.status !== "active" || gameData.gamePhase !== "main") return;

            const isMyTurn = gameData.playerOrder[gameData.currentPlayerIndex] === currentUserId;
            const myPlayerState = gameData.players[currentUserId]; 
            const amIInDetention = myPlayerState.inDetention;
            const myPlayerActionTakenThisTurn = myPlayerState.playerActionTakenThisTurn; 

            const playerToken = document.getElementById(`player-token-${currentUserId}`);
            if (isMyTurn) {
                // Flash token only if no modal/card is active
                if (playerToken && developPropertyContainer.style.display === 'none' && (!onBoardCardDisplayDiv || onBoardCardDisplayDiv.style.display === 'none')) {
                    playerToken.classList.add('token-flash');
                } else if (playerToken) {
                    playerToken.classList.remove('token-flash');
                }
            } else {
                 if (playerToken) playerToken.classList.remove('token-flash');
            }


            if (isMyTurn) {
                if (amIInDetention) {
                    setupDetentionActionsUI(myPlayerState, gameData); 
                    if (myPlayerActionTakenThisTurn) { 
                        endTurnButton.style.display = 'block';
                        endTurnButton.disabled = false; 
                        endTurnButton.classList.add('main-action-button');
                        detentionActionsDiv.innerHTML = ''; 
                    }
                } else { 
                    const rolledDoubles = gameData.lastDiceRoll?.isDoubles;
                    const doublesCount = myPlayerState.doublesRolledInTurn || 0;

                    if (!myPlayerActionTakenThisTurn || (rolledDoubles && doublesCount > 0 && doublesCount < 3) ) {
                        rollDiceButton.style.display = 'block';
                        rollDiceButton.disabled = false; 
                        rollDiceButton.classList.add('main-action-button');
                        if (rolledDoubles && doublesCount > 0 && doublesCount < 3 && gameStatusMessageP) {
                            gameStatusMessageP.textContent = `${myPlayerState.name} rolled doubles! Roll again.`;
                        }
                    }

                    let showOptionalActions = false;
                    if (gameData.lastDiceRoll || myPlayerActionTakenThisTurn) { 
                        showOptionalActions = true;
                    }


                    if (showOptionalActions) {
                        otherActionsContainer.style.display = 'block';
                        const currentSpace = gameData.boardLayout[myPlayerState.position];
                        const propData = Array.isArray(gameData.propertyData) ? gameData.propertyData.find(p => p.id === currentSpace?.id) : null;

                        if (currentSpace && propData && (currentSpace.type === 'property' || currentSpace.type === 'set_property') && propData.owner === null && !propData.isMortgaged) {
                            let price = currentSpace.price;
                            if (myPlayerState.hasHousingVoucher && currentSpace.type === 'property') {
                                price = Math.round(price * 0.75);
                            }
                            buyPropertyPriceSpan.textContent = price;
                            buyPropertyButton.style.display = (myPlayerState.money >= price) ? 'inline-block' : 'none';
                            if (buyPropertyButton.style.display === 'inline-block') buyPropertyButton.disabled = false;
                        } else {
                            buyPropertyButton.style.display = 'none';
                        }

                        developPropertyButton.style.display = canPlayerDevelopAnyProperty(myPlayerState, gameData) ? 'inline-block' : 'none';
                        if (developPropertyButton.style.display === 'inline-block') {
                            developPropertyButton.disabled = false; 
                        }

                        if (buyPropertyButton.style.display === 'none' && developPropertyButton.style.display === 'none') {
                            otherActionsContainer.style.display = 'none'; 
                        }
                    } else {
                         otherActionsContainer.style.display = 'none';
                    }
                    
                    if (myPlayerActionTakenThisTurn && !(rolledDoubles && doublesCount > 0 && doublesCount < 3) ) {
                        endTurnButton.style.display = 'block';
                        endTurnButton.disabled = false;
                        endTurnButton.classList.add('main-action-button');
                    }


                    const noMandatoryRollPending = !((myPlayerState.doublesRolledInTurn || 0) > 0 && (myPlayerState.doublesRolledInTurn || 0) < 3 && !myPlayerActionTakenThisTurn);
                    const noOptionalActionsAvailable = buyPropertyButton.style.display === 'none' && developPropertyButton.style.display === 'none';
                    const noCardActionPending = (!onBoardCardDisplayDiv || onBoardCardDisplayDiv.style.display === 'none');

                    if (myPlayerActionTakenThisTurn && noMandatoryRollPending && noOptionalActionsAvailable && noCardActionPending) {
                        logEvent("Auto-ending turn conditions met. Setting timeout.");
                        setTimeout(() => {
                            const freshLocalDataForAutoEnd = localGameData; 
                            if (freshLocalDataForAutoEnd && freshLocalDataForAutoEnd.players && freshLocalDataForAutoEnd.players[currentUserId]) {
                                const stillMyTurnNow = freshLocalDataForAutoEnd.playerOrder[freshLocalDataForAutoEnd.currentPlayerIndex] === currentUserId;
                                const playerStateNow = freshLocalDataForAutoEnd.players[currentUserId];
                                
                                const noRollPendingNow = !((playerStateNow.doublesRolledInTurn || 0) > 0 && (playerStateNow.doublesRolledInTurn || 0) < 3 && !playerStateNow.playerActionTakenThisTurn);
                                const noOptionsNow = document.getElementById('buy-property-button').style.display === 'none' &&
                                                     document.getElementById('develop-property-button').style.display === 'none';
                                const noCardNow = (!document.getElementById('on-board-card-display') || document.getElementById('on-board-card-display').style.display === 'none');

                                if (stillMyTurnNow && playerStateNow.playerActionTakenThisTurn && noRollPendingNow && noOptionsNow && noCardNow) {
                                    logEvent("Auto-end conditions still met in timeout. Calling handleEndTurnAction.");
                                    handleEndTurnAction();
                                } else {
                                    logEvent("Auto-end conditions changed during timeout or not my turn anymore. Not auto-ending.");
                                }
                            } else {
                                logEvent("Auto-end timeout: Could not get fresh player data. Not auto-ending.");
                            }
                        }, 1500); 
                    }
                }
            }
        }
        
        function updatePreGameRollUI(gameData) {
            if (!preGameRollArea || !preGameRollButton || !preGameRollResultsDiv || !gameData.players) { 
                logEvent("updatePreGameRollUI: Missing DOM elements or player data.");
                return;
            }

            if (!gameData.preGamePhase || gameData.status !== "active" || Object.keys(gameData.players).length < gameData.maxPlayers) { 
                preGameRollArea.style.display = 'none';
                preGameRollButton.style.display = 'none';
                return;
            }
            
            preGameRollArea.style.display = 'flex'; 
            preGameRollResultsDiv.innerHTML = ''; 
            preGameRollButton.style.display = 'none'; 

            let allPlayerIdsInOrder = gameData.playerOrder || []; 
            let preGameRollsData = gameData.preGameRolls || {};
            let numberOfPlayers = allPlayerIdsInOrder.length;
            
            let rolledPlayerCount = 0;
            allPlayerIdsInOrder.forEach(pid => {
                const playerName = gameData.players[pid]?.name || 'Unknown Player';
                const playerOrderForColor = gameData.players[pid]?.order; 
                const playerColor = (typeof playerOrderForColor !== 'undefined') ? playerColors[playerOrderForColor % playerColors.length] : '#ecf0f1';

                if (preGameRollsData[pid] !== undefined) {
                    preGameRollResultsDiv.innerHTML += `<span style="color:${playerColor};">${playerName}</span> rolled: ${preGameRollsData[pid]}<br>`;
                    rolledPlayerCount++;
                } else {
                    preGameRollResultsDiv.innerHTML += `<span style="color:${playerColor};">${playerName}</span> has not rolled yet.<br>`;
                }
            });
            
            if (rolledPlayerCount === numberOfPlayers && numberOfPlayers > 0 && numberOfPlayers === gameData.maxPlayers) {
                preGameRollResultsDiv.innerHTML += "All players rolled. Host is determining start order...";
            } else if (numberOfPlayers > 0 && numberOfPlayers === gameData.maxPlayers) { 
                let nextPlayerToRollId = null;
                const sortedByJoinOrder = [...allPlayerIdsInOrder].sort((a,b) => (gameData.players[a]?.order || 0) - (gameData.players[b]?.order || 0));

                for (const pid of sortedByJoinOrder) {
                    if (preGameRollsData[pid] === undefined) {
                        nextPlayerToRollId = pid;
                        break;
                    }
                }

                if (nextPlayerToRollId === currentUserId) {
                    preGameRollButton.style.display = 'block';
                    preGameRollButton.textContent = `Your turn, ${gameData.players[currentUserId]?.name || 'Player'}, Roll to Start`;
                    preGameRollButton.disabled = false;
                } else if (nextPlayerToRollId && gameData.players[nextPlayerToRollId]) {
                    preGameRollButton.style.display = 'block'; 
                    preGameRollButton.textContent = `Waiting for ${gameData.players[nextPlayerToRollId].name} to roll...`;
                    preGameRollButton.disabled = true;
                } else if (rolledPlayerCount < numberOfPlayers) { 
                    preGameRollButton.style.display = 'block';
                    preGameRollButton.textContent = `Waiting for players to roll...`;
                    preGameRollButton.disabled = true;
                }
            } else { 
                 preGameRollResultsDiv.innerHTML = "Waiting for all players to join before starting rolls...";
            }
        }

        function updateUkGovDisplay(govMoney) {
            if (ukGovCashSpan) {
                 ukGovCashSpan.textContent = govMoney !== undefined ? govMoney : (localGameData.ukGovMoney || 20000);
            }
        }

        function handleGameEndUI(gameData) {
            if (!gameStatusMessageP || !currentTurnDisplay || !rollDiceButton || !endTurnButton || !buyPropertyButton || !developPropertyButton || !preGameRollArea || !otherActionsContainer) return;
            
            gameStatusMessageP.textContent = gameData.lastActionMessage || "Game Over!";
            currentTurnDisplay.textContent = "Game Over!";
            currentTurnDisplay.style.color = '#e74c3c';

            rollDiceButton.style.display = 'none';
            endTurnButton.style.display = 'none';
            buyPropertyButton.style.display = 'none';
            developPropertyButton.style.display = 'none';
            preGameRollArea.style.display = 'none'; 
            detentionActionsDiv.innerHTML = ''; 
            if (onBoardCardDisplayDiv) onBoardCardDisplayDiv.style.display = 'none';


            otherActionsContainer.style.display = 'block'; 
            otherActionsContainer.innerHTML = '<button id="leave-game-button" style="background-color:#c0392b;">Back to Setup</button>';
            const leaveButton = document.getElementById('leave-game-button');
            if (leaveButton) {
                leaveButton.onclick = () => {
                    if (unsubscribeGameState) unsubscribeGameState();
                    resetToSetupScreen();
                };
            }
        }

        function setupBoardFromFirestore(gameData) {
            if (!boardContainer) {
                logEvent("Error: boardContainer DOM element not found in setupBoardFromFirestore.");
                return;
            }
            boardContainer.innerHTML = ''; 
            
            if (gameData.boardLayout && gameData.boardLayout.length > 0) {
                boardLayout = gameData.boardLayout;
            } else {
                logEvent("setupBoardFromFirestore: gameData.boardLayout is missing or empty. Cannot setup board.");
                return;
            }
            
            const dcSpace = boardLayout.find(s => s.name === "Detention Center");
            detentionCenterSpaceId = dcSpace ? dcSpace.id : (boardLayout.find(s => s.type === "detention_visiting")?.id || 8) ;

            const cardDecksCenter = document.createElement('div');
            cardDecksCenter.id = 'card-decks-center';
            boardContainer.appendChild(cardDecksCenter); 

            // Create and append the on-board card display div
            const onBoardCardDiv = document.createElement('div');
            onBoardCardDiv.id = 'on-board-card-display'; 
            onBoardCardDiv.style.display = 'none'; 
            onBoardCardDiv.innerHTML = `
                <h4 id="on-board-card-type">Card Type</h4>
                <p id="on-board-card-text">Card text will appear here.</p>
                <button id="on-board-card-ok-button">OK</button> 
            `;
            boardContainer.appendChild(onBoardCardDiv); // Append to board container
            
            // Assign to global vars after creation
            onBoardCardDisplayDiv = document.getElementById('on-board-card-display'); 
            onBoardCardTypeH4 = document.getElementById('on-board-card-type');
            onBoardCardTextP = document.getElementById('on-board-card-text');
            onBoardCardOkButton = document.getElementById('on-board-card-ok-button');

            if (onBoardCardOkButton) {
                onBoardCardOkButton.onclick = executeDrawnCardAction; // Link to the new card execution function
            }


            boardLayout.forEach((s) => {
                const spaceDiv = document.createElement('div');
                spaceDiv.id = `space-${s.id}`;
                spaceDiv.classList.add('space');
                if (s.type === 'go' || s.type === 'detention_visiting' || s.type === 'go_to_detention' || s.type === 'crime_spree') {
                    spaceDiv.classList.add('corner');
                }
                if (['Fake PIP declined', 'Fake ID Cards', "Payout: Job Seeker's"].includes(s.name)) {
                    spaceDiv.classList.add('yellow-boardname');
                }
                if (s.name === "Dole" && s.type === "go"){
                     spaceDiv.classList.add('dole-space');
                     const doleSign = document.createElement('div');
                     doleSign.classList.add('dole-sign');
                     doleSign.textContent = '$'; 
                     spaceDiv.appendChild(doleSign);
                }
                if (s.name === 'Detention Center') {
                    const bars = document.createElement('div'); bars.className = 'detention-bars';
                    for (let b = 0; b < 6; b++) { const bar = document.createElement('div'); bar.className = 'detention-bar'; bars.appendChild(bar); }
                    spaceDiv.appendChild(bars);
                }
                if (s.name === 'Go to Detention Center') {
                    const arrow = document.createElement('div'); arrow.className = 'detention-arrow'; arrow.textContent = '→'; spaceDiv.appendChild(arrow);
                    const subLabel = document.createElement('div'); subLabel.className = 'sub-label'; subLabel.textContent = 'DO NOT PASS GO'; spaceDiv.appendChild(subLabel);
                }
                if (s.type === 'property') {
                    spaceDiv.classList.add('property', s.color || s.groupId); 
                    const colorBar = document.createElement('div'); colorBar.classList.add('color-bar'); spaceDiv.appendChild(colorBar);
                } else if (s.type === 'set_property') {
                    spaceDiv.classList.add('set-property');
                } else if (s.type === 'welfare') {
                    spaceDiv.classList.add('welfare'); // Add class for styling
                } else if (s.type === 'opportunity') {
                    spaceDiv.classList.add('opportunity'); // Add class for styling
                }

                const nameDiv = document.createElement('div'); nameDiv.classList.add('name');
                if (s.name === 'Detention Center') nameDiv.classList.add('detention-center-name');
                nameDiv.textContent = s.name; spaceDiv.appendChild(nameDiv);

                if (s.type === 'property' && s.rent) { 
                    const devIndicator = document.createElement('div');
                    devIndicator.classList.add('development-indicator');
                    devIndicator.id = `dev-indicator-${s.id}`;
                    spaceDiv.appendChild(devIndicator);
                }
                if (s.price) {
                    const priceDiv = document.createElement('div'); priceDiv.classList.add('price');
                    priceDiv.textContent = `£${s.price}`; spaceDiv.appendChild(priceDiv);
                }
                if (s.type === 'property' || s.type === 'set_property') { 
                    const ownerIndicator = document.createElement('div');
                    ownerIndicator.classList.add('owner-indicator');
                    ownerIndicator.id = `owner-indicator-${s.id}`;
                    spaceDiv.appendChild(ownerIndicator);
                }
                
                const currentId = s.id; 
                if (currentId === 0) { spaceDiv.style.gridArea = `1 / 1`; } 
                else if (currentId >= 1 && currentId <= 8) { spaceDiv.style.gridArea = `1 / ${currentId + 1}`; } 
                else if (currentId === 9) { spaceDiv.style.gridArea = `1 / 10`; } 
                else if (currentId >= 10 && currentId <= 17) { spaceDiv.style.gridArea = `${(currentId - 9) + 1} / 10`; } 
                else if (currentId === 18) { spaceDiv.style.gridArea = `10 / 10`; } 
                else if (currentId >= 19 && currentId <= 26) { spaceDiv.style.gridArea = `10 / ${10 - (currentId - 18)}`; } 
                else if (currentId === 27) { spaceDiv.style.gridArea = `10 / 1`; } 
                else if (currentId >= 28 && currentId <= 31) { 
                     spaceDiv.style.gridArea = `${10 - (currentId - 27)} / 1`; 
                } else if (currentId >= 28 && currentId <= 35) { // Max board size check (adjust if board is larger)
                    spaceDiv.style.gridArea = `${10 - (currentId - 27)} / 1`; 
                }

                boardContainer.appendChild(spaceDiv);
            });

            if (gameData.players && gameData.playerOrder) {
                Object.values(gameData.players).forEach(player => {
                    if (player && typeof player.id !== 'undefined' && typeof player.order !== 'undefined') { 
                        let token = document.getElementById(`player-token-${player.id}`);
                        if (!token) { 
                            token = document.createElement('div');
                            token.id = `player-token-${player.id}`; 
                            token.classList.add('player-token');
                        }
                        token.textContent = playerEmojis[player.order % playerEmojis.length];
                        const playerTokenColor = playerColors[player.order % playerColors.length];
                        token.style.color = playerTokenColor;
                        token.style.filter = `drop-shadow(0 0 3px ${playerTokenColor})`;
                        
                        const spaceToPlace = document.getElementById(`space-${player.position}`);
                        if (spaceToPlace) {
                            spaceToPlace.appendChild(token);
                        } else {
                            logEvent(`Warning: Could not find space-${player.position} to place token for ${player.name}`);
                            const goSpace = document.getElementById('space-0'); 
                            if (goSpace) goSpace.appendChild(token);
                        }
                    } else {
                        logEvent("Warning: Invalid player data in setupBoardFromFirestore, skipping token creation/update.", player);
                    }
                });
            } else {
                logEvent("Warning: gameData.players or gameData.playerOrder is missing in setupBoardFromFirestore. Tokens not created.");
            }
            updateBoardDynamicElements(gameData); 
        }
        
        function updateBoardDynamicElements(gameData) {
            if (!gameData || !gameData.players || !gameData.boardLayout) {
                logEvent("updateBoardDynamicElements: Missing critical gameData. Skipping updates.");
                return;
            }

            Object.values(gameData.players).forEach(player => {
                if (!player || typeof player.id === 'undefined') { 
                    logEvent("updateBoardDynamicElements: Invalid player object in players list.", player);
                    return; 
                } 
                const token = document.getElementById(`player-token-${player.id}`);
                if (token) {
                    if (player.isBankrupt) {
                        token.style.display = 'none'; 
                    } else {
                        token.style.display = 'block';
                        const currentSpaceEl = document.getElementById(`space-${player.position}`);
                        if (currentSpaceEl) { 
                            if (token.parentNode !== currentSpaceEl) {
                                currentSpaceEl.appendChild(token); 
                            }
                        } else {
                            logEvent(`updateBoardDynamicElements: Could not find space-${player.position} for token ${player.id}`);
                        }
                    }
                } else {
                    // This might happen if board is redrawn before tokens are fully established
                    // logEvent(`updateBoardDynamicElements: Token not found for player ${player.id}. It should have been created.`);
                }
            });

            if (Array.isArray(gameData.propertyData)) {
                gameData.propertyData.forEach(propInPropertyData => {
                    if (!propInPropertyData || typeof propInPropertyData.id === 'undefined') {
                        logEvent("Warning: Invalid item in propertyData array during UI update, skipping this item.", propInPropertyData);
                        return; 
                    }

                    const ownerIndicator = document.getElementById(`owner-indicator-${propInPropertyData.id}`);
                    if (ownerIndicator) {
                        if (propInPropertyData.owner && gameData.players[propInPropertyData.owner] && !gameData.players[propInPropertyData.owner].isBankrupt) {
                            const ownerData = gameData.players[propInPropertyData.owner];
                            if (ownerData && typeof ownerData.order !== 'undefined') {
                                const ownerColor = playerColors[ownerData.order % playerColors.length];
                                ownerIndicator.style.backgroundColor = ownerColor;
                            } else {
                                 ownerIndicator.style.backgroundColor = 'transparent'; 
                            }
                        } else {
                            ownerIndicator.style.backgroundColor = 'transparent'; 
                        }
                    }

                    const boardSpaceDetails = gameData.boardLayout.find(s => s.id === propInPropertyData.id);
                    if (boardSpaceDetails && boardSpaceDetails.type === 'property') { 
                        const devIndicator = document.getElementById(`dev-indicator-${propInPropertyData.id}`);
                        if (devIndicator) {
                            if (propInPropertyData.permanentResidence) {
                                devIndicator.textContent = "🏢"; 
                            } else if (propInPropertyData.tenancies > 0) {
                                devIndicator.textContent = "🏠".repeat(propInPropertyData.tenancies); 
                            } else {
                                devIndicator.textContent = ""; 
                            }
                        }
                    }
                });
            } else {
                logEvent("updateBoardDynamicElements: gameData.propertyData is NOT an array. Property visual updates will be skipped.", gameData.propertyData);
            }
        }

        function showMoneyChangeEffect(amount, type = 'loss') {
            const moneyFlashDivLocal = document.getElementById('money-flash'); 
            if (!moneyFlashDivLocal) {
                logEvent("showMoneyChangeEffect: money-flash div not found.");
                return;
            }

            moneyFlashDivLocal.textContent = `${type === 'loss' ? '-' : '+'}£${Math.abs(amount)}`;
            moneyFlashDivLocal.style.color = type === 'loss' ? '#e74c3c' : '#2ecc71'; 

            moneyFlashDivLocal.classList.add('show'); 

            setTimeout(() => {
                moneyFlashDivLocal.classList.remove('show');
            }, 1000); 

            if (audioContextStarted && toneSynth) {
                try {
                    if (type === 'loss') {
                        toneSynth.triggerAttackRelease("A3", "16n", Tone.now());
                        toneSynth.triggerAttackRelease("F#3", "16n", Tone.now() + 0.07);
                    } else { 
                        toneSynth.triggerAttackRelease("C5", "16n", Tone.now());
                        toneSynth.triggerAttackRelease("E5", "16n", Tone.now() + 0.07);
                    }
                } catch (e) {
                    console.error("Money change sound error:", e);
                }
            }
        }


        // --- MAIN UI UPDATE FUNCTION (Calls helpers) ---
        function updateLocalUIFromFirestore(gameData) { 
            if (!currentUserId) {
                logEvent("UpdateLocalUI: currentUserId not set yet, deferring UI update.");
                if(gameStatusMessageP) gameStatusMessageP.textContent = "Authenticating..."; 
                return;
            }

            if (!gameData || Object.keys(gameData).length === 0) {
                logEvent("UpdateLocalUI: No game data received. Cannot update UI.");
                return;
            }
            
            if (gameData.preGamePhase && 
                gameData.status === "active" &&
                gameData.hostId === currentUserId && 
                gameData.playerOrder && gameData.playerOrder.length === gameData.maxPlayers && 
                gameData.preGameRolls &&
                gameData.playerOrder.every(pid => gameData.preGameRolls[pid] !== undefined) 
               ) {
                logEvent("Host detected conditions to finalize pre-game. Calling finalizePreGameAsHost.");
                finalizePreGameAsHost(); 
                return; 
            }

            if (gameData.boardLayout && gameData.boardLayout.length > 0) {
                const boardIsMissingOrDifferent = boardLayout.length === 0 || 
                                                (boardContainer && boardContainer.innerHTML.trim() === '') ||
                                                JSON.stringify(boardLayout) !== JSON.stringify(gameData.boardLayout);
                if (boardIsMissingOrDifferent) {
                    logEvent("UpdateLocalUI: Setting up/refreshing board from Firestore data.");
                    setupBoardFromFirestore(gameData); 
                } else {
                    updateBoardDynamicElements(gameData);
                }
            } else {
                logEvent("UpdateLocalUI: gameData.boardLayout is missing or empty. Board not set up/updated.");
            }

            // Card Display Logic - must happen BEFORE updateControlsBasedOnTurn
            if (onBoardCardDisplayDiv && onBoardCardTypeH4 && onBoardCardTextP && onBoardCardOkButton) {
                if (gameData.drawnCard && gameData.playerOrder[gameData.currentPlayerIndex] === currentUserId) {
                    onBoardCardTypeH4.textContent = gameData.drawnCard.deckType === 'welfare' ? "Welfare Card" : "Opportunity Card";
                    onBoardCardTextP.textContent = gameData.drawnCard.text;
                    onBoardCardDisplayDiv.style.display = 'flex';
                    onBoardCardOkButton.disabled = false; 
                } else if (onBoardCardDisplayDiv.style.display !== 'none' && !gameData.drawnCard) {
                    // This case handles when a card was displayed but is now null (e.g., after execution)
                    onBoardCardDisplayDiv.style.display = 'none';
                }
            }


            updateDiceUIDisplay(gameData); 
            updatePlayerInfoPanel(gameData); 
            updateGameStatusPanel(gameData);
            updateControlsBasedOnTurn(gameData); // This must be AFTER card display logic
            updateUkGovDisplay(gameData.ukGovMoney);

            if (gameData.preGamePhase && gameData.status === "active") { 
                updatePreGameRollUI(gameData);
            } else {
                if(preGameRollArea) preGameRollArea.style.display = 'none';
            }

            if (gameData.status === "finished") {
                handleGameEndUI(gameData);
            } 
        }
        
        // --- ACTION HANDLERS (Dice, Turn, Property, etc.) ---

        async function animatePlayerMove(playerId, startPos, steps, currentBoardLayout) {
            const token = document.getElementById(`player-token-${playerId}`);
            if (!token || !currentBoardLayout || currentBoardLayout.length === 0) return;

            let currentVisualPos = startPos;
            const stepDelay = 200; 

            for (let i = 0; i < steps; i++) {
                currentVisualPos = (currentVisualPos + 1) % currentBoardLayout.length;
                const nextSpaceEl = document.getElementById(`space-${currentVisualPos}`);
                
                if (nextSpaceEl) {
                    nextSpaceEl.appendChild(token); 
                    
                    token.classList.remove('token-arrive-step'); 
                    void token.offsetWidth; 
                    token.classList.add('token-arrive-step');
                }

                if (audioContextStarted && toneSynth) {
                    try {
                        toneSynth.triggerAttackRelease("A5", "32n", Tone.now() + (i * 0.02)); 
                    } catch (e) { 
                        console.error("Token move sound error:", e); 
                    }
                }
                await new Promise(resolve => setTimeout(resolve, stepDelay));
            }
        }

        // Helper function to check if a player owns all properties in a group
        function ownsAllInGroup(playerId, groupId, gameData) {
            if (!groupId || !gameData.boardLayout || !gameData.propertyData) return false;
            const groupPropertiesLayout = gameData.boardLayout.filter(s => s.groupId === groupId && s.type === 'property');
            if (groupPropertiesLayout.length === 0) return false; // No properties in this group to own

            return groupPropertiesLayout.every(propLayout => {
                const propData = gameData.propertyData.find(p => p.id === propLayout.id);
                return propData && propData.owner === playerId && !propData.isMortgaged; // Mortgaged properties might not count for monopoly rent
            });
        }

        // Rent Calculation Function
        function calculateRent(propertyId, ownerId, gameData) {
            const propertyLayout = gameData.boardLayout.find(s => s.id === propertyId);
            const propertyState = gameData.propertyData.find(p => p.id === propertyId);

            if (!propertyLayout || !propertyState || propertyState.owner !== ownerId) return 0; // Not a valid property or not owned by this player
            if (propertyState.isMortgaged) return 0; // No rent on mortgaged properties

            if (propertyLayout.type === 'property') {
                if (propertyState.permanentResidence) {
                    return propertyLayout.rent[4] || 0; // Rent for PR (hotel)
                }
                if (propertyState.tenancies > 0) {
                    return propertyLayout.rent[propertyState.tenancies] || 0; // Rent with tenancies
                }
                // Base rent (0 tenancies, no PR)
                let baseRent = propertyLayout.rent[0] || 0;
                if (ownsAllInGroup(ownerId, propertyLayout.groupId, gameData)) {
                    // Check if ALL properties in the group have 0 tenancies and no PR
                    const groupPropertiesData = gameData.propertyData.filter(pd => {
                        const layout = gameData.boardLayout.find(s => s.id === pd.id);
                        return layout && layout.groupId === propertyLayout.groupId && layout.type === 'property';
                    });
                    const allUndevelopedInMonopoly = groupPropertiesData.every(pd => pd.tenancies === 0 && !pd.permanentResidence);
                    
                    if(allUndevelopedInMonopoly){
                        return baseRent * 2; // Double rent for undeveloped monopoly
                    }
                }
                return baseRent;
            } else if (propertyLayout.type === 'set_property') {
                // Rent for "set_property" (e.g., utilities, stations in classic Monopoly)
                // This example assumes rent_base is fixed, but typically it scales with how many are owned.
                // For simplicity now, just return rent_base. A more complex version would count owned set_properties.
                const ownedSetProperties = gameData.propertyData.filter(p => {
                    const layout = gameData.boardLayout.find(s => s.id === p.id);
                    return layout && layout.groupId === propertyLayout.groupId && p.owner === ownerId && !p.isMortgaged;
                }).length;

                if (propertyLayout.groupId === "special_set") { // Example: Utilities
                     if (ownedSetProperties === 1) return 25 * (gameData.lastDiceRoll?.total || 4); // Placeholder for dice roll multiplier
                     if (ownedSetProperties === 2) return 50 * (gameData.lastDiceRoll?.total || 4);
                     if (ownedSetProperties === 3) return 100 * (gameData.lastDiceRoll?.total || 4);
                     if (ownedSetProperties === 4) return 200 * (gameData.lastDiceRoll?.total || 4);
                     return 0; // Or a default if not matching
                }
                return propertyLayout.rent_base || 0; // Fallback
            }
            return 0;
        }


        async function handleRollDiceAction() {
            if (!currentGameId || !localGameData || !localGameData.playerOrder || localGameData.playerOrder[localGameData.currentPlayerIndex] !== currentUserId) {
                showMessageModal("Not your turn", "It's not your turn to roll the dice.");
                return;
            }
             if (localGameData.preGamePhase) {
                showMessageModal("Game Phase Error", "Cannot roll main dice during pre-game roll phase. Use 'Roll to Start'.");
                return;
            }
            if (localGameData.gamePhase !== "main") {
                showMessageModal("Game Phase Error", "Cannot roll dice before the main game has started.");
                return;
            }
            if (!localGameData.players || !localGameData.players[currentUserId]) {
                 showMessageModal("Error", "Player data not found."); return;
            }
            
            const currentPlayerStateFromLocal = localGameData.players[currentUserId]; 
            if (currentPlayerStateFromLocal.playerActionTakenThisTurn && !(localGameData.lastDiceRoll?.isDoubles && currentPlayerStateFromLocal.doublesRolledInTurn < 3 && currentPlayerStateFromLocal.doublesRolledInTurn > 0)) {
                 showMessageModal("Action Taken", "You've already completed your roll action for this part of the turn.");
                return;
            }
             if (currentPlayerStateFromLocal.inDetention) {
                 showMessageModal("In Detention", "You are in detention. Use detention actions.");
                return;
            }

            if(rollDiceButton) rollDiceButton.disabled = true; 

            const die1 = Math.floor(Math.random() * 6) + 1;
            const die2 = Math.floor(Math.random() * 6) + 1;
            const totalRoll = die1 + die2;
            let isDoubles = die1 === die2; 

            if (audioContextStarted && toneSynth) {
                try {
                    toneSynth.triggerAttackRelease("C4", "16n", Tone.now());
                    setTimeout(() => { if (toneSynth) toneSynth.triggerAttackRelease("E4", "16n", Tone.now() + 0.1); }, 100);
                } catch (e) { console.error("Dice roll sound error:", e); }
            }
            
            const playerStartPosForAnim = localGameData.players[currentUserId].position;
            await animatePlayerMove(currentUserId, playerStartPosForAnim, totalRoll, localGameData.boardLayout);


            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game document not found during roll.");
                    const freshGameData = freshGameDoc.data();
                    
                    const playerState = freshGameData.players[currentUserId]; 
                    if (!playerState || playerState.isBankrupt) throw new Error("Player data missing or bankrupt in Firestore during roll.");
                    if (freshGameData.playerOrder[freshGameData.currentPlayerIndex] !== currentUserId) {
                        throw new Error("Not your turn (checked in transaction).");
                    }
                     if (playerState.inDetention) { 
                        throw new Error("Still in detention (checked in transaction).");
                    }

                    let newPosition = playerState.position; 
                    let messages = [];
                    let updates = {};
                    updates.lastDiceRoll = { die1, die2, total: totalRoll, isDoubles }; // Store dice roll first

                    let currentDoublesCount = playerState.doublesRolledInTurn || 0;
                    if (isDoubles) {
                        currentDoublesCount++;
                    } else {
                        currentDoublesCount = 0; 
                    }
                    updates[`players.${currentUserId}.doublesRolledInTurn`] = currentDoublesCount;
                    
                    if (isDoubles && currentDoublesCount === 3) {
                        messages.push(`${playerState.name} rolled 3 doubles! Sent to Detention.`);
                        newPosition = detentionCenterSpaceId; 
                        updates[`players.${currentUserId}.position`] = newPosition;
                        updates[`players.${currentUserId}.inDetention`] = true;
                        updates[`players.${currentUserId}.missedTurnsInDetention`] = 0; 
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = true; 
                        updates[`players.${currentUserId}.doublesRolledInTurn`] = 0; // Reset for next time in jail
                    } else {
                        newPosition = (playerState.position + totalRoll) % freshGameData.boardLayout.length;
                        updates[`players.${currentUserId}.position`] = newPosition;
                        const landedSpace = freshGameData.boardLayout[newPosition];
                        messages.push(`${playerState.name} rolled ${totalRoll} (${die1}, ${die2})${isDoubles ? " (Doubles!)" : ""}. Moved to ${landedSpace.name}.`);

                        let passedGo = false;
                        if (playerState.position + totalRoll >= freshGameData.boardLayout.length && !(isDoubles && currentDoublesCount ===3) && !playerState.inDetention ) {
                             passedGo = true;
                        }
                        if (passedGo) {
                            const goPayout = 400; 
                            updates[`players.${currentUserId}.money`] = (playerState.money || 0) + goPayout;
                            updates.ukGovMoney = (freshGameData.ukGovMoney || 0) - goPayout; 
                            updates[`players.${currentUserId}.govReceived`] = (playerState.govReceived || 0) + goPayout;
                            messages.push(`${playerState.name} passed Dole and collected £${goPayout}.`);
                        }
                        
                        // Handle landing on specific spaces (BEFORE card draw or rent)
                        if (landedSpace.type === 'payout' && landedSpace.amount) {
                            updates[`players.${currentUserId}.money`] = (updates[`players.${currentUserId}.money`] || playerState.money) + landedSpace.amount;
                            updates.ukGovMoney = (updates.ukGovMoney || freshGameData.ukGovMoney) - landedSpace.amount;
                            updates[`players.${currentUserId}.govReceived`] = (updates[`players.${currentUserId}.govReceived`] || playerState.govReceived || 0) + landedSpace.amount;
                            messages.push(`${playerState.name} collected £${landedSpace.amount} from ${landedSpace.name}.`);
                            updates[`players.${currentUserId}.playerActionTakenThisTurn`] = !isDoubles;
                        } else if (landedSpace.type === 'tax' && landedSpace.amount) {
                            updates[`players.${currentUserId}.money`] = (playerState.money || 0) - landedSpace.amount;
                            updates.bankMoney = (freshGameData.bankMoney || 0) + landedSpace.amount; 
                            messages.push(`${playerState.name} paid £${landedSpace.amount} for ${landedSpace.name}.`);
                            updates[`players.${currentUserId}.playerActionTakenThisTurn`] = !isDoubles;
                        } else if (landedSpace.type === 'crime_spree' && landedSpace.amount) {
                            updates[`players.${currentUserId}.money`] = (playerState.money || 0) - landedSpace.amount;
                            updates.bankMoney = (freshGameData.bankMoney || 0) + landedSpace.amount; 
                            messages.push(`${playerState.name} landed on Crime Spree and was fined £${landedSpace.amount}!`);
                            updates[`players.${currentUserId}.playerActionTakenThisTurn`] = !isDoubles;
                        } else if (landedSpace.type === 'go_to_detention') {
                            updates[`players.${currentUserId}.position`] = detentionCenterSpaceId;
                            updates[`players.${currentUserId}.inDetention`] = true;
                            updates[`players.${currentUserId}.missedTurnsInDetention`] = 0;
                            messages.push(`${playerState.name} was sent to Detention!`);
                            isDoubles = false; 
                            updates[`players.${currentUserId}.doublesRolledInTurn`] = 0;
                            updates[`players.${currentUserId}.playerActionTakenThisTurn`] = true; // Turn ends after going to jail
                        } else if (landedSpace.type === 'welfare' || landedSpace.type === 'opportunity') {
                            const deck = landedSpace.type === 'welfare' ? freshGameData.shuffledWelfareCards : freshGameData.shuffledOpportunityCards;
                            const deckIndex = landedSpace.type === 'welfare' ? freshGameData.welfareCardIndex : freshGameData.opportunityCardIndex;
                            const cardToDraw = deck[deckIndex];
                            
                            updates.drawnCard = { ...cardToDraw, deckType: landedSpace.type }; // Store the drawn card
                            if (landedSpace.type === 'welfare') {
                                updates.welfareCardIndex = (deckIndex + 1) % deck.length;
                            } else {
                                updates.opportunityCardIndex = (deckIndex + 1) % deck.length;
                            }
                            messages.push(`${playerState.name} landed on ${landedSpace.name} and drew a card.`);
                            updates[`players.${currentUserId}.playerActionTakenThisTurn`] = false; // Card action is pending
                        } else if (landedSpace.type === 'property' || landedSpace.type === 'set_property') {
                            const propData = freshGameData.propertyData.find(p => p.id === newPosition);
                            if (propData && propData.owner && propData.owner !== currentUserId && !freshGameData.players[propData.owner].isBankrupt) {
                                const rentAmount = calculateRent(newPosition, propData.owner, freshGameData); // Pass freshGameData
                                if (rentAmount > 0) {
                                    // Ensure player money doesn't go below zero from this update, if that's the rule
                                    const playerMoneyAfterRent = (updates[`players.${currentUserId}.money`] || playerState.money) - rentAmount;
                                    updates[`players.${currentUserId}.money`] = playerMoneyAfterRent; 
                                    updates[`players.${propData.owner}.money`] = (freshGameData.players[propData.owner].money || 0) + rentAmount;
                                    messages.push(`${playerState.name} paid £${rentAmount} rent for ${landedSpace.name} to ${freshGameData.players[propData.owner].name}.`);
                                    // Bankruptcy check would go here if playerMoneyAfterRent < 0
                                }
                            }
                            updates[`players.${currentUserId}.playerActionTakenThisTurn`] = !isDoubles; // Action taken unless buying/developing
                        } else {
                             // For other spaces like "Detention Visiting" or "GO" (if landed directly)
                            updates[`players.${currentUserId}.playerActionTakenThisTurn`] = !isDoubles;
                        }
                    }
                    
                    updates.lastActionMessage = messages.join(" ");
                    updates.updatedAt = serverTimestamp();
                    transaction.update(gameDocRef, updates);
                });
            } catch (error) {
                console.error("Error during roll dice action transaction:", error);
                showMessageModal("Roll Error", "Could not process roll transaction: " + error.message);
                if(rollDiceButton) rollDiceButton.disabled = false; // Re-enable on error
            }
        }
        
        async function handleEndTurnAction() {
            logEvent("handleEndTurnAction called."); 

            if (!currentGameId || !localGameData || !currentUserId || !db) {
                logEvent("EndTurn: Exiting - Missing critical global vars."); 
                showMessageModal("Error", "Game data or connection issue.");
                return;
            }

            const gameDataForCheck = localGameData; 
            const currentPlayerId = gameDataForCheck.playerOrder[gameDataForCheck.currentPlayerIndex]; 
            
            if (gameDataForCheck.players && gameDataForCheck.players[currentUserId]) {
                const pState = gameDataForCheck.players[currentUserId];
                logEvent(`EndTurn Initial Check: Player ${currentUserId} (current turn player: ${currentPlayerId})
                    playerActionTakenThisTurn: ${pState.playerActionTakenThisTurn}, 
                    inDetention: ${pState.inDetention},
                    doublesRolledInTurn: ${pState.doublesRolledInTurn},
                    lastDiceRoll.isDoubles: ${gameDataForCheck.lastDiceRoll?.isDoubles}`);
            } else {
                logEvent("EndTurn Initial Check: Player data for currentUserId not found in localGameData.");
            }


            if (currentPlayerId !== currentUserId) { 
                logEvent(`EndTurn: ERROR - It's not your turn! Expected: ${currentPlayerId}, You are: ${currentUserId}.`);
                showMessageModal("Error", "It's not your turn to end.");
                return;
            }

            const playerState = gameDataForCheck.players[currentUserId]; 
            if (!playerState || playerState.isBankrupt) {
                logEvent(`EndTurn: Exiting - Player state error or bankrupt.`);
                showMessageModal("Error", "Cannot end turn (player state error or bankrupt).");
                return;
            }
            
            // If a card is displayed, it must be actioned first.
            if (onBoardCardDisplayDiv && onBoardCardDisplayDiv.style.display === 'flex') {
                showMessageModal("Card Action Required", "Please resolve the drawn card first.");
                return;
            }

            if (gameDataForCheck.lastDiceRoll?.isDoubles && 
                (playerState.doublesRolledInTurn || 0) > 0 && 
                (playerState.doublesRolledInTurn || 0) < 3 && 
                !playerState.inDetention &&
                !playerState.playerActionTakenThisTurn) { 
                logEvent("EndTurn: Exiting - Player must roll again (doubles).");
                showMessageModal("Doubles!", "You rolled doubles, please roll again before ending your turn!");
                return;
            }
            if (!playerState.playerActionTakenThisTurn && !playerState.inDetention) { 
                logEvent("EndTurn: Exiting - Player has not taken their main action (e.g., rolled dice). playerActionTakenThisTurn is false.");
                showMessageModal("Action Required", "You must take an action (e.g., roll dice) before ending your turn.");
                return;
            }
            
            logEvent("EndTurn: Proceeding to transaction.");
            if(endTurnButton) endTurnButton.disabled = true;

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game not found for end turn.");
                    const freshGameData = freshGameDoc.data();

                    if (freshGameData.playerOrder[freshGameData.currentPlayerIndex] !== currentUserId) {
                        logEvent("EndTurn TXN: Turn already changed. Aborting.");
                        return; 
                    }
                    const freshPlayerState = freshGameData.players[currentUserId];
                     if (!freshPlayerState || freshPlayerState.isBankrupt) {
                        logEvent("EndTurn TXN: Player bankrupt/missing. Aborting.");
                        return; 
                    }
                    // Re-check card display with fresh data
                    if (freshGameData.drawnCard) {
                        logEvent("EndTurn TXN: Card still drawn in fresh data. Aborting end turn.");
                        return; // Player must resolve card
                    }

                    if (freshGameData.lastDiceRoll?.isDoubles && 
                        (freshPlayerState.doublesRolledInTurn || 0) > 0 && 
                        (freshPlayerState.doublesRolledInTurn || 0) < 3 &&
                        !freshPlayerState.inDetention &&
                        !freshPlayerState.playerActionTakenThisTurn) { 
                        logEvent("EndTurn TXN: Must roll again (doubles) based on fresh data. Aborting.");
                        return; 
                    }
                     if (!freshPlayerState.playerActionTakenThisTurn && !freshPlayerState.inDetention) {
                        logEvent("EndTurn TXN: Player action not taken in fresh data. Aborting. playerActionTakenThisTurn is false.");
                        return;
                    }


                    let updates = {};
                    updates[`players.${currentUserId}.playerActionTakenThisTurn`] = false; 
                    updates[`players.${currentUserId}.doublesRolledInTurn`] = 0;      

                    let nextPlayerIndex = (freshGameData.currentPlayerIndex + 1) % freshGameData.playerOrder.length;
                    let nextPlayerId = freshGameData.playerOrder[nextPlayerIndex];
                    let attempts = 0;
                    const maxAttempts = freshGameData.playerOrder.length;

                    while (freshGameData.players[nextPlayerId]?.isBankrupt && attempts < maxAttempts) {
                        nextPlayerIndex = (nextPlayerIndex + 1) % freshGameData.playerOrder.length;
                        nextPlayerId = freshGameData.playerOrder[nextPlayerIndex];
                        attempts++;
                    }

                    const nonBankruptPlayers = freshGameData.playerOrder.filter(pid => !freshGameData.players[pid]?.isBankrupt);

                    if (nonBankruptPlayers.length <= 1 && freshGameData.playerOrder.length > 1) { 
                         updates.status = "finished";
                         const winnerName = nonBankruptPlayers.length === 1 ? freshGameData.players[nonBankruptPlayers[0]].name : "No one";
                         updates.lastActionMessage = `Game Over! ${winnerName} is the winner!`;
                         logEvent(`Game ended. Winner: ${winnerName}`);
                    } else if (attempts >= maxAttempts && nonBankruptPlayers.length > 1) { 
                        logEvent("Error in turn progression: Loop completed but non-bankrupt players should exist.");
                        updates.status = "finished"; 
                        updates.lastActionMessage = "Error finding next player. Game Over.";
                    } else if (nonBankruptPlayers.length === 0 && freshGameData.playerOrder.length >=1){ 
                        updates.status = "finished";
                        updates.lastActionMessage = "All players are bankrupt! Game Over!";
                    }
                    else { 
                        updates.currentPlayerIndex = nextPlayerIndex;
                        updates.lastActionMessage = `${freshPlayerState.name} ended their turn. It's now ${freshGameData.players[nextPlayerId].name}'s turn.`;
                        updates.lastDiceRoll = null; 
                        updates.drawnCard = null; // Ensure no card carries over
                    }
                    
                    updates.updatedAt = serverTimestamp();
                    transaction.update(gameDocRef, updates);
                    logEvent(`EndTurn TXN: ${freshPlayerState.name} ended turn. Next is ${nextPlayerId || 'N/A'}.`);
                });
            } catch (error) {
                console.error("Error ending turn (transaction phase):", error);
                showMessageModal("End Turn Error", "Could not end turn: " + error.message);
            } finally {
                 if(endTurnButton) endTurnButton.disabled = false; // Re-enable, UI will hide if not needed
            }
        }

        async function handleBuyPropertyAction() {
            logEvent("BuyProp: Action initiated by user: " + currentUserId); 

            if (!currentGameId || !localGameData || !currentUserId || !db) {
                logEvent("BuyProp: Exiting - Missing critical global vars."); 
                showMessageModal("Error", "Game data or connection issue.");
                return;
            }

            const currentSnapshotGameData = localGameData; 
            const currentPlayerIdFromOrder = currentSnapshotGameData.playerOrder[currentSnapshotGameData.currentPlayerIndex];
            logEvent("BuyProp: Current turn player from order: " + currentPlayerIdFromOrder + ", current user: " + currentUserId); 

            if (currentPlayerIdFromOrder !== currentUserId) {
                logEvent(`BuyProp: Exiting - Not current player's turn. Expected: ${currentPlayerIdFromOrder}`); 
                showMessageModal("Error", "Not your turn to buy property.");
                return;
            }

            const playerState = currentSnapshotGameData.players[currentUserId];
            if (!playerState) {
                logEvent("BuyProp: Exiting - Player state not found for user: " + currentUserId); 
                showMessageModal("Error", "Player data not found.");
                return;
            }
            if (playerState.isBankrupt) {
                logEvent(`BuyProp: Exiting - Player ${currentUserId} is bankrupt.`); 
                showMessageModal("Error", "Cannot buy property (player is bankrupt).");
                return;
            }
            
            logEvent("BuyProp: Player state check passed.", { playerMoney: playerState.money, playerActionTaken: playerState.playerActionTakenThisTurn, lastDiceRoll: currentSnapshotGameData.lastDiceRoll }); 

            if (!currentSnapshotGameData.lastDiceRoll && !playerState.playerActionTakenThisTurn) {
                 logEvent("BuyProp: Exiting - Player has not rolled/landed yet in this turn segment."); 
                 showMessageModal("Action Required", "You must roll and land on a space before buying property.");
                 return;
            }

            const currentPosition = playerState.position;
            const spaceDetails = currentSnapshotGameData.boardLayout[currentPosition];
            logEvent("BuyProp: Attempting to buy space:", { position: currentPosition, spaceDetails }); 

            const propertyDataEntry = Array.isArray(currentSnapshotGameData.propertyData) ? 
                                      currentSnapshotGameData.propertyData.find(p => p.id === currentPosition) : null;

            if (!spaceDetails || !propertyDataEntry || (spaceDetails.type !== 'property' && spaceDetails.type !== 'set_property')) {
                logEvent(`BuyProp: Exiting - Not a buyable property.`); 
                showMessageModal("Invalid Space", "Not a buyable property space.");
                return;
            }

            if (propertyDataEntry.owner) {
                logEvent(`BuyProp: Exiting - Property already owned by ${propertyDataEntry.owner}`); 
                showMessageModal("Owned", `This property (${spaceDetails.name}) is already owned by ${currentSnapshotGameData.players[propertyDataEntry.owner]?.name || 'another player'}.`);
                return;
            }
             if (propertyDataEntry.isMortgaged) { // Should not happen if owner is null, but good check
                logEvent(`BuyProp: Exiting - Property is mortgaged (even if unowned).`);
                showMessageModal("Mortgaged", `This property (${spaceDetails.name}) is currently mortgaged and cannot be bought.`);
                return;
            }


            let price = spaceDetails.price;
            let usedVoucher = false;
            if (playerState.hasHousingVoucher && spaceDetails.type === 'property') { 
                price = Math.round(price * 0.75);
                usedVoucher = true;
                logEvent("BuyProp: Housing voucher applied. New price: " + price); 
            }

            if (playerState.money < price) {
                logEvent(`BuyProp: Exiting - Insufficient funds. Needs: ${price}, Has: ${playerState.money}`); 
                showMessageModal("Insufficient Funds", `You need £${price} to buy ${spaceDetails.name}, but you only have £${playerState.money}.`);
                return;
            }
            
            logEvent("BuyProp: All pre-transaction checks passed. Disabling button and starting transaction."); 
            if(buyPropertyButton) buyPropertyButton.disabled = true;

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    logEvent("BuyProp TXN: Inside transaction."); 
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) {
                        logEvent("BuyProp TXN: Game doc not found."); 
                        throw new Error("Game not found for buying property.");
                    }
                    const freshGameData = freshGameDoc.data();
                    logEvent("BuyProp TXN: Fetched fresh game data."); 

                    if (freshGameData.playerOrder[freshGameData.currentPlayerIndex] !== currentUserId) {
                        logEvent("BuyProp TXN: Not player's turn in fresh data."); 
                        throw new Error("Not your turn (checked in transaction).");
                    }
                    const freshPlayerState = freshGameData.players[currentUserId];
                    if (!freshPlayerState || freshPlayerState.isBankrupt) {
                        logEvent("BuyProp TXN: Player state error/bankrupt in fresh data."); 
                        throw new Error("Player error in transaction.");
                    }
                    
                    if (!freshGameData.lastDiceRoll && !freshPlayerState.playerActionTakenThisTurn) {
                         logEvent("BuyProp TXN: Player has not rolled/landed (fresh data)."); 
                         throw new Error("Player action not completed (checked in transaction).");
                    }

                    const freshCurrentPosition = freshPlayerState.position; 
                    const actualSpaceDetails = freshGameData.boardLayout[freshCurrentPosition];
                    logEvent("BuyProp TXN: Fresh player position: " + freshCurrentPosition); 
                    
                    if (!Array.isArray(freshGameData.propertyData)) { 
                        logEvent("BuyProp TXN: propertyData is not an array in fresh data."); 
                        throw new Error("Property data in Firestore is not an array. Cannot buy.");
                    }
                    const freshPropertyDataEntry = freshGameData.propertyData.find(p => p.id === freshCurrentPosition);

                    if (!actualSpaceDetails || !freshPropertyDataEntry || (actualSpaceDetails.type !== 'property' && actualSpaceDetails.type !== 'set_property')) {
                         logEvent("BuyProp TXN: Not a buyable space in fresh data."); 
                         throw new Error("Not a buyable property space (checked in transaction).");
                    }
                    if (freshPropertyDataEntry.owner) {
                        logEvent("BuyProp TXN: Property already owned in fresh data by " + freshPropertyDataEntry.owner); 
                        throw new Error(`Property (${actualSpaceDetails.name}) already owned by ${freshGameData.players[freshPropertyDataEntry.owner]?.name || 'another player'} (checked in transaction).`);
                    }
                    
                    let actualPrice = actualSpaceDetails.price;
                    let actualUsedVoucher = false;
                    if (freshPlayerState.hasHousingVoucher && actualSpaceDetails.type === 'property') {
                        actualPrice = Math.round(actualPrice * 0.75);
                        actualUsedVoucher = true;
                    }
                    if (freshPlayerState.money < actualPrice) {
                         logEvent("BuyProp TXN: Insufficient funds in fresh data."); 
                         throw new Error(`Insufficient funds (£${freshPlayerState.money} vs £${actualPrice}) for ${actualSpaceDetails.name} (checked in transaction).`);
                    }

                    let updates = {};
                    updates[`players.${currentUserId}.money`] = freshPlayerState.money - actualPrice;
                    updates[`players.${currentUserId}.properties`] = arrayUnion(freshCurrentPosition); 
                    if (actualUsedVoucher) {
                        updates[`players.${currentUserId}.hasHousingVoucher`] = false;
                    }
                    
                    const updatedPropertyData = freshGameData.propertyData.map(prop => {
                        if (prop.id === freshCurrentPosition) {
                            return { ...prop, owner: currentUserId };
                        }
                        return prop;
                    });
                    updates.propertyData = updatedPropertyData; 

                    updates.lastActionMessage = `${freshPlayerState.name} bought ${actualSpaceDetails.name} for £${actualPrice}${actualUsedVoucher ? " (with voucher)" : ""}.`;
                    updates.updatedAt = serverTimestamp();

                    if (!freshGameData.lastDiceRoll?.isDoubles) {
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = true;
                         logEvent("BuyProp TXN: Non-doubles roll, setting playerActionTakenThisTurn to true."); 
                    } else {
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = false; 
                        logEvent("BuyProp TXN: Doubles roll, playerActionTakenThisTurn explicitly set to false to ensure re-roll."); 
                    }


                    transaction.update(gameDocRef, updates);
                    logEvent("BuyProp TXN: Transaction update successful."); 

                    if (audioContextStarted && toneSynth) {
                        try {
                            toneSynth.triggerAttackRelease("A3", "16n", Tone.now()); 
                            toneSynth.triggerAttackRelease("F#3", "16n", Tone.now() + 0.07); 
                        } catch(e){ console.error("Buy property sound error:", e); }
                    }
                });
                logEvent("BuyProp: Transaction completed successfully."); 
            } catch (error) {
                console.error("Error buying property (transaction phase):", error); 
                showMessageModal("Buy Property Error", "Could not buy property: " + error.message);
            } finally {
                 logEvent("BuyProp: Action finished (successfully or with error)."); 
            }
        }

        async function handlePreGameRollAction() {
            if (!currentGameId || !localGameData || !localGameData.preGamePhase) {
                showMessageModal("Error", "Not in pre-game roll phase.");
                return;
            }
             if (Object.keys(localGameData.players).length < localGameData.maxPlayers) {
                showMessageModal("Waiting", "Waiting for all players to join before rolling.");
                return;
            }
            if (localGameData.preGameRolls && localGameData.preGameRolls[currentUserId] !== undefined) {
                showMessageModal("Already Rolled", "You have already rolled for starting position.");
                return;
            }

            let nextToRollInPreGame = null;
            const sortedByJoinOrderForPreGame = [...localGameData.playerOrder].sort((a,b) => (localGameData.players[a]?.order || 0) - (localGameData.players[b]?.order || 0));
            for (const pid of sortedByJoinOrderForPreGame) {
                if (!localGameData.preGameRolls || localGameData.preGameRolls[pid] === undefined) {
                    nextToRollInPreGame = pid;
                    break;
                }
            }
            if (nextToRollInPreGame !== currentUserId) {
                showMessageModal("Wait", "It's not your turn to roll for starting position.");
                return;
            }


            if(preGameRollButton) preGameRollButton.disabled = true;
            const roll = Math.floor(Math.random() * 6) + 1 + Math.floor(Math.random() * 6) + 1; 

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game not found for pre-game roll.");
                    const freshGameData = freshGameDoc.data();
                     if (!freshGameData.players || !freshGameData.players[currentUserId]) throw new Error("Player data missing in Firestore for pre-game roll.");
                     if (!freshGameData.preGamePhase) throw new Error("Pre-game phase ended."); 
                     if (freshGameData.preGameRolls && freshGameData.preGameRolls[currentUserId] !== undefined) {
                         throw new Error("Already rolled (checked in transaction).");
                     }

                    let updates = {};
                    updates[`preGameRolls.${currentUserId}`] = roll;
                    updates.lastActionMessage = `${freshGameData.players[currentUserId].name} rolled ${roll} for starting order.`;
                    updates.updatedAt = serverTimestamp();

                    const currentPreGameRollsWithThis = { ...(freshGameData.preGameRolls || {}), [currentUserId]: roll };
                    const allPlayersInOrder = freshGameData.playerOrder || [];
                    const allHaveRolled = allPlayersInOrder.length > 0 && 
                                          allPlayersInOrder.length === freshGameData.maxPlayers &&
                                          allPlayersInOrder.every(pid => currentPreGameRollsWithThis[pid] !== undefined);


                    if (allHaveRolled) { 
                        updates.lastActionMessage += " All players rolled.";
                        if (currentUserId === freshGameData.hostId) { 
                            logEvent("Host is the last to roll (or among the last) in pre-game, finalizing directly.");
                            const sortedPlayerIds = [...allPlayersInOrder].sort((a, b) => {
                                const rollA = currentPreGameRollsWithThis[a]; 
                                const rollB = currentPreGameRollsWithThis[b];
                                if (rollB === rollA) { 
                                    return (freshGameData.players[a]?.order || 0) - (freshGameData.players[b]?.order || 0);
                                }
                                return rollB - rollA; 
                            });
                            updates.playerOrder = sortedPlayerIds; 
                            updates.currentPlayerIndex = 0; 
                            updates.preGamePhase = false; 
                            updates.gamePhase = "main"; 
                            updates.status = "active";
                            updates.lastActionMessage = `Starting order determined. ${freshGameData.players[sortedPlayerIds[0]].name} starts!`;
                        } else {
                            updates.lastActionMessage += " Waiting for host to finalize starting order.";
                        }
                    }
                    transaction.update(gameDocRef, updates);
                });
            } catch (error) {
                console.error("Error during pre-game roll:", error);
                showMessageModal("Roll Error", "Could not process pre-game roll: " + error.message);
                if(preGameRollButton) preGameRollButton.disabled = false; 
            }
        }

        // --- Card Action Execution ---
        async function executeDrawnCardAction() {
            if (!currentGameId || !localGameData || !currentUserId || !db || !localGameData.drawnCard) {
                showMessageModal("Error", "Cannot execute card action: Missing data or card.");
                if(onBoardCardDisplayDiv) onBoardCardDisplayDiv.style.display = 'none'; // Hide if error
                return;
            }
            if (localGameData.playerOrder[localGameData.currentPlayerIndex] !== currentUserId) {
                showMessageModal("Error", "Not your turn to resolve a card.");
                return;
            }

            if(onBoardCardOkButton) onBoardCardOkButton.disabled = true; // Prevent double clicks

            const gameDocRef = doc(db, "games", currentGameId);
            const card = localGameData.drawnCard; // Use the card from localGameData that was displayed

            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game not found for card action.");
                    const freshGameData = freshGameDoc.data();

                    if (freshGameData.playerOrder[freshGameData.currentPlayerIndex] !== currentUserId) {
                        throw new Error("Not your turn (checked in card action transaction).");
                    }
                    if (!freshGameData.drawnCard || JSON.stringify(freshGameData.drawnCard) !== JSON.stringify(card)) {
                        // This means the card state changed or was cleared by another process, or this is a stale call
                        logEvent("Card state mismatch or card already cleared. Aborting card action.", { localCard: card, firestoreCard: freshGameData.drawnCard });
                        return; 
                    }

                    const playerState = freshGameData.players[currentUserId];
                    if (!playerState || playerState.isBankrupt) throw new Error("Player data missing or bankrupt for card action.");

                    let updates = {};
                    let cardMessages = [`${playerState.name} resolved: ${card.text}`];

                    switch (card.action) {
                        case "collect":
                            updates[`players.${currentUserId}.money`] = (playerState.money || 0) + card.amount;
                            updates.ukGovMoney = (freshGameData.ukGovMoney || 0) - card.amount;
                            updates[`players.${currentUserId}.govReceived`] = (playerState.govReceived || 0) + card.amount;
                            cardMessages.push(`Collected £${card.amount}.`);
                            break;
                        case "pay":
                            updates[`players.${currentUserId}.money`] = (playerState.money || 0) - card.amount;
                            updates.bankMoney = (freshGameData.bankMoney || 0) + card.amount;
                            cardMessages.push(`Paid £${card.amount}.`);
                            break;
                        case "gainHealthService":
                            updates[`players.${currentUserId}.healthServices`] = (playerState.healthServices || 0) + 1;
                            cardMessages.push(`Gained a Health Service.`);
                            break;
                        case "getOutOfDetentionFree":
                            updates[`players.${currentUserId}.getOutOfDetentionCards`] = (playerState.getOutOfDetentionCards || 0) + 1;
                            cardMessages.push(`Received a 'Get out of Detention Free' card.`);
                            break;
                        case "goToDetentionDirect":
                            updates[`players.${currentUserId}.position`] = detentionCenterSpaceId;
                            updates[`players.${currentUserId}.inDetention`] = true;
                            updates[`players.${currentUserId}.missedTurnsInDetention`] = 0;
                            updates[`players.${currentUserId}.doublesRolledInTurn`] = 0; // Reset doubles
                            cardMessages.push(`Sent to Detention Center.`);
                            break;
                        case "housingVoucher":
                            updates[`players.${currentUserId}.hasHousingVoucher`] = true;
                            cardMessages.push(`Received a Housing Voucher (25% off next estate).`);
                            break;
                        case "advanceToGo": // Assumes Dole is GO (space 0) and pays 400
                            const oldPosForGo = playerState.position;
                            updates[`players.${currentUserId}.position`] = 0;
                            if (oldPosForGo !== 0) { // Only pay if not already on GO
                                updates[`players.${currentUserId}.money`] = (playerState.money || 0) + 400;
                                updates.ukGovMoney = (freshGameData.ukGovMoney || 0) - 400;
                                updates[`players.${currentUserId}.govReceived`] = (playerState.govReceived || 0) + 400;
                                cardMessages.push(`Advanced to Dole and collected £400.`);
                            } else {
                                cardMessages.push(`Advanced to Dole.`);
                            }
                            break;
                        case "payPerTenancy":
                            let totalTenancies = 0;
                            if (playerState.properties && Array.isArray(playerState.properties)) {
                                playerState.properties.forEach(propId => {
                                    const propData = freshGameData.propertyData.find(p => p.id === propId);
                                    if (propData && propData.tenancies > 0 && !propData.permanentResidence) {
                                        totalTenancies += propData.tenancies;
                                    }
                                });
                            }
                            const paymentPerTenancy = totalTenancies * card.amountPer;
                            updates[`players.${currentUserId}.money`] = (playerState.money || 0) - paymentPerTenancy;
                            updates.bankMoney = (freshGameData.bankMoney || 0) + paymentPerTenancy;
                            cardMessages.push(`Paid £${paymentPerTenancy} for housing inspection (${totalTenancies} tenancies).`);
                            break;
                        case "moveToNearestPayout":
                            const { spaceId: nearestPayoutId, passedGo: passedGoForPayout, distance } = findNearestSpace(playerState.position, 'payout', freshGameData.boardLayout);
                            if (nearestPayoutId !== -1) {
                                updates[`players.${currentUserId}.position`] = nearestPayoutId;
                                const payoutSpaceDetails = freshGameData.boardLayout.find(s => s.id === nearestPayoutId);
                                let payoutAmount = payoutSpaceDetails.amount || 0;
                                
                                cardMessages.push(`Moved to ${payoutSpaceDetails.name}.`);
                                if (passedGoForPayout) {
                                    updates[`players.${currentUserId}.money`] = (playerState.money || 0) + 400; // GO money
                                    updates.ukGovMoney = (freshGameData.ukGovMoney || 0) - 400;
                                    updates[`players.${currentUserId}.govReceived`] = (playerState.govReceived || 0) + 400;
                                    cardMessages.push(`Passed Dole, collected £400.`);
                                }
                                // Collect from payout space itself
                                updates[`players.${currentUserId}.money`] = (updates[`players.${currentUserId}.money`] || playerState.money) + payoutAmount;
                                updates.ukGovMoney = (updates.ukGovMoney || freshGameData.ukGovMoney) - payoutAmount;
                                updates[`players.${currentUserId}.govReceived`] = (updates[`players.${currentUserId}.govReceived`] || playerState.govReceived || 0) + payoutAmount;
                                cardMessages.push(`Collected £${payoutAmount} from ${payoutSpaceDetails.name}.`);

                            } else {
                                cardMessages.push(`Could not find a Payout space.`);
                            }
                            break;
                        case "collectFromPlayers":
                            let totalCollectedFromPlayers = 0;
                            freshGameData.playerOrder.forEach(otherPlayerId => {
                                if (otherPlayerId !== currentUserId && freshGameData.players[otherPlayerId] && !freshGameData.players[otherPlayerId].isBankrupt) {
                                    const otherPlayer = freshGameData.players[otherPlayerId];
                                    const amountToCollect = Math.min(otherPlayer.money, card.amount); // Can't collect more than they have
                                    updates[`players.${otherPlayerId}.money`] = (otherPlayer.money || 0) - amountToCollect;
                                    totalCollectedFromPlayers += amountToCollect;
                                }
                            });
                            updates[`players.${currentUserId}.money`] = (playerState.money || 0) + totalCollectedFromPlayers;
                            cardMessages.push(`Collected a total of £${totalCollectedFromPlayers} from other players.`);
                            break;
                        default:
                            cardMessages.push(`Unknown card action: ${card.action}`);
                            break;
                    }

                    updates.drawnCard = null; // Clear the card
                    updates.lastActionMessage = cardMessages.join(" ");
                    
                    // Determine if turn should end. Generally, card actions complete the current action segment.
                    // If player rolled doubles before landing on card space, they don't get to roll again after card.
                    // Exception: "Go to Detention" always ends ability to use prior doubles.
                    if (card.action === "goToDetentionDirect") {
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = true; 
                    } else {
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = true; // Most cards mean action is taken
                    }
                    
                    updates.updatedAt = serverTimestamp();
                    transaction.update(gameDocRef, updates);
                });

            } catch (error) {
                console.error("Error executing card action:", error);
                showMessageModal("Card Error", "Could not execute card action: " + error.message);
            } finally {
                // UI update will happen via onSnapshot, which will hide the card and re-evaluate controls
                if(onBoardCardOkButton) onBoardCardOkButton.disabled = false; // Re-enable in case of error before transaction
            }
        }

        // Helper to find the nearest space of a certain type (advancing forward)
        function findNearestSpace(currentPosition, targetType, board) {
            let nearestSpaceId = -1;
            let minDistance = board.length;
            let passedGo = false;

            for (let i = 1; i < board.length; i++) { // Start checking from the next space
                const checkPos = (currentPosition + i) % board.length;
                if (board[checkPos].type === targetType) {
                    minDistance = i;
                    nearestSpaceId = checkPos;
                    passedGo = (currentPosition + i) >= board.length;
                    break; 
                }
            }
            return { spaceId: nearestSpaceId, passedGo: passedGo, distance: minDistance };
        }


        // --- Event Listeners ---
        createGameButton.onclick = handleCreateGame;
        joinGameButton.onclick = handleJoinGame;
        rollDiceButton.onclick = handleRollDiceAction; 
        preGameRollButton.onclick = handlePreGameRollAction;
        endTurnButton.onclick = handleEndTurnAction; 
        buyPropertyButton.onclick = handleBuyPropertyAction; 
        developPropertyButton.onclick = () => { 
            if (localGameData && currentUserId && localGameData.players && localGameData.players[currentUserId]) {
                showDevelopPropertyOptions(localGameData.players[currentUserId], localGameData);
            }
        };
        closeDevelopButton.onclick = () => {
            if(developPropertyContainer) developPropertyContainer.style.display = 'none';
        };
        
        generatedGameIdSpan.onclick = () => {
            if (generatedGameIdSpan.textContent) {
                const textArea = document.createElement("textarea");
                textArea.value = generatedGameIdSpan.textContent;
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy'); 
                    showMessageModal("Copied!", "Game ID copied to clipboard.");
                } catch (err) {
                    console.error('Fallback: Oops, unable to copy', err);
                    showMessageModal("Copy Failed", "Could not copy Game ID automatically. Please select and copy manually.");
                }
                document.body.removeChild(textArea);
            }
        };
        
        function shuffleDeck(deck) { 
            let newDeck = [...deck];
            for (let i = newDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
            }
            return newDeck;
        }

        function canPlayerDevelopAnyProperty(playerState, gameData) {
            if (!playerState || playerState.isBankrupt || !gameData || !Array.isArray(gameData.propertyData) || !gameData.boardLayout) return false;
            
            return playerState.properties.some(propId => {
                const propDetails = gameData.propertyData.find(p => p.id === propId);
                const propLayout = gameData.boardLayout.find(s => s.id === propId);

                if (!propDetails || !propLayout || propLayout.type !== 'property') return false; 
                if (propDetails.owner !== playerState.id || propDetails.permanentResidence || propDetails.isMortgaged) return false; 

                const groupPropertiesLayout = gameData.boardLayout.filter(s => s.groupId === propLayout.groupId && s.type === 'property');
                const ownsAllInGroup = groupPropertiesLayout.every(gpLayout => {
                    const gpDataForCheck = gameData.propertyData.find(pd => pd.id === gpLayout.id);
                    // Also ensure none of the group properties are mortgaged if that's a rule for development
                    return gpDataForCheck && gpDataForCheck.owner === playerState.id && !gpDataForCheck.isMortgaged; 
                });
                if (!ownsAllInGroup) return false;
                
                // Check if development is balanced (not strictly enforced here yet, but a common rule)
                // For now, just allow development if not maxed out
                return (propDetails.tenancies < MAX_TENANCIES) || (propDetails.tenancies === MAX_TENANCIES && !propDetails.permanentResidence);
            });
        }
        
        function setupDetentionActionsUI(playerState, gameData) {
            if (!playerState || !playerState.inDetention || !detentionActionsDiv) return;
            detentionActionsDiv.innerHTML = ''; 

            const canTakeAction = gameData.playerOrder[gameData.currentPlayerIndex] === currentUserId && !playerState.playerActionTakenThisTurn;

            if (playerState.getOutOfDetentionCards > 0) {
                const useCardBtn = document.createElement('button');
                useCardBtn.textContent = "Use Legal Aid Card";
                useCardBtn.disabled = !canTakeAction;
                useCardBtn.onclick = async () => { 
                    const gameDocRef = doc(db, "games", currentGameId);
                    try {
                        await updateDoc(gameDocRef, {
                            [`players.${currentUserId}.getOutOfDetentionCards`]: playerState.getOutOfDetentionCards - 1,
                            [`players.${currentUserId}.inDetention`]: false,
                            [`players.${currentUserId}.missedTurnsInDetention`]: 0,
                            [`players.${currentUserId}.playerActionTakenThisTurn`]: false, // Allows rolling to move
                            lastActionMessage: `${playerState.name} used a Legal Aid card and is free. Roll to move.`,
                            updatedAt: serverTimestamp()
                        });
                    } catch (e) { showMessageModal("Error", "Failed to use card: " + e.message); }
                };
                detentionActionsDiv.appendChild(useCardBtn);
            }

            const fineAmount = 50;
            if (playerState.money >= fineAmount) {
                const payFineBtn = document.createElement('button');
                payFineBtn.textContent = `Pay £${fineAmount} Fine`;
                payFineBtn.disabled = !canTakeAction;
                payFineBtn.onclick = async () => { 
                    const gameDocRef = doc(db, "games", currentGameId);
                     try {
                        await updateDoc(gameDocRef, {
                            [`players.${currentUserId}.money`]: playerState.money - fineAmount,
                            [`players.${currentUserId}.inDetention`]: false,
                            [`players.${currentUserId}.missedTurnsInDetention`]: 0,
                            [`players.${currentUserId}.playerActionTakenThisTurn`]: false, // Allows rolling to move
                            bankMoney: (gameData.bankMoney || 0) + fineAmount, 
                            lastActionMessage: `${playerState.name} paid £${fineAmount} fine and is free. Roll to move.`,
                            updatedAt: serverTimestamp()
                        });
                    } catch (e) { showMessageModal("Error", "Failed to pay fine: " + e.message); }
                };
                detentionActionsDiv.appendChild(payFineBtn);
            }

            const rollDoublesBtn = document.createElement('button');
            rollDoublesBtn.textContent = "Roll for Doubles (Exit Jail)";
            rollDoublesBtn.disabled = !canTakeAction;
            rollDoublesBtn.onclick = async () => { 
                const die1 = Math.floor(Math.random() * 6) + 1;
                const die2 = Math.floor(Math.random() * 6) + 1;
                const isDoubles = die1 === die2;
                const totalRoll = die1 + die2; 
                
                const gameDocRef = doc(db, "games", currentGameId);
                let updates = { updatedAt: serverTimestamp(), lastDiceRoll: {die1, die2, total: totalRoll, isDoubles: isDoubles} }; 
                let missedTurns = playerState.missedTurnsInDetention || 0;

                if (isDoubles) {
                    updates[`players.${currentUserId}.inDetention`] = false;
                    updates[`players.${currentUserId}.missedTurnsInDetention`] = 0;
                    updates[`players.${currentUserId}.playerActionTakenThisTurn`] = false; // Allows rolling to move
                    updates.lastActionMessage = `${playerState.name} rolled doubles (${die1},${die2}) and is out of Detention! Roll again to move.`;
                } else {
                    missedTurns++;
                    updates[`players.${currentUserId}.missedTurnsInDetention`] = missedTurns;
                    updates[`players.${currentUserId}.playerActionTakenThisTurn`] = true; // Turn ends if failed roll
                    if (missedTurns >= 3) {
                        updates[`players.${currentUserId}.inDetention`] = false; 
                        updates[`players.${currentUserId}.missedTurnsInDetention`] = 0;
                        updates[`players.${currentUserId}.money`] = (playerState.money || 0) - fineAmount; 
                        updates.bankMoney = (gameData.bankMoney || 0) + fineAmount;
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = false; // Allows rolling next turn
                        updates.lastActionMessage = `${playerState.name} failed to roll doubles for 3 turns, paid £${fineAmount} fine and is out. Roll to move on next turn.`;
                    } else {
                        updates.lastActionMessage = `${playerState.name} failed to roll doubles (${die1},${die2}) in detention. Still in detention. ${3 - missedTurns} attempt(s) left.`;
                    }
                }
                 try {
                    await updateDoc(gameDocRef, updates);
                } catch (e) { showMessageModal("Error", "Failed to roll for doubles in detention: " + e.message); }
            };
            detentionActionsDiv.appendChild(rollDoublesBtn);
        }

        function showDevelopPropertyOptions(playerState, gameData) {
            if (!developPropertyContainer || !developPropertyOptionsDiv || !developPropertyNameH3) return;

            developPropertyOptionsDiv.innerHTML = ''; 
            developPropertyNameH3.textContent = "Develop Property"; 

            let canDevelopAnything = false;

            playerState.properties.forEach(propId => {
                const propLayout = gameData.boardLayout.find(s => s.id === propId);
                const propData = gameData.propertyData.find(p => p.id === propId);

                if (propLayout && propData && propLayout.type === 'property' && propData.owner === playerState.id && !propData.isMortgaged) {
                    const groupPropertiesLayout = gameData.boardLayout.filter(s => s.groupId === propLayout.groupId && s.type === 'property');
                    const ownsAllInGroup = groupPropertiesLayout.every(gpLayout => {
                        const gpDataForCheck = gameData.propertyData.find(pd => pd.id === gpLayout.id);
                        return gpDataForCheck && gpDataForCheck.owner === playerState.id && !gpDataForCheck.isMortgaged;
                    });

                    if (ownsAllInGroup) {
                        // Add logic for balanced building if desired (e.g., must build evenly across group)
                        if (!propData.permanentResidence && propData.tenancies < MAX_TENANCIES) {
                            const addTenancyButton = document.createElement('button');
                            addTenancyButton.textContent = `Add Tenancy to ${propLayout.name} (£${TENANCY_COST})`;
                            addTenancyButton.disabled = playerState.money < TENANCY_COST;
                            addTenancyButton.onclick = () => handleConfirmDevelopment(propId, 'tenancy');
                            developPropertyOptionsDiv.appendChild(addTenancyButton);
                            canDevelopAnything = true;
                        }
                        if (!propData.permanentResidence && propData.tenancies === MAX_TENANCIES) {
                            const buildPRButton = document.createElement('button');
                            buildPRButton.textContent = `Build PR on ${propLayout.name} (£${PR_COST})`;
                            buildPRButton.disabled = playerState.money < PR_COST;
                            buildPRButton.onclick = () => handleConfirmDevelopment(propId, 'pr');
                            developPropertyOptionsDiv.appendChild(buildPRButton);
                            canDevelopAnything = true;
                        }
                    }
                }
            });

            if (!canDevelopAnything) {
                developPropertyOptionsDiv.innerHTML = '<p>No properties currently eligible for development (must own all in group, unmortgaged, and have funds).</p>';
            }
            developPropertyContainer.style.display = 'block';
        }

        async function handleConfirmDevelopment(propertyId, developmentType) {
            logEvent(`handleConfirmDevelopment called for prop: ${propertyId}, type: ${developmentType}`);
            if (!currentGameId || !localGameData || !currentUserId || !db) {
                showMessageModal("Error", "Game data or connection issue.");
                return;
            }

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game not found for development.");
                    
                    const freshGameData = freshGameDoc.data();
                    const playerState = freshGameData.players[currentUserId];
                    const propLayout = freshGameData.boardLayout.find(s => s.id === propertyId);
                    const propDataIndex = freshGameData.propertyData.findIndex(p => p.id === propertyId);

                    if (propDataIndex === -1 || !propLayout || !playerState) {
                        throw new Error("Property or player data not found for development.");
                    }
                    const propData = freshGameData.propertyData[propDataIndex];

                    if (freshGameData.playerOrder[freshGameData.currentPlayerIndex] !== currentUserId) {
                        throw new Error("Not your turn to develop.");
                    }
                    if (propData.owner !== currentUserId) {
                        throw new Error("You do not own this property.");
                    }
                    if (propLayout.type !== 'property') {
                        throw new Error("This type of property cannot be developed.");
                    }
                     if (propData.isMortgaged) {
                        throw new Error("Cannot develop a mortgaged property.");
                    }


                    const groupPropertiesLayout = freshGameData.boardLayout.filter(s => s.groupId === propLayout.groupId && s.type === 'property');
                    const ownsAllInGroupAndUnmortgaged = groupPropertiesLayout.every(gpLayout => {
                        const gpDataForCheck = freshGameData.propertyData.find(pd => pd.id === gpLayout.id);
                        return gpDataForCheck && gpDataForCheck.owner === currentUserId && !gpDataForCheck.isMortgaged;
                    });
                    if (!ownsAllInGroupAndUnmortgaged) {
                        throw new Error(`You must own all unmortgaged properties in the ${propLayout.color || propLayout.groupId} group to develop.`);
                    }

                    let cost = 0;
                    let newTenancies = propData.tenancies;
                    let newPR = propData.permanentResidence;
                    let developmentMessage = "";

                    if (developmentType === 'tenancy') {
                        if (propData.permanentResidence) throw new Error("Cannot add tenancies to a property with Permanent Residence.");
                        if (propData.tenancies >= MAX_TENANCIES) throw new Error("Maximum tenancies reached.");
                        // Add balanced building check: ensure this property doesn't have more tenancies than others in the group by more than 1
                        // This is a common Monopoly rule, but complex to add here quickly. For now, allow.
                        cost = TENANCY_COST;
                        newTenancies++;
                        developmentMessage = `added a tenancy to ${propLayout.name}`;
                    } else if (developmentType === 'pr') {
                        if (propData.permanentResidence) throw new Error("Permanent Residence already built.");
                        if (propData.tenancies < MAX_TENANCIES) throw new Error(`Must have ${MAX_TENANCIES} tenancies to build PR.`);
                         // Ensure all other properties in the group also have MAX_TENANCIES
                        const allOthersMaxedTenancies = groupPropertiesLayout.every(gpLayout => {
                            if (gpLayout.id === propertyId) return true; // Skip self
                            const otherPropData = freshGameData.propertyData.find(pd => pd.id === gpLayout.id);
                            return otherPropData && otherPropData.tenancies === MAX_TENANCIES && !otherPropData.permanentResidence;
                        });
                        if (!allOthersMaxedTenancies) {
                            throw new Error("All properties in the group must have maximum tenancies before building a Permanent Residence on any of them.");
                        }
                        cost = PR_COST;
                        newPR = true;
                        developmentMessage = `built Permanent Residence on ${propLayout.name}`;
                    } else {
                        throw new Error("Invalid development type.");
                    }

                    if (playerState.money < cost) {
                        throw new Error(`Insufficient funds. Need £${cost}.`);
                    }

                    const updates = {};
                    updates[`players.${currentUserId}.money`] = playerState.money - cost;
                    
                    const updatedPropertyDataArray = freshGameData.propertyData.map((p, index) => {
                        if (index === propDataIndex) {
                            return { ...p, tenancies: newTenancies, permanentResidence: newPR };
                        }
                        return p;
                    });
                    updates.propertyData = updatedPropertyDataArray;
                    
                    updates.lastActionMessage = `${playerState.name} ${developmentMessage} for £${cost}.`;
                    updates.updatedAt = serverTimestamp();
                    
                    // If player didn't roll doubles, this action means their turn segment is done.
                    if (!freshGameData.lastDiceRoll?.isDoubles) {
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = true;
                    } // If doubles, playerActionTakenThisTurn remains false for re-roll

                    transaction.update(gameDocRef, updates);
                    logEvent("Development successful in transaction:", updates);
                });

                developPropertyContainer.style.display = 'none'; 

            } catch (error) {
                console.error("Error confirming development:", error);
                showMessageModal("Development Error", error.message);
            }
        }


        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', async () => {
            if (firebaseConfigToUse.apiKey === "YOUR_API_KEY" || !firebaseConfigToUse.projectId) {
                 onlineSetupMessage.textContent = "CRITICAL: Firebase is not configured. Please update firebaseConfigToUse in the script.";
                 console.error("CRITICAL: Firebase configuration is a placeholder. Update it with your actual Firebase project details.");
                 createGameButton.disabled = true;
                 joinGameButton.disabled = true;
                 showMessageModal("SETUP REQUIRED", "Firebase is not configured. Online features are disabled. See console for details.");
                 return; 
            }
            reformatBoardLayout(); 
            await initializeFirebase();
            
            const overlay = document.querySelector('.overlay');
            if(overlay) overlay.style.display = 'none';
        });

        document.body.addEventListener('click', async () => {
            if (!audioContextStarted && typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                try {
                    await Tone.start();
                    audioContextStarted = true;
                    logEvent("AudioContext started by user interaction.");
                    if (!toneSynth) { 
                        toneSynth = new Tone.Synth({
                            oscillator: { type: "triangle" }, 
                            envelope: { attack: 0.005, decay: 0.1, sustain: 0.2, release: 0.3 }
                        }).toDestination();
                        logEvent("Tone.Synth initialized.");
                    }
                } catch (e) { 
                    console.error("Error starting Tone.js AudioContext or initializing synth:", e); 
                }
            }
        }, { once: true }); 

    </script>
  </div>
</body>
</html>
