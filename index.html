<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Migrantopoly - Online Multiplayer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            padding: 20px;
            color: #ecf0f1;
            position: relative;
            overflow-x: hidden;
            font-family: 'Inter', Arial, sans-serif;
            min-height: 100vh;
            background: #2c3e50;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* body::before is intended for a subtle background texture or effect.
           Its content is empty, so it should not display any text itself. */
        body::before {
            content: ''; 
            position: fixed;
            top: 50%;
            left: 50%;
            width: 1200px;
            height: 700px;
            transform: translate(-50%, -50%);
            background-color: rgba(255,255,255,0.05);
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.18;
            pointer-events: none;
            z-index: 0;
            mix-blend-mode: lighten;
        }

        .main-content {
          position: relative;
          z-index: 3; /* Ensures main content is above body::before and overlay */
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          min-height: 100vh;
          width: 100%;
          padding-top: 20px;
          padding-bottom: 20px;
          background-color: #2c3e50; /* Added to ensure opacity over potential stray body content */
        }

        #player-setup-screen, #online-setup-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #2c3e50;
            padding: 30px 40px;
            border-radius: 12px;
            border: 2px solid #7f8c8d;
            box-shadow: 0 8px 25px rgba(0,0,0,0.5);
            color: #ecf0f1;
            text-align: center;
            width: auto;
            max-width: 450px;
        }
        #player-setup-screen h2, #online-setup-screen h2 {
            color: #1abc9c;
            margin-top: 0;
            margin-bottom: 25px;
            font-size: 1.8em;
        }
        .setup-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 18px;
        }
        #player-setup-screen label, #online-setup-screen label {
            font-size: 1em;
            margin-right: 15px;
            flex-basis: 40%;
            text-align: left;
        }
        #player-setup-screen select, #online-setup-screen select, #online-setup-screen input {
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #7f8c8d;
            background-color: #34495e;
            color: #ecf0f1;
            font-size: 1em;
            flex-grow: 1;
        }
        #online-setup-screen input {
            width: calc(100% - 22px); /* Account for padding */
        }
        #player-setup-screen button, #online-setup-screen button {
            background-color: #27ae60;
            color: white;
            padding: 12px 25px;
            font-size: 1.1em;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 15px;
            margin-right: 10px;
        }
        #player-setup-screen button:last-child, #online-setup-screen button:last-child {
            margin-right: 0;
        }
        #player-setup-screen button:hover, #online-setup-screen button:hover {
            background-color: #2ecc71;
        }
         #online-setup-screen button.secondary {
            background-color: #3498db;
        }
        #online-setup-screen button.secondary:hover {
            background-color: #2980b9;
        }
        #player-setup-message, #online-setup-message {
            color: #f1c40f;
            font-size: 0.9em;
            margin-top: 15px;
            min-height: 1.2em;
        }
        #game-id-display {
            margin-top: 15px;
            font-size: 1.1em;
            color: #1abc9c;
        }
        #game-id-display span {
            font-weight: bold;
            background-color: #34495e;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
         #user-id-display {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.5);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            z-index: 1000;
        }


        #game-container, #game-info-area, #board-container {
            position: relative;
            z-index: 1;
        }

        #game-container {
            display: none; /* Initially hidden */
            flex-wrap: wrap;
            justify-content: center;
            gap: 25px;
            padding-top: 0px;
        }

        #board-container {
            display: grid;
            grid-template-columns: 100px repeat(8, 70px) 100px;
            grid-template-rows: 100px repeat(8, 70px) 100px;
            border: 3px solid #7f8c8d;
            width: 760px; /* Fixed width */
            height: 760px; /* Fixed height */
            position: relative;
            background-color: rgba(52, 73, 94, 0.68);
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            overflow: visible;
            margin-top: 20px;
            /* Add background image for the board */
            background-image: url('migrant3.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        #card-decks-center {
            display: none; /* Hide the center image container, since background is now on the board */
        }
        #center-board-image { display: none; }
        .card-deck {
            width: 110px;
            height: 60px;
            background: linear-gradient(135deg, #f7ca18 60%, #f1c40f 100%);
            border: 2px solid #7f8c8d;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.18);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1em;
            font-weight: bold;
            color: #2c3e50;
            cursor: pointer;
            user-select: none;
            transition: transform 0.1s;
        }
        .card-deck.opportunity {
            background: linear-gradient(135deg, #6dd5ed 60%, #2193b0 100%);
            color: #fff;
        }
        .card-deck.welfare {
            background: linear-gradient(135deg, #f7ca18 60%, #f1c40f 100%);
            color: #2c3e50;
        }
        .card-deck:active {
            transform: scale(0.96);
        }

        #on-board-card-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 280px;
            min-height: 190px; /* Use min-height to allow content to expand */
            background-color: #fdf5e6;
            border: 3px solid #c0392b;
            border-radius: 15px;
            box-shadow: 0 6px 22px rgba(0,0,0,0.35);
            z-index: 5;
            display: none; /* Initially hidden */
            flex-direction: column;
            align-items: center;
            justify-content: space-around;
            padding: 15px;
            box-sizing: border-box;
            text-align: center;
            color: #2c3e50;
        }

        #on-board-card-display h4 {
            margin: 5px 0;
            font-size: 1.4em;
            color: #c0392b;
            font-weight: bold;
        }

        #on-board-card-display p {
            margin: 10px 0; /* Increased margin */
            font-size: 1em;
            line-height: 1.45;
            overflow-y: auto;
            max-height: 100px;
            width: 100%;
            color: #34495e;
        }
        #on-board-card-ok-button { /* Specific ID for this OK button */
            background-color: #27ae60;
            margin-top: 10px;
        }
        #on-board-card-ok-button:hover {
            background-color: #2ecc71;
        }


        .space {
            border: 1px solid #7f8c8d;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 10px;
            position: relative;
            padding: 3px;
            box-sizing: border-box;
            background-color: #4a6378;
            color: #ecf0f1;
            border-radius: 5px;
        }
        .space .name {
            font-weight: bold;
            font-size: 10px;
            margin-bottom: 2px;
            line-height: 1.2;
        }
        .space .price {
            font-size: 9px;
            color: #bdc3c7;
            font-weight: normal;
        }
        .space .owner-indicator {
            width: 90%;
            height: 6px;
            margin-top: 3px;
            background-color: transparent;
            border-radius: 3px;
            position: absolute;
            bottom: 3px;
            left: 5%;
        }
         .space .development-indicator {
            font-size: 12px;
            color: #fff;
            position: absolute;
            top: 15px;
            width: 100%;
            text-align: center;
            line-height: 1;
            text-shadow: 0 0 2px #000;
        }
        .space .sub-label {
            font-size: 10px;
            color: #e74c3c;
            font-weight: bold;
            margin-top: 2px;
            letter-spacing: 0.04em;
            text-align: center;
            line-height: 1.1;
        }

        .corner {
            font-weight: bold;
            background-color: #527a78;
        }
        .corner .name {
            font-size: 16px !important;
            color: #e74c3c !important;
            font-weight: bold !important;
            margin-top: 0;
        }
        .corner .name.detention-center-name {
            margin-top: 35px;
            position: relative;
            z-index: 1;
        }


        .property .color-bar {
            width: 100%;
            height: 12px;
            border-bottom: 1px solid #7f8c8d;
            position: absolute;
            top: 0;
            left: 0;
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
        }
        .space.property .name { margin-top: 14px; }

        .welfare .name, .opportunity .name, .tax .name, .payout .name, .neutral:not(.corner) .name {
            margin-top: 0;
        }
        
        .set-property {
            background-color: #303F4D;
        }
        .set-property .name {
            margin-top: 0;
            font-size: 11px;
            font-weight: bold;
        }


        .brown .color-bar { background-color: #8B4513; }
        .light-blue .color-bar { background-color: #ADD8E6; }
        .pink .color-bar { background-color: #FFC0CB; }
        .orange .color-bar { background-color: #FFA500; }
        .red .color-bar { background-color: #FF0000; }
        .green .color-bar { background-color: #008000; }


        .player-token {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            position: absolute;
            border: none;
            font-size: 26px;
            line-height: 28px;
            text-align: center;
            background: none;
            z-index: 10;
            user-select: none;
            pointer-events: none;
        }

        #game-info-area {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #player-info, #controls, #card-display-container, #game-status-message-container, #develop-property-container {
            padding: 15px;
            background-color: #34495e;
            border: 1px solid #7f8c8d;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            color: #ecf0f1;
        }
        #player-info div { margin-bottom: 8px; font-size: 14px; }
        #card-message { margin-bottom: 10px; font-size: 14px; }

        button {
            padding: 10px 15px;
            font-size: 14px;
            cursor: pointer;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 6px;
            transition: background-color 0.2s;
            margin-top: 5px;
            margin-right: 5px;
        }
        button:last-child { margin-right: 0; }
        button:hover {
            background-color: #c0392b;
        }
        button:disabled {
            background-color: #7f8c8d;
            color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .main-action-button {
            display: block !important;
            margin: 8px auto !important;
        }

        #end-turn-button {
            background-color: #d35400;
        }
        #end-turn-button:hover {
            background-color: #e67e22;
        }
        #develop-property-button {
            background-color: #2980b9;
        }
        #develop-property-button:hover {
            background-color: #3498db;
        }


        #card-display-container, #develop-property-container {
            display: none; /* Initially hidden */
        }
        #card-display-container h3, #develop-property-container h3 {
             margin-top: 0; color: #1abc9c;
        }

        #detention-actions button {
            background-color: #f39c12;
            margin-right: 5px;
        }
        #detention-actions button:hover {
            background-color: #e67e22;
        }
        #game-status-message {
            font-weight: bold;
            color: #e74c3c;
            min-height: 20px;
        }
        #pre-game-roll-area button {
            background-color: #f1c40f;
            color: #2c3e50;
        }
        #pre-game-roll-area button:hover {
            background-color: #f39c12;
        }
        #pre-game-roll-results { margin-top: 10px; font-size: 13px; }
        #develop-property-options button {
            display: block;
            width: calc(100% - 10px);
            margin-bottom: 8px;
            background-color: #2980b9;
        }
        #develop-property-options button:hover {
            background-color: #3498db;
        }

        .space.dole-space .name {
            font-size: 26px !important;
            font-weight: bold;
            letter-spacing: 0.08em;
            color: #fff !important;
            text-transform: uppercase;
            position: absolute;
            top: 15px;
            left: 0;
            width: 100%;
            text-align: center;
            transform: rotate(-36deg);
            transform-origin: center center;
            white-space: nowrap;
            pointer-events: none;
        }
        .dole-sign {
            position: absolute;
            bottom: 8px;
            right: 8px;
            font-size: 28px;
            color: #f1c40f;
            font-weight: bold;
            z-index: 3;
        }

        .space.red-boardname .name {
            color: #e74c3c !important;
            font-weight: bold;
        }
        .space.yellow-boardname .name {
            color: #f1c40f !important;
            font-weight: bold;
        }


        .player-highlight {
            animation: player-highlight-flash 1s;
            background: #ffeaa7;
            color: #222d3a !important;
        }
        @keyframes player-highlight-flash {
            0% { background: #ffeaa7; }
            60% { background: #ffeaa7; }
            100% { background: transparent; }
        }

        #money-flash {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 7vw;
            font-family: 'Impact', 'Arial Black', Arial, sans-serif;
            color: #e74c3c; /* Red for loss, maybe green for gain later */
            font-weight: bold;
            opacity: 0;
            pointer-events: none;
            z-index: 1000;
            text-shadow: 2px 2px 16px #000, 0 0 32px #fff;
            transition: opacity 0.2s;
        }
        #money-flash.show {
            opacity: 1;
            animation: money-flash-pop 0.7s;
        }
        @keyframes money-flash-pop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.7); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            60% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.7); }
        }

        .detention-bars {
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            height: 32px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            z-index: 2;
        }
        .detention-bar {
            width: 4px;
            height: 100%;
            background: #111;
            border-radius: 2px;
            opacity: 0.85;
        }
        .detention-arrow {
            position: absolute;
            bottom: 6px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2em;
            color: #e67e22;
            font-weight: bold;
            z-index: 2;
            pointer-events: none;
            text-shadow: 1px 1px 6px #000, 0 0 8px #fff;
        }

        #current-turn-display {
            text-align: center;
            width: 100%;
            color: #ecf0f1;
            font-weight: bold;
            padding-bottom: 5px;
        }
        #current-turn-display.pulsing { /* New class for pulsing effect */
            font-size: 1.2em; /* Slightly larger font */
            animation: pulse-text-animation 1.5s infinite ease-in-out;
        }
        @keyframes pulse-text-animation { /* New animation for current turn text */
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        #game-status-message-container {
            text-align: center;
        }
        #uk-gov-status {
            padding: 12px;
            background: #222d3a;
            border: 1px solid #7f8c8d;
            border-radius: 8px;
            color: #f7ca18;
            font-weight: bold;
            text-align: center;
        }
         #uk-gov-status-container {
            width: 100%;
            box-sizing: border-box;
        }


        #pre-game-roll-area {
            display: none; /* Initially hidden */
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .overlay {
          position: fixed;
          top: 0; left: 0; right: 0; bottom: 0;
          background: rgba(24,28,36,0.48);
          z-index: 2; /* Ensure it's above body::before but below main content modals */
          pointer-events: none;
        }


        .die {
            width: 30px;
            height: 30px;
            border: 1px solid #ecf0f1;
            background-color: #fff;
            color: #2c3e50;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .dice-animation {
            animation: dice-roll-effect 0.4s ease-out;
        }
        @keyframes dice-roll-effect {
            0% { transform: scale(1) rotate(0deg); opacity: 0.5; }
            25% { transform: scale(1.3) rotate(90deg); opacity: 0.75; }
            50% { transform: scale(1.1) rotate(180deg); opacity: 1; }
            75% { transform: scale(1.3) rotate(270deg); opacity: 0.75; }
            100% { transform: scale(1) rotate(360deg); opacity: 1; }
        }

        .token-hop { /* General hop for landing, can be reused or a new one for steps */
            animation: hop-animation 0.3s ease-out;
        }
        @keyframes hop-animation {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            30% { transform: translateY(-35px) scale(1.25); opacity: 0.9; }
            60% { transform: translateY(-35px) scale(1.25); opacity: 0.9; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }

        .token-arrive-step { /* Short animation for each step */
            animation: arrive-step-animation 0.15s ease-out;
        }
        @keyframes arrive-step-animation {
            0% { transform: scale(0.8) translateY(2px); opacity: 0.7; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }

        #dice-display-master-container {
            min-height: 32px;
            text-align: center;
            margin-bottom: 8px;
        }
        #actual-dice-faces {
            display: inline-flex;
            gap: 5px;
            margin-left: 5px;
            vertical-align: middle;
        }
        #dice-total-display-text {
            margin-left: 8px;
            font-weight: bold;
        }

        .token-flash {
            animation: token-flash-animation 0.7s infinite alternate;
        }
        @keyframes token-flash-animation {
            0% { opacity: 1; transform: scale(1.1); filter: drop-shadow(0 0 6px currentColor) drop-shadow(0 0 3px #fff); }
            100% { opacity: 0.6; transform: scale(1); filter: drop-shadow(0 0 3px currentColor); }
        }
        .token-move-flash {
            animation: token-move-flash-animation 0.2s infinite;
        }
        @keyframes token-move-flash-animation {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 1001; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.6); /* Black w/ opacity */
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background-color: #2c3e50;
            margin: auto;
            padding: 25px 35px;
            border: 1px solid #7f8c8d;
            border-radius: 10px;
            width: 80%;
            max-width: 450px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            text-align: center;
        }
        .modal-content h3 {
            color: #1abc9c;
            margin-top: 0;
        }
        .modal-content p {
            margin-bottom: 20px;
        }
        .modal-content button {
             background-color: #e74c3c;
        }
         .modal-content button:hover {
             background-color: #c0392b;
         }

</style>
</head>
<body>
  <div class="overlay"></div>
  <div id="user-id-display">Your User ID: <span id="local-user-id">Not Signed In</span></div>
  <div class="main-content">
    <div id="online-setup-screen"> <h2>Migrantopoly Online</h2>
        <div class="setup-row">
            <label for="player-name-input">Your Name:</label>
            <input type="text" id="player-name-input" placeholder="Enter your name" value="Player">
        </div>
        <div class="setup-row">
            <label for="game-id-input">Game ID (for joining):</label>
            <input type="text" id="game-id-input" placeholder="Enter Game ID to join">
        </div>
        <button id="join-game-button">Join Game</button>
        <hr style="width:80%; margin: 20px 0; border-color: #7f8c8d;">
        <div class="setup-row">
            <label for="num-players-online-select">Total Players in Game:</label>
            <select id="num-players-online-select">
                <option value="2" selected>2 Players</option>
                <option value="3">3 Players</option>
                <option value="4">4 Players</option>
            </select>
        </div>
        <button id="create-game-button">Create New Game</button>
        <p id="online-setup-message"></p>
        <div id="game-id-display" style="display:none;">
            Share this Game ID: <span id="generated-game-id" title="Click to copy"></span>
        </div>
    </div>

    <div id="player-setup-screen" style="display: none;"> <h2>Player Setup (Local)</h2>
        </div>

    <div id="game-container" style="display: none;">
        <div id="board-container">
            </div>

        <div id="game-info-area">
            <div id="player-info">
                </div>

            <div id="controls">
                <h3 id="current-turn-display">Current Turn: Player 1</h3>
                <div id="pre-game-roll-area" style="display:none;">
                    <h4>Determine Starting Player</h4>
                    <button id="pre-game-roll-button">Roll to Start</button>
                    <div id="pre-game-roll-results"></div>
                </div>

                <div id="dice-display-master-container">
                    <span>Dice: </span>
                    <div id="actual-dice-faces">
                        <div class="die" id="die-face-1">--</div>
                        <div class="die" id="die-face-2">--</div>
                    </div>
                    <span id="dice-total-display-text"></span>
                </div>
                <button id="roll-dice-button" style="display:none;">Roll Dice</button>
                <button id="end-turn-button" style="display:none;">End Turn</button>

                <div id="other-actions-container" style="text-align: center; margin-top: 5px;">
                    <button id="develop-property-button" style="display:none;">Develop Property</button>
                    <button id="buy-property-button" style="display:none;">Buy Property (Â£<span id="buy-property-price"></span>)</button>
                </div>
                <div id="detention-actions" style="margin-top: 10px;">
                    </div>
            </div>

            <div id="develop-property-container" style="display:none;">
                <h3 id="develop-property-name">Develop Property</h3>
                <div id="develop-property-options">
                    </div>
                <button id="close-develop-button">Close</button>
            </div>


            <div id="card-display-container" style="display:none;">
                <h3 id="card-type-title">Card Drawn</h3>
                <p id="card-message"></p>
                <button id="card-ok-button">OK</button>
            </div>

            <div id="game-status-message-container">
                <h4>Game Status:</h4>
                <p id="game-status-message">Waiting for game to start...</p>
            </div>

            <div id="uk-gov-status-container">
                <div id="uk-gov-status">
                    UK Gov: Â£<span id="uk-gov-cash">20000</span>
                </div>
            </div>
        </div>
    </div>

    <div id="money-flash"></div>

    <div id="message-modal" class="modal">
        <div class="modal-content">
            <h3 id="modal-title">Notification</h3>
            <p id="modal-message">This is a sample message.</p>
            <button id="modal-ok-button">OK</button>
        </div>
    </div>

  </div>

    <script type="module">
        // --- Firebase Configuration ---
        const userProvidedFirebaseConfig = {
            apiKey: "AIzaSyARzlfhH_AC0YTxJ5fKvhz_SPDq1r6mWPA",
            authDomain: "migrantopoly.firebaseapp.com",
            projectId: "migrantopoly",
            storageBucket: "migrantopoly.firebasestorage.app",
            messagingSenderId: "649348280586",
            appId: "1:649348280586:web:2bd3be4d2de84c0ea8caf3",
            measurementId: "G-1TMRSC6KL8"
        };
        // Use global config if available, otherwise fallback to userProvided (or your defaults)
        const firebaseConfigToUse = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : userProvidedFirebaseConfig;
        
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Firebase SDK imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, serverTimestamp, arrayUnion, arrayRemove, runTransaction, writeBatch, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js"; // Analytics can be added if needed

        let db, auth, currentUserId = null, localPlayerName = '';
        let currentGameId = null; 
        let unsubscribeGameState = null; 
        let localGameData = {}; // Local cache of the game state
        let aiAddTimerId = null; // Timer for adding AI players
        // let analytics; // Declare analytics if you plan to use it

        // --- DOM Elements ---
        const onlineSetupScreen = document.getElementById('online-setup-screen');
        const gameContainer = document.getElementById('game-container');
        const playerNameInput = document.getElementById('player-name-input');
        const gameIdInput = document.getElementById('game-id-input');
        const createGameButton = document.getElementById('create-game-button');
        const joinGameButton = document.getElementById('join-game-button');
        const numPlayersOnlineSelect = document.getElementById('num-players-online-select');
        const onlineSetupMessage = document.getElementById('online-setup-message');
        const gameIdDisplayDiv = document.getElementById('game-id-display');
        const generatedGameIdSpan = document.getElementById('generated-game-id');
        const localUserIdSpan = document.getElementById('local-user-id');

        const boardContainer = document.getElementById('board-container');
        const playerInfoDiv = document.getElementById('player-info');
        const rollDiceButton = document.getElementById('roll-dice-button');
        const endTurnButton = document.getElementById('end-turn-button');
        const buyPropertyButton = document.getElementById('buy-property-button');
        const buyPropertyPriceSpan = document.getElementById('buy-property-price');
        const developPropertyButton = document.getElementById('develop-property-button');
        const diceFace1Elem = document.getElementById('die-face-1');
        const diceFace2Elem = document.getElementById('die-face-2');
        const diceTotalDisplayText = document.getElementById('dice-total-display-text');
        const currentTurnDisplay = document.getElementById('current-turn-display');
        const cardDisplayContainer = document.getElementById('card-display-container');
        const cardTypeTitle = document.getElementById('card-type-title');
        const cardMessageP = document.getElementById('card-message');
        const cardOkButton = document.getElementById('card-ok-button');
        const detentionActionsDiv = document.getElementById('detention-actions');
        const gameStatusMessageP = document.getElementById('game-status-message');
        const preGameRollArea = document.getElementById('pre-game-roll-area');
        const preGameRollButton = document.getElementById('pre-game-roll-button');
        const preGameRollResultsDiv = document.getElementById('pre-game-roll-results');
        const developPropertyContainer = document.getElementById('develop-property-container');
        const developPropertyNameH3 = document.getElementById('develop-property-name');
        const developPropertyOptionsDiv = document.getElementById('develop-property-options');
        const closeDevelopButton = document.getElementById('close-develop-button');
        const otherActionsContainer = document.getElementById('other-actions-container');
        const ukGovCashSpan = document.getElementById('uk-gov-cash');
        let onBoardCardDisplayDiv, onBoardCardTypeH4, onBoardCardTextP, onBoardCardOkButton; 

        const messageModal = document.getElementById('message-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalOkButton = document.getElementById('modal-ok-button');
        const moneyFlashDiv = document.getElementById('money-flash');


        // --- Game Data Definitions ---
        let initialBoardLayout = [ // This layout will be reformatted
            { id: 0, name: "Dole", type: "go" },
            { id: 1, name: "Tent in Field 1", type: "property", price: 60, rent: [4, 20, 60, 180, 320, 450], color: "brown", groupId: "brown", houseCost: 50 }, // Added houseCost, expanded rent
            { id: 2, name: "Welfare Card", type: "welfare" },
            { id: 3, name: "Tent in Field 2", type: "property", price: 80, rent: [8, 40, 100, 300, 450, 600], color: "brown", groupId: "brown", houseCost: 50 }, // Added houseCost, expanded rent
            { id: 4, name: "Black Market Sales", type: "set_property", price: 200, rent_base: 25, groupId: "special_set" }, // Rent base is per property
            { id: 5, name: "Fake PIP declined", type: "tax", amount: 100 },
            { id: 6, name: "Tesco Cardboard Skip 1", type: "property", price: 100, rent: [6, 30, 90, 270, 400, 550], color: "light-blue", groupId: "lightblue", houseCost: 50 },
            { id: 7, name: "Tesco Cardboard Skip 2", type: "property", price: 120, rent: [8, 40, 100, 300, 450, 600], color: "light-blue", groupId: "lightblue", houseCost: 50 },
            { id: 8, name: "Detention Center", type: "detention_visiting" },
            { id: 9, name: "Payout: Job Seeker's", type: "payout", amount: 100 },
            { id: 10, name: "Tesco Cardboard Skip 3", type: "property", price: 140, rent: [10, 50, 150, 450, 625, 750], color: "light-blue", groupId: "lightblue", houseCost: 50 },
            { id: 11, name: "Council Highrise 1", type: "property", price: 160, rent: [12, 60, 180, 500, 700, 900], color: "pink", groupId: "pink", houseCost: 100 },
            { id: 12, name: "Forced Marriage", type: "set_property", price: 200, rent_base: 25, groupId: "special_set" },
            { id: 13, name: "Welfare Card", type: "welfare" }, 
            { id: 14, name: "Council Highrise 2", type: "property", price: 180, rent: [14, 70, 200, 550, 750, 950], color: "pink", groupId: "pink", houseCost: 100 },
            { id: 15, name: "Council Highrise 3", type: "property", price: 200, rent: [16, 80, 220, 600, 800, 1000], color: "pink", groupId: "pink", houseCost: 100 },
            { id: 16, name: "Crime Spree !!! Arrest", type: "crime_spree", amount: 150 }, 
            { id: 17, name: "Gypsy Estate 1", type: "property", price: 220, rent: [18, 90, 250, 700, 875, 1050], color: "orange", groupId: "orange", houseCost: 150 },
            { id: 18, name: "Opportunity Card", type: "opportunity" }, 
            { id: 19, name: "Gypsy Estate 2", type: "property", price: 240, rent: [20, 100, 300, 750, 925, 1100], color: "orange", groupId: "orange", houseCost: 150 },
            { id: 20, name: "Child Wives", type: "set_property", price: 200, rent_base: 25, groupId: "special_set" },
            { id: 21, name: "Fake ID Cards", type: "tax", amount: 100 },
            { id: 22, name: "Gypsy Estate 3", type: "property", price: 260, rent: [22, 110, 330, 800, 975, 1150], color: "orange", groupId: "orange", houseCost: 150 },
            { id: 23, name: "Holiday Inn 1", type: "property", price: 280, rent: [24, 120, 360, 850, 1025, 1200], color: "red", groupId: "red", houseCost: 200 },
            { id: 24, name: "Go to Detention Center", type: "go_to_detention" }, 
            { id: 25, name: "Welfare Card", type: "welfare" }, 
            { id: 26, name: "Holiday Inn 2", type: "property", price: 300, rent: [26, 130, 390, 900, 1100, 1275], color: "red", groupId: "red", houseCost: 200 },
            { id: 27, name: "Holiday Inn 3", type: "property", price: 320, rent: [28, 150, 450, 1000, 1200, 1400], color: "red", groupId: "red", houseCost: 200 },
            { id: 28, name: "I Dont speak English", type: "set_property", price: 200, rent_base: 25, groupId: "special_set" },
            { id: 29, name: "Luxury Flat 1", type: "property", price: 350, rent: [35, 175, 500, 1100, 1300, 1500], color: "green", groupId: "green", houseCost: 200 },
            { id: 30, name: "Opportunity Card", type: "opportunity" }, 
            { id: 31, name: "Luxury Flat 2", type: "property", price: 400, rent: [50, 200, 600, 1400, 1700, 2000], color: "green", groupId: "green", houseCost: 200 },
        ];
        let boardLayout = []; // Will hold the final, re-indexed board layout
        let detentionCenterSpaceId;
        // Constants for development costs - these are now on the property definitions (houseCost)
        // const TENANCY_COST = 50; // Example, adjust as needed, or better, define per property group
        // const PR_COST = 150; // Example, adjust as needed
        const MAX_TENANCIES_BEFORE_PR = 4; // Standard Monopoly has 4 houses before a hotel
        const PR_IS_FIFTH_DEVELOPMENT = true; // PR acts as the 5th level (hotel)


        const welfareCards = [
            { text: "Child Benefit: Collect Â£100.", action: "collect", amount: 100 },
            { text: "Free Health Service: Gain a health service (worth Â£100).", action: "gainHealthService" },
            { text: "Council House Grant: Collect Â£150.", action: "collect", amount: 150 },
            { text: "Social Worker Fee: Pay Â£50.", action: "pay", amount: 50 },
            { text: "Food Voucher: Collect Â£75.", action: "collect", amount: 75 },
            { text: "Education Grant: Collect Â£120.", action: "collect", amount: 120 },
            { text: "Housing Inspection: Pay Â£20 per tenancy/PR owned.", action: "payPerDevelopment", amountPerTenancy: 20, amountPerPR: 100 },
            { text: "Utility Subsidy: Collect Â£80.", action: "collect", amount: 80 },
            { text: "Legal Aid: Get out of Detention Center free.", action: "getOutOfDetentionFree" },
            { text: "Emergency bowels: Collect Â£100.", action: "collect", amount: 100 },
            { text: "Tax Audit: Pay Â£60.", action: "pay", amount: 60 },
            { text: "Welfare Review: Move to nearest Payout Space.", action: "moveToNearestPayout" }
        ];
        const opportunityCards = [
            { text: "Work Permit Granted: Collect Â£150.", action: "collect", amount: 150 },
            { text: "Language Subsidy: Collect Â£50.", action: "collect", amount: 50 },
            { text: "Community Grant: Collect Â£100.", action: "collect", amount: 100 },
            { text: "Deportation Threat: Go to Detention Center. Do not pass Dole. Do not collect Â£200.", action: "goToDetentionDirect" },
            { text: "Legal Homosexuals: Get out of Detention Center free.", action: "getOutOfDetentionFree" },
            { text: "Job Offer: Collect Â£120.", action: "collect", amount: 120 },
            { text: "Housing Voucher: Next estate purchase is 25% off.", action: "housingVoucher" },
            { text: "Free Health Service: Gain a health service (worth Â£100).", action: "gainHealthService" },
            { text: "Bank Manager Shat His Load: Pay Â£50 to the bank.", action: "pay", amount: 50 },
            { text: "Tax Refund: Collect Â£75.", action: "collect", amount: 75 },
            { text: "Dogs Had An Abortion: Collect Â£40 from each player.", action: "collectFromPlayers", amount: 40 },
            { text: "Advance to Dole: Collect Â£400.", action: "advanceToGo" } // Standard Monopoly "Advance to Go"
        ];
        const playerEmojis = ['ðŸ•â€ðŸ¦º', 'ðŸˆ', 'ðŸ˜', 'ðŸ…', 'ðŸ’', 'ðŸ¦Š']; 
        const playerColors = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6', '#1abc9c']; 

        let toneSynth;
        let audioContextStarted = false;
        // let currentCardBeingExecuted = null; // This seems managed by currentCardDraw in Firestore

        // --- Utility Functions ---
        function logEvent(message, data = null) {
            if (data) {
                console.log(`[Game Log] ${new Date().toLocaleTimeString()}: ${message}`, data);
            } else {
                console.log(`[Game Log] ${new Date().toLocaleTimeString()}: ${message}`);
            }
        }

        function showMessageModal(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            messageModal.style.display = 'flex';
        }
        modalOkButton.onclick = () => {
            messageModal.style.display = 'none';
        };

        function generateGameId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function reformatBoardLayout() { 
            const newBoardLocations = [
                { name: "Boat Sank After Renting", type: "set_property", price: 100, rent_base: 25, groupId: "special_set" },
                { name: "People Trafficking", type: "set_property", price: 100, rent_base: 25, groupId: "special_set" },
                { name: "More than 15 children", type: "set_property", price: 100, rent_base: 25, groupId: "special_set" },
                { name: "Crypto Scam from Iqbhal", type: "set_property", price: 100, rent_base: 25, groupId: "special_set" }
            ];
            let tempBoard = [];
            tempBoard.push(initialBoardLayout.find(s => s.id === 0)); 
            const welfareCardOriginalSide1 = initialBoardLayout.find(s => s.id === 2);
            const boatSankProperty = newBoardLocations[0];
            tempBoard.push(initialBoardLayout.find(s => s.id === 1));
            tempBoard.push(boatSankProperty);
            tempBoard.push(initialBoardLayout.find(s => s.id === 3));
            tempBoard.push(initialBoardLayout.find(s => s.id === 4)); // Black Market Sales
            tempBoard.push(welfareCardOriginalSide1);
            tempBoard.push(...initialBoardLayout.filter(s => s.id >= 5 && s.id <= 7)); // Fake PIP, Tesco 1, Tesco 2
            tempBoard.push(initialBoardLayout.find(s => s.id === 8)); // Detention Center
            
            const peopleTraffickingProperty = newBoardLocations[1];
            const payoutJobSeekersOriginal = initialBoardLayout.find(s => s.id === 9);
            tempBoard.push(peopleTraffickingProperty); // New property before Tesco 3
            tempBoard.push(initialBoardLayout.find(s => s.id === 10)); // Tesco 3
            tempBoard.push(initialBoardLayout.find(s => s.id === 11)); // Council Highrise 1
            tempBoard.push(initialBoardLayout.find(s => s.id === 12)); // Forced Marriage
            tempBoard.push(payoutJobSeekersOriginal); // Payout Job Seekers (moved)
            tempBoard.push(initialBoardLayout.find(s => s.id === 13)); // Welfare Card
            tempBoard.push(initialBoardLayout.find(s => s.id === 14)); // Council Highrise 2
            tempBoard.push(initialBoardLayout.find(s => s.id === 15)); // Council Highrise 3
            
            tempBoard.push(initialBoardLayout.find(s => s.id === 16)); // Crime Spree
            const moreThan15ChildrenProperty = newBoardLocations[2];
            const opportunityCardSide3Original = initialBoardLayout.find(s => s.id === 18);
            tempBoard.push(initialBoardLayout.find(s => s.id === 17)); // Gypsy Estate 1
            tempBoard.push(moreThan15ChildrenProperty); // New Property before Gypsy Estate 2
            tempBoard.push(initialBoardLayout.find(s => s.id === 19)); // Gypsy Estate 2
            tempBoard.push(initialBoardLayout.find(s => s.id === 20)); // Child Wives
            tempBoard.push(opportunityCardSide3Original); // Opportunity Card
            tempBoard.push(initialBoardLayout.find(s => s.id === 21)); // Fake ID Cards
            tempBoard.push(initialBoardLayout.find(s => s.id === 22)); // Gypsy Estate 3
            tempBoard.push(initialBoardLayout.find(s => s.id === 23)); // Holiday Inn 1

            tempBoard.push(initialBoardLayout.find(s => s.id === 24)); // Go To Detention
            const cryptoScamProperty = newBoardLocations[3];
            const opportunityCardSide4Original = initialBoardLayout.find(s => s.id === 30);
            tempBoard.push(initialBoardLayout.find(s => s.id === 25)); // Welfare Card
            tempBoard.push(initialBoardLayout.find(s => s.id === 26)); // Holiday Inn 2
            tempBoard.push(initialBoardLayout.find(s => s.id === 27)); // Holiday Inn 3
            tempBoard.push(initialBoardLayout.find(s => s.id === 28)); // I Don't Speak English
            tempBoard.push(opportunityCardSide4Original); // Opportunity Card (moved)
            tempBoard.push(initialBoardLayout.find(s => s.id === 29)); // Luxury Flat 1
            tempBoard.push(cryptoScamProperty); // New property before Luxury Flat 2
            tempBoard.push(initialBoardLayout.find(s => s.id === 31)); // Luxury Flat 2
            
            boardLayout = tempBoard.map((space, index) => ({ ...space, id: index })); // Re-index
            
            const dcSpace = boardLayout.find(s => s.name === "Detention Center");
            detentionCenterSpaceId = dcSpace ? dcSpace.id : (boardLayout.find(s => s.type === "detention_visiting")?.id || 8) ; 
        }


        // --- Firebase Setup ---
        async function initializeFirebase() {
            if (!firebaseConfigToUse || !firebaseConfigToUse.apiKey || firebaseConfigToUse.apiKey === "YOUR_API_KEY" || !firebaseConfigToUse.projectId) { 
                onlineSetupMessage.textContent = "Firebase configuration is missing or incomplete. Online features disabled.";
                console.error("Firebase config is not available or incomplete. Please update it in the script with your actual Firebase project details.");
                createGameButton.disabled = true;
                joinGameButton.disabled = true;
                showMessageModal("Setup Error", "Firebase is not configured. Please check the console for details. Online play is unavailable.");
                return;
            }
            try {
                const app = initializeApp(firebaseConfigToUse); 
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        localUserIdSpan.textContent = currentUserId;
                        logEvent(`Authenticated as: ${currentUserId}`);
                        onlineSetupMessage.textContent = "Connected. Ready to create or join a game.";
                        createGameButton.disabled = false;
                        joinGameButton.disabled = false;
                    } else {
                        currentUserId = null;
                        localUserIdSpan.textContent = "Not Signed In";
                        logEvent("User is signed out or initial authentication pending.");
                        
                        if (initialAuthToken) {
                            try {
                                await signInWithCustomToken(auth, initialAuthToken);
                                logEvent("Signed in with custom token.");
                            } catch (error) {
                                console.error("Custom token sign-in error:", error);
                                logEvent("Custom token sign-in failed, trying anonymous.");
                                await signInAnonymously(auth);
                            }
                        } else {
                            logEvent("No custom token, trying anonymous sign-in.");
                            await signInAnonymously(auth);
                        }
                    }
                });
            } catch (error) {
                console.error("Firebase initialization error:", error);
                onlineSetupMessage.textContent = "Error connecting to Firebase: " + error.message;
                showMessageModal("Firebase Error", "Could not initialize Firebase: " + error.message);
                createGameButton.disabled = true;
                joinGameButton.disabled = true;
            }
        }

        // --- Game Management Functions (Create, Join, Sync) ---
        async function handleCreateGame() {
            if (!currentUserId) {
                showMessageModal("Error", "You are not authenticated. Please wait or refresh.");
                return;
            }
            localPlayerName = playerNameInput.value.trim() || `Player ${currentUserId.substring(0,4)}`;
            if (!localPlayerName) {
                showMessageModal("Input Needed", "Please enter your player name.");
                return;
            }

            const newGameId = generateGameId();
            currentGameId = newGameId; 
            const numPlayers = parseInt(numPlayersOnlineSelect.value);

            const gameDocRef = doc(db, "games", newGameId);

            reformatBoardLayout(); 

            const initialPropertyDataForFirestore = boardLayout
                .filter(s => s.type === 'property' || s.type === 'set_property')
                .map(p => ({
                    id: p.id, 
                    name: p.name,
                    owner: null, 
                    tenancies: 0, // Represents number of houses
                    permanentResidence: false, // Represents hotel
                }));


            const initialPlayerData = {
                id: currentUserId, 
                name: localPlayerName,
                money: 2000,
                position: 0,
                propertiesOwned: [], // Changed from 'properties' to 'propertiesOwned' for clarity
                healthServices: 0,
                getOutOfDetentionCards: 0,
                inDetention: false,
                missedTurnsInDetention: 0,
                hasHousingVoucher: false,
                isBankrupt: false,
                playerActionTakenThisTurn: false, 
                doublesRolledInTurn: 0, 
                order: 0, 
                govReceived: 0,
                isAI: false 
            };

            const initialGameState = {
                gameId: newGameId,
                status: "waiting", 
                hostId: currentUserId,
                maxPlayers: numPlayers,
                players: { [currentUserId]: initialPlayerData }, 
                playerOrder: [currentUserId], 
                currentPlayerIndex: 0, 
                boardLayout: boardLayout, 
                propertyData: initialPropertyDataForFirestore, 
                bankMoney: 15000, // Standard Monopoly bank
                ukGovMoney: 20000,
                shuffledWelfareCards: shuffleDeck([...welfareCards]), 
                shuffledOpportunityCards: shuffleDeck([...opportunityCards]),
                welfareCardIndex: 0, 
                opportunityCardIndex: 0,
                lastDiceRoll: null, 
                lastActionMessage: `${localPlayerName} created the game. Waiting for players...`,
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp(),
                preGameRolls: {}, 
                preGamePlayersRolled: [], 
                preGamePhase: true, 
                gamePhase: "setup", 
                currentCardDraw: null, // Added for card synchronization
            };
            
            if (Object.keys(initialGameState.players).length < numPlayers) {
                if (currentUserId === initialGameState.hostId) {
                    if (aiAddTimerId) clearTimeout(aiAddTimerId); 
                    logEvent(`Host starting 30s timer to add AI players if game not full.`);
                    aiAddTimerId = setTimeout(() => {
                        checkAndAddAIPlayers(newGameId, numPlayers);
                    }, 30000); 
                }
            } else {
                 initialGameState.status = "active"; 
                 initialGameState.lastActionMessage = `${localPlayerName} created the game. Starting pre-game rolls.`;
            }


            try {
                await setDoc(gameDocRef, initialGameState);
                logEvent(`Game ${newGameId} created by ${localPlayerName}.`);
                onlineSetupMessage.textContent = `Game created! ID: ${newGameId}. Waiting for players...`;
                generatedGameIdSpan.textContent = newGameId;
                gameIdDisplayDiv.style.display = 'block';
                subscribeToGameState(newGameId);
            } catch (error) {
                console.error("Error creating game:", error);
                showMessageModal("Error", "Could not create game: " + error.message);
                onlineSetupMessage.textContent = "Failed to create game. " + error.message;
            }
        }

        async function handleJoinGame() {
            if (!currentUserId) {
                showMessageModal("Error", "You are not authenticated. Please wait or refresh.");
                return;
            }
            localPlayerName = playerNameInput.value.trim() || `Player ${currentUserId.substring(0,4)}`;
            if (!localPlayerName) {
                showMessageModal("Input Needed", "Please enter your player name.");
                return;
            }

            const gameIdToJoin = gameIdInput.value.trim().toUpperCase();
            if (!gameIdToJoin) {
                showMessageModal("Input Needed", "Please enter a Game ID to join.");
                return;
            }

            const gameDocRef = doc(db, "games", gameIdToJoin);

            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameDocRef);
                    if (!gameDoc.exists()) {
                        throw new Error("Game not found.");
                    }

                    const gameData = gameDoc.data();
                    if (gameData.boardLayout && gameData.boardLayout.length > 0) {
                        boardLayout = gameData.boardLayout;
                        const dcSpace = boardLayout.find(s => s.name === "Detention Center");
                        detentionCenterSpaceId = dcSpace ? dcSpace.id : (boardLayout.find(s => s.type === "detention_visiting")?.id || 8);
                    } else {
                        reformatBoardLayout();
                        logEvent("Warning: Joined game was missing boardLayout, reformatted locally.");
                    }


                    if (Object.keys(gameData.players).length >= gameData.maxPlayers) {
                        if (!gameData.players[currentUserId]) { 
                             throw new Error("Game is full.");
                        } else {
                            logEvent("Already part of this game. Rejoining/Resubscribing...");
                        }
                    }
                    
                    if (!gameData.players[currentUserId]) { 
                        const newPlayerOrderIndex = gameData.playerOrder.length; 
                        const newPlayerData = {
                            id: currentUserId, name: localPlayerName, money: 2000, position: 0, propertiesOwned: [],
                            healthServices: 0, getOutOfDetentionCards: 0, inDetention: false, missedTurnsInDetention: 0,
                            hasHousingVoucher: false, isBankrupt: false, playerActionTakenThisTurn: false,
                            doublesRolledInTurn: 0, order: newPlayerOrderIndex, govReceived: 0, isAI: false
                        };

                        const updates = {};
                        updates[`players.${currentUserId}`] = newPlayerData;
                        updates.playerOrder = arrayUnion(currentUserId); 
                        updates.updatedAt = serverTimestamp();

                        const newPlayerCount = gameData.playerOrder.length + 1; 

                        if (newPlayerCount === gameData.maxPlayers) {
                            updates.preGamePhase = true; 
                            updates.status = "active";   
                            updates.lastActionMessage = `${localPlayerName} joined. All players present! Starting pre-game rolls.`;
                        } else {
                            updates.lastActionMessage = `${localPlayerName} joined the game. Waiting for ${gameData.maxPlayers - newPlayerCount} more.`;
                        }
                        transaction.update(gameDocRef, updates);
                        logEvent(`${localPlayerName} joining game ${gameIdToJoin}. Player order index: ${newPlayerOrderIndex}`);
                    }
                });

                currentGameId = gameIdToJoin;
                onlineSetupMessage.textContent = `Joined game ${gameIdToJoin}! Waiting for game to start...`;
                subscribeToGameState(gameIdToJoin);

            } catch (error) {
                console.error("Error joining game:", error);
                showMessageModal("Error", "Could not join game: " + error.message);
                onlineSetupMessage.textContent = "Failed to join game. " + error.message;
            }
        }

        async function checkAndAddAIPlayers(gameId, maxPlayersInGame) {
            if (aiAddTimerId) { 
                clearTimeout(aiAddTimerId);
                aiAddTimerId = null;
            }
            logEvent(`checkAndAddAIPlayers called for game ${gameId}. Max players: ${maxPlayersInGame}`);

            const gameDocRef = doc(db, "games", gameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const gameDoc = await transaction.get(gameDocRef);
                    if (!gameDoc.exists()) {
                        logEvent("checkAndAddAIPlayers: Game document no longer exists.");
                        return;
                    }
                    const gameData = gameDoc.data();

                    if (gameData.status !== "waiting" || Object.keys(gameData.players).length >= maxPlayersInGame) {
                        logEvent("checkAndAddAIPlayers: Game is no longer waiting or is full. No AI needed.", { status: gameData.status, playerCount: Object.keys(gameData.players).length });
                        return;
                    }

                    const numHumanPlayers = Object.keys(gameData.players).length;
                    const numAIToAdd = maxPlayersInGame - numHumanPlayers;

                    if (numAIToAdd <= 0) {
                        logEvent("checkAndAddAIPlayers: No AI players needed.");
                        return;
                    }

                    logEvent(`checkAndAddAIPlayers: Adding ${numAIToAdd} AI player(s).`);
                    let updates = {};
                    let newPlayerOrder = [...gameData.playerOrder];
                    let newPlayersObject = {...gameData.players};
                    let aiPlayerNames = [];

                    for (let i = 0; i < numAIToAdd; i++) {
                        const aiPlayerId = `AI-${crypto.randomUUID().substring(0, 8)}`;
                        const aiPlayerName = `AI Bot ${i + 1}`;
                        aiPlayerNames.push(aiPlayerName);
                        const aiOrderIndex = newPlayerOrder.length; 
                        const aiPlayerData = {
                            id: aiPlayerId, name: aiPlayerName, money: 2000, position: 0, propertiesOwned: [],
                            healthServices: 0, getOutOfDetentionCards: 0, inDetention: false, missedTurnsInDetention: 0,
                            hasHousingVoucher: false, isBankrupt: false, playerActionTakenThisTurn: false,
                            doublesRolledInTurn: 0, order: aiOrderIndex, govReceived: 0, isAI: true
                        };
                        newPlayersObject[aiPlayerId] = aiPlayerData;
                        newPlayerOrder.push(aiPlayerId);
                    }

                    updates.players = newPlayersObject;
                    updates.playerOrder = newPlayerOrder;
                    updates.preGamePhase = true; 
                    updates.status = "active";   
                    updates.lastActionMessage = `${aiPlayerNames.join(', ')} joined as AI. Starting pre-game rolls.`;
                    updates.updatedAt = serverTimestamp();
                    
                    transaction.update(gameDocRef, updates);
                    logEvent(`checkAndAddAIPlayers: Successfully added ${numAIToAdd} AI player(s).`);
                });
            } catch (error) {
                console.error("Error in checkAndAddAIPlayers transaction:", error);
                showMessageModal("AI Add Error", "Could not add AI players: " + error.message);
            }
        }


        function subscribeToGameState(gameId) {
            if (unsubscribeGameState) {
                unsubscribeGameState(); 
            }
            const gameDocRef = doc(db, "games", gameId);
            unsubscribeGameState = onSnapshot(gameDocRef, async (docSnap) => {
                if (docSnap.exists()) {
                    const gameData = docSnap.data(); 
                    
                    if (currentUserId === gameData.hostId && aiAddTimerId) {
                        if (gameData.status !== "waiting" || Object.keys(gameData.players).length >= gameData.maxPlayers) {
                            logEvent("Game filled or started, clearing AI add timer.");
                            clearTimeout(aiAddTimerId);
                            aiAddTimerId = null;
                        }
                    }
                    
                    if (localGameData.players && gameData.players && currentUserId && 
                        localGameData.players[currentUserId] && gameData.players[currentUserId]) {
                        
                        const oldMoney = localGameData.players[currentUserId].money;
                        const newMoney = gameData.players[currentUserId].money;

                        if (typeof oldMoney !== 'undefined' && newMoney < oldMoney) {
                            const amountLost = oldMoney - newMoney;
                            if (amountLost > 0) { 
                                showMoneyChangeEffect(amountLost, 'loss');
                            }
                        } else if (typeof oldMoney !== 'undefined' && newMoney > oldMoney) {
                            const amountGained = newMoney - oldMoney;
                             if (amountGained > 0) { 
                                showMoneyChangeEffect(amountGained, 'gain');
                            }
                        }
                    }
                    
                    localGameData = gameData; 
                    logEvent("Game state updated from Firestore:", gameData.lastActionMessage || "No message", gameData.status);
                    
                    if (gameData.boardLayout && JSON.stringify(boardLayout) !== JSON.stringify(gameData.boardLayout)) {
                        logEvent("Board layout received from Firestore is different or not set, adopting it.");
                        boardLayout = gameData.boardLayout;
                        const dcSpace = boardLayout.find(s => s.name === "Detention Center");
                        detentionCenterSpaceId = dcSpace ? dcSpace.id : (boardLayout.find(s => s.type === "detention_visiting")?.id || 8);
                        if (boardContainer.innerHTML.trim() !== '') { 
                            logEvent("Board was already drawn, re-setting up from new Firestore layout.");
                            setupBoardFromFirestore(gameData); 
                        }
                    }

                     // --- Card Draw Display Logic (Moved into onSnapshot) ---
                    if (gameData.currentCardDraw && (!window._lastCardDrawIdShown || window._lastCardDrawIdShown !== gameData.currentCardDraw.id)) {
                        window._lastCardDrawIdShown = gameData.currentCardDraw.id;
                        logEvent("New card draw detected in onSnapshot:", gameData.currentCardDraw);
                        showCardModal(gameData.currentCardDraw, gameData.currentCardDraw.type, async () => {
                            // Only the player who drew the card (or host for AI) should apply the action
                            // However, for simplicity now, any client can trigger apply if they are the one who drew it
                            // A more robust solution would be for the host to manage card action application.
                            if (gameData.currentCardDraw.playerId === currentUserId || (localGameData.players[gameData.currentCardDraw.playerId]?.isAI && currentUserId === localGameData.hostId) ) {
                                await applyCardAction(gameData.currentCardDraw, gameData.currentCardDraw.playerId, gameData.currentCardDraw.type.toLowerCase());
                            }
                            // Clear the card from Firestore for all AFTER action is processed (or attempted)
                            // This should ideally be done by the client that applied the action.
                            if (currentUserId === gameData.currentCardDraw.playerId || (localGameData.players[gameData.currentCardDraw.playerId]?.isAI && currentUserId === localGameData.hostId)) {
                                 await updateDoc(doc(db, "games", currentGameId), { currentCardDraw: null, updatedAt: serverTimestamp() });
                            }
                        });
                    } else if (!gameData.currentCardDraw) {
                        window._lastCardDrawIdShown = null; // Reset if card is cleared
                        if (onBoardCardDisplayDiv && onBoardCardDisplayDiv.style.display === 'flex') {
                            onBoardCardDisplayDiv.style.display = 'none'; // Hide modal if card is cleared from server
                        }
                    }
                    
                    updateLocalUIFromFirestore(gameData); 
                    
                    if (currentGameId && onlineSetupScreen.style.display !== 'none' && (gameData.status === "active" || gameData.status === "finished")) {
                         onlineSetupScreen.style.display = 'none';
                         gameContainer.style.display = 'flex';
                         logEvent("Switched to game container as game status is active/finished and setup screen was visible.");
                    }
                    if (
                        gameData.status === "active" &&
                        !gameData.preGamePhase &&
                        gameData.playerOrder &&
                        gameData.players
                    ) {
                        const currentPlayerId = gameData.playerOrder[gameData.currentPlayerIndex];
                        const currentPlayer = gameData.players[currentPlayerId];
                        if (currentPlayer && currentPlayer.isAI && !currentPlayer.isBankrupt) {
                            if (!window._aiTurnInProgress) {
                                window._aiTurnInProgress = true;
                                setTimeout(async () => {
                                    await handleAITurn(gameData, currentPlayerId);
                                    window._aiTurnInProgress = false;
                                }, 1000);
                            }
                        }
                    }
                } else {
                    logEvent(`Game ${gameId} no longer exists or access denied.`);
                    showMessageModal("Game Ended", "The game session has ended or is no longer available.");
                    if (unsubscribeGameState) unsubscribeGameState();
                    resetToSetupScreen();
                }
            }, (error) => {
                console.error("Error listening to game state:", error);
                showMessageModal("Connection Error", "Lost connection to the game: " + error.message);
                if (unsubscribeGameState) unsubscribeGameState();
                resetToSetupScreen();
            });
        }
        
        function resetToSetupScreen() {
            onlineSetupScreen.style.display = 'flex';
            gameContainer.style.display = 'none';
            currentGameId = null;
            localGameData = {};
            if (unsubscribeGameState) {
                unsubscribeGameState();
                unsubscribeGameState = null;
            }
            if (aiAddTimerId) { 
                clearTimeout(aiAddTimerId);
                aiAddTimerId = null;
            }
            onlineSetupMessage.textContent = "Ready to create or join a new game.";
            gameIdDisplayDiv.style.display = 'none';
            generatedGameIdSpan.textContent = '';
            gameIdInput.value = '';
            boardLayout = []; 
            if(boardContainer) boardContainer.innerHTML = ''; 
            if(playerInfoDiv) playerInfoDiv.innerHTML = '';
            if(diceFace1Elem) diceFace1Elem.textContent = '--';
            if(diceFace2Elem) diceFace2Elem.textContent = '--';
            if(diceTotalDisplayText) diceTotalDisplayText.textContent = '';
            if(currentTurnDisplay) currentTurnDisplay.textContent = 'Current Turn: Player 1';
            if(gameStatusMessageP) gameStatusMessageP.textContent = 'Waiting for game to start...';

        }

        async function finalizePreGameAsHost() {
            if (!currentGameId || !currentUserId || !db || !localGameData.hostId || localGameData.hostId !== currentUserId) {
                logEvent("finalizePreGameAsHost: Conditions not met.");
                return;
            }
            logEvent("Host attempting to finalize pre-game rolls.");

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) {
                        throw new Error("Game document not found during host finalization.");
                    }
                    const freshGameData = freshGameDoc.data();

                    if (!freshGameData.preGamePhase) {
                        logEvent("Host finalization: Pre-game phase already ended.");
                        return; 
                    }
                     if (freshGameData.hostId !== currentUserId) { 
                        logEvent("Host finalization check: Current user is NOT host in fresh data. Aborting.");
                        return;
                    }

                    const allPlayersInOrder = freshGameData.playerOrder || [];
                    const currentPreGameRolls = freshGameData.preGameRolls || {};
                    const allHaveRolled = allPlayersInOrder.length > 0 &&
                                        allPlayersInOrder.length === freshGameData.maxPlayers && 
                                        allPlayersInOrder.every(pid => currentPreGameRolls[pid] !== undefined);

                    if (!allHaveRolled) {
                        logEvent("Host finalization: Not all players have rolled or not all joined. Aborting.");
                        return; 
                    }
                    
                    logEvent("Host is proceeding with finalization of pre-game rolls.");
                    let updates = {};
                    const sortedPlayerIds = [...allPlayersInOrder].sort((a, b) => {
                        const rollA = currentPreGameRolls[a];
                        const rollB = currentPreGameRolls[b];
                        if (rollB === rollA) { 
                            return (freshGameData.players[a]?.order || 0) - (freshGameData.players[b]?.order || 0);
                        }
                        return rollB - rollA; 
                    });

                    updates.playerOrder = sortedPlayerIds; 
                    updates.currentPlayerIndex = 0;
                    updates.preGamePhase = false;
                    updates.gamePhase = "main";
                    updates.status = "active"; 
                    updates.lastActionMessage = `Starting order determined by host. ${freshGameData.players[sortedPlayerIds[0]].name} starts!`;
                    updates.updatedAt = serverTimestamp();
                    
                    transaction.update(gameDocRef, updates);
                    logEvent("Host successfully finalized pre-game starting order.");
                });
            } catch (error) {
                console.error("Error during host finalization of pre-game rolls:", error);
                showMessageModal("Host Finalization Error", "Could not finalize game start: " + error.message);
            }
        }

        // --- UI HELPER FUNCTION DEFINITIONS ---
        function updateDiceUIDisplay(gameData) {
            const diceDisplayContainer = document.getElementById('actual-dice-faces');
            if (!diceFace1Elem || !diceFace2Elem || !diceTotalDisplayText || !diceDisplayContainer) return;

            if (gameData.lastDiceRoll && gameData.gamePhase === "main" && !gameData.preGamePhase) {
                diceFace1Elem.textContent = gameData.lastDiceRoll.die1;
                diceFace2Elem.textContent = gameData.lastDiceRoll.die2;
                diceTotalDisplayText.textContent = ` = ${gameData.lastDiceRoll.total}`;
                
                diceDisplayContainer.classList.remove('dice-animation');
                void diceDisplayContainer.offsetWidth; 
                diceDisplayContainer.classList.add('dice-animation');
            } else { 
                diceFace1Elem.textContent = '--';
                diceFace2Elem.textContent = '--';
                diceTotalDisplayText.textContent = '';
                diceDisplayContainer.classList.remove('dice-animation');
            }
        }

        function updatePlayerInfoPanel(gameData) {
            if (!playerInfoDiv) return;
            playerInfoDiv.innerHTML = ''; 
            if (!gameData.playerOrder || !gameData.players) {
                logEvent("updatePlayerInfoPanel: Missing playerOrder or players data.");
                return;
            }

            gameData.playerOrder.forEach(playerId => {
                const p = gameData.players[playerId];
                if (!p || typeof p.id === 'undefined' || typeof p.order === 'undefined') { 
                    logEvent("updatePlayerInfoPanel: Invalid player data encountered for ID:", playerId, p);
                    return; 
                };

                const playerColor = playerColors[p.order % playerColors.length];
                const pDiv = document.createElement('div');
                if (p.isBankrupt) {
                    pDiv.innerHTML = `<b style="color:${playerColor};">${p.name}</b>: BANKRUPT`;
                    pDiv.style.textDecoration = 'line-through';
                    pDiv.style.opacity = '0.6';
                } else {
                    pDiv.innerHTML = `<b style='color:${playerColor};'>${p.name}</b>: <span style='font-weight:bold;'>Â£${p.money}</span> | HS: ${p.healthServices} | LegalAids: ${p.getOutOfDetentionCards}`;
                    if (p.inDetention) pDiv.innerHTML += ` (In Detention - ${p.missedTurnsInDetention} missed)`;
                }
                if (!gameData.preGamePhase && gameData.status === "active" && gameData.playerOrder[gameData.currentPlayerIndex] === p.id && !p.isBankrupt) { 
                    pDiv.style.border = `2px solid ${playerColor}`;
                    pDiv.style.padding = "3px";
                    pDiv.style.borderRadius = "4px";
                    pDiv.classList.add('player-highlight'); 
                } else {
                    pDiv.classList.remove('player-highlight');
                }
                playerInfoDiv.appendChild(pDiv);
            });
        }
        
        function updateGameStatusPanel(gameData) {
            if (!gameStatusMessageP || !currentTurnDisplay || !gameData.players || !gameData.playerOrder) return;

            if (gameData.preGamePhase) {
                 const joined = Object.keys(gameData.players).length;
                 if (joined < gameData.maxPlayers) {
                    gameStatusMessageP.textContent = `Waiting for players... (${joined}/${gameData.maxPlayers} joined)`;
                 } else { 
                    const allRolled = gameData.playerOrder.every(pid => gameData.preGameRolls && gameData.preGameRolls[pid] !== undefined);
                    if (allRolled) {
                        gameStatusMessageP.textContent = "All players rolled. Host is determining start order...";
                    } else {
                        gameStatusMessageP.textContent = "Pre-game: Determine starting player by rolling.";
                    }
                 }
            } else if (gameData.status === "active" && gameData.gamePhase === "main") {
                gameStatusMessageP.textContent = gameData.lastActionMessage || "Game in progress...";
            } else if (gameData.status === "finished") {
                gameStatusMessageP.textContent = gameData.lastActionMessage || "Game Over!";
            } else { 
                 gameStatusMessageP.textContent = `Waiting for players... (${Object.keys(gameData.players).length}/${gameData.maxPlayers} joined)`;
            }

            const currentPlayerIdInOrder = gameData.playerOrder[gameData.currentPlayerIndex];
            const currentPlayerInOrder = gameData.players[currentPlayerIdInOrder];

            if (currentPlayerInOrder && gameData.status === "active") { 
                if (gameData.preGamePhase) {
                    let nextPlayerToRollForDisplayId = null;
                    for(const pid of gameData.playerOrder) { 
                        if(!gameData.preGameRolls || gameData.preGameRolls[pid] === undefined) {
                            nextPlayerToRollForDisplayId = pid;
                            break;
                        }
                    }
                    const playerToRoll = gameData.players[nextPlayerToRollForDisplayId];

                    if (playerToRoll && typeof playerToRoll.name !== 'undefined' && typeof playerToRoll.order !== 'undefined') {
                         currentTurnDisplay.textContent = `Pre-Game Roll: ${playerToRoll.name}`;
                         currentTurnDisplay.style.color = playerColors[playerToRoll.order % playerColors.length];
                         currentTurnDisplay.classList.remove('pulsing'); 
                    } else if (Object.keys(gameData.players).length === gameData.maxPlayers) { 
                        currentTurnDisplay.textContent = "Pre-Game Rolls Complete";
                        currentTurnDisplay.style.color = '#ecf0f1'; 
                        currentTurnDisplay.classList.remove('pulsing');
                    } else {
                        currentTurnDisplay.textContent = "Waiting for Players...";
                        currentTurnDisplay.style.color = '#ecf0f1';
                        currentTurnDisplay.classList.remove('pulsing');
                    }
                } else if (gameData.gamePhase === "main" && !currentPlayerInOrder.isBankrupt) { 
                    currentTurnDisplay.textContent = `Current Turn: ${currentPlayerInOrder.name}`;
                    currentTurnDisplay.style.color = playerColors[currentPlayerInOrder.order % playerColors.length];
                    currentTurnDisplay.classList.add('pulsing'); 
                } else if (gameData.gamePhase === "main" && currentPlayerInOrder.isBankrupt) {
                    currentTurnDisplay.textContent = `Skipping Bankrupt: ${currentPlayerInOrder.name}`;
                    currentTurnDisplay.style.color = '#7f8c8d'; 
                    currentTurnDisplay.classList.remove('pulsing');
                }
            } else if (gameData.status === "finished") {
                currentTurnDisplay.textContent = "Game Over!";
                currentTurnDisplay.style.color = '#e74c3c';
                currentTurnDisplay.classList.remove('pulsing');
            } else { 
                currentTurnDisplay.textContent = "Game Not Fully Started";
                currentTurnDisplay.style.color = '#ecf0f1';
                currentTurnDisplay.classList.remove('pulsing');
            }
        }

        function updateControlsBasedOnTurn(gameData) {
            if (!currentUserId || !gameData.players || !gameData.players[currentUserId]) {
                rollDiceButton.style.display = 'none';
                endTurnButton.style.display = 'none';
                buyPropertyButton.style.display = 'none';
                developPropertyButton.style.display = 'none';
                otherActionsContainer.style.display = 'none'; 
                detentionActionsDiv.innerHTML = ''; 
                return;
            }
            const amIBankrupt = gameData.players[currentUserId]?.isBankrupt;

            rollDiceButton.style.display = 'none';
            endTurnButton.style.display = 'none';
            buyPropertyButton.style.display = 'none';
            developPropertyButton.style.display = 'none';
            otherActionsContainer.style.display = 'none'; 
            detentionActionsDiv.innerHTML = ''; 

            if (amIBankrupt || gameData.status === "finished" || gameData.preGamePhase) {
                const playerToken = document.getElementById(`player-token-${currentUserId}`);
                if (playerToken) playerToken.classList.remove('token-flash');
                return;
            }
            
            if (gameData.status !== "active" || gameData.gamePhase !== "main") return;

            const isMyTurn = gameData.playerOrder[gameData.currentPlayerIndex] === currentUserId;
            const myPlayerState = gameData.players[currentUserId]; 
            const amIInDetention = myPlayerState.inDetention;
            const myPlayerActionTakenThisTurn = myPlayerState.playerActionTakenThisTurn; 

            const playerToken = document.getElementById(`player-token-${currentUserId}`);
            if (isMyTurn) {
                if (playerToken && cardDisplayContainer.style.display === 'none' && developPropertyContainer.style.display === 'none' && (!onBoardCardDisplayDiv || onBoardCardDisplayDiv.style.display === 'none')) {
                    playerToken.classList.add('token-flash');
                } else if (playerToken) {
                    playerToken.classList.remove('token-flash');
                }
            } else {
                 if (playerToken) playerToken.classList.remove('token-flash');
            }


            if (isMyTurn) {
                if (amIInDetention) {
                    setupDetentionActionsUI(myPlayerState, gameData); 
                    if (myPlayerActionTakenThisTurn) { 
                        endTurnButton.style.display = 'block';
                        endTurnButton.disabled = false; 
                        endTurnButton.classList.add('main-action-button');
                        detentionActionsDiv.innerHTML = ''; 
                    }
                } else { 
                    const rolledDoubles = gameData.lastDiceRoll?.isDoubles;
                    const doublesCount = myPlayerState.doublesRolledInTurn || 0;

                    if (!myPlayerActionTakenThisTurn || (rolledDoubles && doublesCount > 0 && doublesCount < 3) ) {
                        rollDiceButton.style.display = 'block';
                        rollDiceButton.disabled = false; 
                        rollDiceButton.classList.add('main-action-button');
                        if (rolledDoubles && doublesCount > 0 && doublesCount < 3 && gameStatusMessageP) {
                            gameStatusMessageP.textContent = `${myPlayerState.name} rolled doubles! Roll again.`;
                        }
                    }

                    let showOptionalActions = false;
                    if (gameData.lastDiceRoll || myPlayerActionTakenThisTurn) { 
                        showOptionalActions = true;
                    }


                    if (showOptionalActions) {
                        otherActionsContainer.style.display = 'block';
                        const currentSpace = gameData.boardLayout[myPlayerState.position];
                        const propData = Array.isArray(gameData.propertyData) ? gameData.propertyData.find(p => p.id === currentSpace?.id) : null;

                        if (currentSpace && propData && (currentSpace.type === 'property' || currentSpace.type === 'set_property') && propData.owner === null) {
                            let price = currentSpace.price;
                            if (myPlayerState.hasHousingVoucher && currentSpace.type === 'property') {
                                price = Math.round(price * 0.75);
                            }
                            buyPropertyPriceSpan.textContent = price;
                            buyPropertyButton.style.display = (myPlayerState.money >= price) ? 'inline-block' : 'none';
                            if (buyPropertyButton.style.display === 'inline-block') buyPropertyButton.disabled = false;
                        } else {
                            buyPropertyButton.style.display = 'none';
                        }

                        developPropertyButton.style.display = canPlayerDevelopAnyProperty(myPlayerState, gameData) ? 'inline-block' : 'none';
                        if (developPropertyButton.style.display === 'inline-block') {
                            developPropertyButton.disabled = false; 
                        }

                        if (buyPropertyButton.style.display === 'none' && developPropertyButton.style.display === 'none') {
                            otherActionsContainer.style.display = 'none'; 
                        }
                    } else {
                         otherActionsContainer.style.display = 'none';
                    }
                    
                    if (myPlayerActionTakenThisTurn && !(rolledDoubles && doublesCount > 0 && doublesCount < 3) ) {
                        endTurnButton.style.display = 'block';
                        endTurnButton.disabled = false;
                        endTurnButton.classList.add('main-action-button');
                    }

                    const noMandatoryRollPending = !((myPlayerState.doublesRolledInTurn || 0) > 0 && (myPlayerState.doublesRolledInTurn || 0) < 3 && !myPlayerActionTakenThisTurn);
                    const noOptionalActionsAvailable = buyPropertyButton.style.display === 'none' && developPropertyButton.style.display === 'none';
                    const noCardActionPending = cardDisplayContainer.style.display === 'none' && (!onBoardCardDisplayDiv || onBoardCardDisplayDiv.style.display === 'none');

                    if (myPlayerActionTakenThisTurn && noMandatoryRollPending && noOptionalActionsAvailable && noCardActionPending) {
                        logEvent("Auto-ending turn conditions met. Setting timeout.");
                        setTimeout(() => {
                            const freshLocalDataForAutoEnd = localGameData; 
                            if (freshLocalDataForAutoEnd && freshLocalDataForAutoEnd.players && freshLocalDataForAutoEnd.players[currentUserId]) {
                                const stillMyTurnNow = freshLocalDataForAutoEnd.playerOrder[freshLocalDataForAutoEnd.currentPlayerIndex] === currentUserId;
                                const playerStateNow = freshLocalDataForAutoEnd.players[currentUserId];
                                
                                const noRollPendingNow = !((playerStateNow.doublesRolledInTurn || 0) > 0 && (playerStateNow.doublesRolledInTurn || 0) < 3 && !playerStateNow.playerActionTakenThisTurn);
                                const noOptionsNow = document.getElementById('buy-property-button').style.display === 'none' &&
                                                     document.getElementById('develop-property-button').style.display === 'none';
                                const noCardNow = document.getElementById('card-display-container').style.display === 'none' &&
                                                  (!document.getElementById('on-board-card-display') || document.getElementById('on-board-card-display').style.display === 'none');

                                if (stillMyTurnNow && playerStateNow.playerActionTakenThisTurn && noRollPendingNow && noOptionsNow && noCardNow) {
                                    logEvent("Auto-end conditions still met in timeout. Calling handleEndTurnAction.");
                                    handleEndTurnAction();
                                } else {
                                    logEvent("Auto-end conditions changed during timeout or not my turn anymore. Not auto-ending.");
                                }
                            } else {
                                logEvent("Auto-end timeout: Could not get fresh player data. Not auto-ending.");
                            }
                        }, 1500); 
                    }
                }
            }
        }
        
        function updatePreGameRollUI(gameData) {
            if (!preGameRollArea || !preGameRollButton || !preGameRollResultsDiv || !gameData.players) { 
                logEvent("updatePreGameRollUI: Missing DOM elements or player data.");
                return;
            }

            if (!gameData.preGamePhase || gameData.status !== "active" || Object.keys(gameData.players).length < gameData.maxPlayers) { 
                preGameRollArea.style.display = 'none';
                preGameRollButton.style.display = 'none';
                return;
            }
            
            preGameRollArea.style.display = 'flex'; 
            preGameRollResultsDiv.innerHTML = ''; 
            preGameRollButton.style.display = 'none'; 

            let allPlayerIdsInOrder = gameData.playerOrder || []; 
            let preGameRollsData = gameData.preGameRolls || {};
            let numberOfPlayers = allPlayerIdsInOrder.length;
            
            let rolledPlayerCount = 0;
            allPlayerIdsInOrder.forEach(pid => {
                const playerName = gameData.players[pid]?.name || 'Unknown Player';
                const playerOrderForColor = gameData.players[pid]?.order; 
                const playerColor = (typeof playerOrderForColor !== 'undefined') ? playerColors[playerOrderForColor % playerColors.length] : '#ecf0f1';

                if (preGameRollsData[pid] !== undefined) {
                    preGameRollResultsDiv.innerHTML += `<span style="color:${playerColor};">${playerName}</span> rolled: ${preGameRollsData[pid]}<br>`;
                    rolledPlayerCount++;
                } else {
                    preGameRollResultsDiv.innerHTML += `<span style="color:${playerColor};">${playerName}</span> has not rolled yet.<br>`;
                }
            });
            
            if (rolledPlayerCount === numberOfPlayers && numberOfPlayers > 0 && numberOfPlayers === gameData.maxPlayers) {
                preGameRollResultsDiv.innerHTML += "All players rolled. Host is determining start order...";
            } else if (numberOfPlayers > 0 && numberOfPlayers === gameData.maxPlayers) { 
                let nextPlayerToRollId = null;
                const sortedByJoinOrder = [...allPlayerIdsInOrder].sort((a,b) => (gameData.players[a]?.order || 0) - (gameData.players[b]?.order || 0));

                for (const pid of sortedByJoinOrder) {
                    if (preGameRollsData[pid] === undefined) {
                        nextPlayerToRollId = pid;
                        break;
                    }
                }

                if (nextPlayerToRollId === currentUserId) {
                    preGameRollButton.style.display = 'block';
                    preGameRollButton.textContent = `Your turn, ${gameData.players[currentUserId]?.name || 'Player'}, Roll to Start`;
                    preGameRollButton.disabled = false;
                } else if (nextPlayerToRollId && gameData.players[nextPlayerToRollId]) {
                    preGameRollButton.style.display = 'block'; 
                    preGameRollButton.textContent = `Waiting for ${gameData.players[nextPlayerToRollId].name} to roll...`;
                    preGameRollButton.disabled = true;
                } else if (rolledPlayerCount < numberOfPlayers) { 
                    preGameRollButton.style.display = 'block';
                    preGameRollButton.textContent = `Waiting for players to roll...`;
                    preGameRollButton.disabled = true;
                }
            } else { 
                 preGameRollResultsDiv.innerHTML = "Waiting for all players to join before starting rolls...";
            }
        }

        function updateUkGovDisplay(govMoney) {
            if (ukGovCashSpan) {
                 ukGovCashSpan.textContent = govMoney !== undefined ? govMoney : (localGameData.ukGovMoney || 20000);
            }
        }

        function handleGameEndUI(gameData) {
            if (!gameStatusMessageP || !currentTurnDisplay || !rollDiceButton || !endTurnButton || !buyPropertyButton || !developPropertyButton || !preGameRollArea || !otherActionsContainer) return;
            
            gameStatusMessageP.textContent = gameData.lastActionMessage || "Game Over!";
            currentTurnDisplay.textContent = "Game Over!";
            currentTurnDisplay.style.color = '#e74c3c';

            rollDiceButton.style.display = 'none';
            endTurnButton.style.display = 'none';
            buyPropertyButton.style.display = 'none';
            developPropertyButton.style.display = 'none';
            preGameRollArea.style.display = 'none'; 
            detentionActionsDiv.innerHTML = ''; 

            otherActionsContainer.style.display = 'block'; 
            otherActionsContainer.innerHTML = '<button id="leave-game-button" style="background-color:#c0392b;">Back to Setup</button>';
            const leaveButton = document.getElementById('leave-game-button');
            if (leaveButton) {
                leaveButton.onclick = () => {
                    if (unsubscribeGameState) unsubscribeGameState();
                    resetToSetupScreen();
                };
            }
        }

        function setupBoardFromFirestore(gameData) {
            if (!boardContainer) {
                logEvent("Error: boardContainer DOM element not found in setupBoardFromFirestore.");
                return;
            }
            boardContainer.innerHTML = ''; 
            
            if (gameData.boardLayout && gameData.boardLayout.length > 0) {
                boardLayout = gameData.boardLayout;
            } else {
                logEvent("setupBoardFromFirestore: gameData.boardLayout is missing or empty. Cannot setup board.");
                return;
            }
            
            const dcSpace = boardLayout.find(s => s.name === "Detention Center");
            detentionCenterSpaceId = dcSpace ? dcSpace.id : (boardLayout.find(s => s.type === "detention_visiting")?.id || 8) ;

            const cardDecksCenter = document.createElement('div');
            cardDecksCenter.id = 'card-decks-center';
            const centerImage = document.createElement('img');
            centerImage.id = 'center-board-image';
            centerImage.src = 'migrant3.jpg'; 
            centerImage.alt = 'Migrantopoly Center';
            cardDecksCenter.appendChild(centerImage);
            boardContainer.appendChild(cardDecksCenter);

            const onBoardCardDiv = document.createElement('div');
            onBoardCardDiv.id = 'on-board-card-display'; 
            onBoardCardDiv.style.display = 'none'; 
            onBoardCardDiv.innerHTML = `
                <h4 id="on-board-card-type">Card Type</h4>
                <p id="on-board-card-text">Card text will appear here.</p>
                <button id="on-board-card-ok-button">OK</button> 
            `;
            boardContainer.appendChild(onBoardCardDiv);
            onBoardCardDisplayDiv = document.getElementById('on-board-card-display'); 
            onBoardCardTypeH4 = document.getElementById('on-board-card-type');
            onBoardCardTextP = document.getElementById('on-board-card-text');
            onBoardCardOkButton = document.getElementById('on-board-card-ok-button');

            if (onBoardCardOkButton) {
                onBoardCardOkButton.onclick = () => {
                    onBoardCardDisplayDiv.style.display = 'none';
                    if (localGameData && currentUserId && localGameData.players && localGameData.players[currentUserId]) {
                        updateControlsBasedOnTurn(localGameData); 
                    }
                };
            }


            boardLayout.forEach((s) => {
                const spaceDiv = document.createElement('div');
                spaceDiv.id = `space-${s.id}`;
                spaceDiv.classList.add('space');
                if (s.type === 'go' || s.type === 'detention_visiting' || s.type === 'go_to_detention' || s.type === 'crime_spree') {
                    spaceDiv.classList.add('corner');
                }
                if (['Fake PIP declined', 'Fake ID Cards', "Payout: Job Seeker's"].includes(s.name)) {
                    spaceDiv.classList.add('yellow-boardname');
                }
                if (s.name === "Dole" && s.type === "go"){
                     spaceDiv.classList.add('dole-space');
                     const doleSign = document.createElement('div');
                     doleSign.classList.add('dole-sign');
                     doleSign.textContent = '$'; 
                     spaceDiv.appendChild(doleSign);
                }
                if (s.name === 'Detention Center') {
                    const bars = document.createElement('div'); bars.className = 'detention-bars';
                    for (let b = 0; b < 6; b++) { const bar = document.createElement('div'); bar.className = 'detention-bar'; bars.appendChild(bar); }
                    spaceDiv.appendChild(bars);
                }
                if (s.name === 'Go to Detention Center') {
                    const arrow = document.createElement('div'); arrow.className = 'detention-arrow'; arrow.textContent = 'â†’'; spaceDiv.appendChild(arrow);
                    const subLabel = document.createElement('div'); subLabel.className = 'sub-label'; subLabel.textContent = 'DO NOT PASS DOLE'; spaceDiv.appendChild(subLabel);
                }
                if (s.type === 'property') {
                    spaceDiv.classList.add('property', s.color || s.groupId); 
                    const colorBar = document.createElement('div'); colorBar.classList.add('color-bar');
                    if (["Tesco Cardboard Skip 1", "Tesco Cardboard Skip 2", "Tesco Cardboard Skip 3"].includes(s.name)) {
                        colorBar.style.backgroundColor = '#2196f3'; 
                    }
                    spaceDiv.appendChild(colorBar);
                } else if (s.type === 'set_property') {
                    spaceDiv.classList.add('set-property');
                }
                const nameDiv = document.createElement('div'); nameDiv.classList.add('name');
                if (s.name === 'Detention Center') nameDiv.classList.add('detention-center-name');
                nameDiv.textContent = s.name;
                if (s.type === 'opportunity' || s.type === 'welfare') {
                    nameDiv.style.color = '#ff9800'; 
                }
                spaceDiv.appendChild(nameDiv);

                if (s.type === 'property' && s.rent) { 
                    const devIndicator = document.createElement('div');
                    devIndicator.classList.add('development-indicator');
                    devIndicator.id = `dev-indicator-${s.id}`;
                    spaceDiv.appendChild(devIndicator);
                }
                if (s.price) {
                    const priceDiv = document.createElement('div'); priceDiv.classList.add('price');
                    priceDiv.textContent = `Â£${s.price}`; spaceDiv.appendChild(priceDiv);
                }
                if (s.type === 'property' || s.type === 'set_property') { 
                    const ownerIndicator = document.createElement('div');
                    ownerIndicator.classList.add('owner-indicator');
                    ownerIndicator.id = `owner-indicator-${s.id}`;
                    spaceDiv.appendChild(ownerIndicator);
                }
                
                const currentId = s.id; 
                if (currentId === 0) { spaceDiv.style.gridArea = `1 / 1`; } 
                else if (currentId >= 1 && currentId <= 8) { spaceDiv.style.gridArea = `1 / ${currentId + 1}`; } 
                else if (currentId === 9) { spaceDiv.style.gridArea = `1 / 10`; } 
                else if (currentId >= 10 && currentId <= 17) { spaceDiv.style.gridArea = `${(currentId - 9) + 1} / 10`; } 
                else if (currentId === 18) { spaceDiv.style.gridArea = `10 / 10`; } 
                else if (currentId >= 19 && currentId <= 26) { spaceDiv.style.gridArea = `10 / ${10 - (currentId - 18)}`; } 
                else if (currentId === 27) { spaceDiv.style.gridArea = `10 / 1`; } 
                else if (currentId >= 28 && currentId <= 31) { 
                     spaceDiv.style.gridArea = `${10 - (currentId - 27)} / 1`; 
                } else if (currentId >= 28 && currentId <= 35) { 
                    spaceDiv.style.gridArea = `${10 - (currentId - 27)} / 1`; 
                }

                boardContainer.appendChild(spaceDiv);
            });

            if (gameData.players && gameData.playerOrder) {
                Object.values(gameData.players).forEach(player => {
                    if (player && typeof player.id !== 'undefined' && typeof player.order !== 'undefined') { 
                        let token = document.getElementById(`player-token-${player.id}`);
                        if (!token) { 
                            token = document.createElement('div');
                            token.id = `player-token-${player.id}`; 
                            token.classList.add('player-token');
                        }
                        token.textContent = playerEmojis[player.order % playerEmojis.length];
                        const playerTokenColor = playerColors[player.order % playerColors.length];
                        token.style.color = playerTokenColor;
                        token.style.filter = `drop-shadow(0 0 3px ${playerTokenColor})`;
                        
                        const spaceToPlace = document.getElementById(`space-${player.position}`);
                        if (spaceToPlace) {
                            spaceToPlace.appendChild(token);
                        } else {
                            logEvent(`Warning: Could not find space-${player.position} to place token for ${player.name}`);
                            const goSpace = document.getElementById('space-0'); 
                            if (goSpace) goSpace.appendChild(token);
                        }
                    } else {
                        logEvent("Warning: Invalid player data in setupBoardFromFirestore, skipping token creation/update.", player);
                    }
                });
            } else {
                logEvent("Warning: gameData.players or gameData.playerOrder is missing in setupBoardFromFirestore. Tokens not created.");
            }
            updateBoardDynamicElements(gameData); 
        }
        
        function updateBoardDynamicElements(gameData) {
            if (!gameData || !gameData.players || !gameData.boardLayout) {
                logEvent("updateBoardDynamicElements: Missing critical gameData. Skipping updates.");
                return;
            }

            Object.values(gameData.players).forEach(player => {
                if (!player || typeof player.id === 'undefined') { 
                    logEvent("updateBoardDynamicElements: Invalid player object in players list.", player);
                    return; 
                } 
                const token = document.getElementById(`player-token-${player.id}`);
                if (token) {
                    if (player.isBankrupt) {
                        token.style.display = 'none'; 
                    } else {
                        token.style.display = 'block';
                        const currentSpaceEl = document.getElementById(`space-${player.position}`);
                        if (currentSpaceEl) { 
                            if (token.parentNode !== currentSpaceEl) {
                                currentSpaceEl.appendChild(token); 
                            }
                        } else {
                            logEvent(`updateBoardDynamicElements: Could not find space-${player.position} for token ${player.id}`);
                        }
                    }
                } else {
                    logEvent(`updateBoardDynamicElements: Token not found for player ${player.id}. It should have been created.`);
                }
            });

            if (Array.isArray(gameData.propertyData)) {
                gameData.propertyData.forEach(propInPropertyData => {
                    if (!propInPropertyData || typeof propInPropertyData.id === 'undefined') {
                        logEvent("Warning: Invalid item in propertyData array during UI update, skipping this item.", propInPropertyData);
                        return; 
                    }

                    const ownerIndicator = document.getElementById(`owner-indicator-${propInPropertyData.id}`);
                    if (ownerIndicator) {
                        if (propInPropertyData.owner && gameData.players[propInPropertyData.owner] && !gameData.players[propInPropertyData.owner].isBankrupt) {
                            const ownerData = gameData.players[propInPropertyData.owner];
                            if (ownerData && typeof ownerData.order !== 'undefined') {
                                const ownerColor = playerColors[ownerData.order % playerColors.length];
                                ownerIndicator.style.backgroundColor = ownerColor;
                            } else {
                                 ownerIndicator.style.backgroundColor = 'transparent'; 
                            }
                        } else {
                            ownerIndicator.style.backgroundColor = 'transparent'; 
                        }
                    }

                    const boardSpaceDetails = gameData.boardLayout.find(s => s.id === propInPropertyData.id);
                    if (boardSpaceDetails && boardSpaceDetails.type === 'property') { 
                        const devIndicator = document.getElementById(`dev-indicator-${propInPropertyData.id}`);
                        if (devIndicator) {
                            if (propInPropertyData.permanentResidence) {
                                devIndicator.textContent = "ðŸ¢"; // Hotel/PR
                            } else if (propInPropertyData.tenancies > 0) {
                                devIndicator.textContent = "ðŸ ".repeat(propInPropertyData.tenancies); // Houses
                            } else {
                                devIndicator.textContent = ""; 
                            }
                        }
                    }
                });
            } else {
                logEvent("updateBoardDynamicElements: gameData.propertyData is NOT an array. Property visual updates will be skipped.", gameData.propertyData);
            }
        }

        function showMoneyChangeEffect(amount, type = 'loss') {
            const moneyFlashDivLocal = document.getElementById('money-flash'); 
            if (!moneyFlashDivLocal) {
                logEvent("showMoneyChangeEffect: money-flash div not found.");
                return;
            }

            moneyFlashDivLocal.textContent = `${type === 'loss' ? '-' : '+'}Â£${Math.abs(amount)}`;
            moneyFlashDivLocal.style.color = type === 'loss' ? '#e74c3c' : '#2ecc71'; 

            moneyFlashDivLocal.classList.add('show'); 

            setTimeout(() => {
                moneyFlashDivLocal.classList.remove('show');
            }, 1000); 

            if (audioContextStarted && toneSynth) {
                try {
                    if (type === 'loss') {
                        toneSynth.triggerAttackRelease("A3", "16n", Tone.now());
                        toneSynth.triggerAttackRelease("F#3", "16n", Tone.now() + 0.07);
                    } else { 
                        toneSynth.triggerAttackRelease("C5", "16n", Tone.now());
                        toneSynth.triggerAttackRelease("E5", "16n", Tone.now() + 0.07);
                    }
                } catch (e) {
                    console.error("Money change sound error:", e);
                }
            }
        }


        // --- MAIN UI UPDATE FUNCTION (Calls helpers) ---
        function updateLocalUIFromFirestore(gameData) { 
            if (!currentUserId) {
                logEvent("UpdateLocalUI: currentUserId not set yet, deferring UI update.");
                if(gameStatusMessageP) gameStatusMessageP.textContent = "Authenticating..."; 
                return;
            }

            if (!gameData || Object.keys(gameData).length === 0) {
                logEvent("UpdateLocalUI: No game data received. Cannot update UI.");
                return;
            }
            
            if (gameData.preGamePhase && 
                gameData.status === "active" &&
                gameData.hostId === currentUserId && 
                gameData.playerOrder && gameData.playerOrder.length === gameData.maxPlayers && 
                gameData.preGameRolls &&
                gameData.playerOrder.every(pid => gameData.preGameRolls[pid] !== undefined) 
               ) {
                logEvent("Host detected conditions to finalize pre-game. Calling finalizePreGameAsHost.");
                finalizePreGameAsHost(); 
                return; 
            }

            if (gameData.boardLayout && gameData.boardLayout.length > 0) {
                const boardIsMissingOrDifferent = boardLayout.length === 0 || 
                                                (boardContainer && boardContainer.innerHTML.trim() === '') ||
                                                JSON.stringify(boardLayout) !== JSON.stringify(gameData.boardLayout);
                if (boardIsMissingOrDifferent) {
                    logEvent("UpdateLocalUI: Setting up/refreshing board from Firestore data.");
                    setupBoardFromFirestore(gameData); 
                } else {
                    updateBoardDynamicElements(gameData);
                }
            } else {
                logEvent("UpdateLocalUI: gameData.boardLayout is missing or empty. Board not set up/updated.");
            }

            updateDiceUIDisplay(gameData); 
            updatePlayerInfoPanel(gameData); 
            updateGameStatusPanel(gameData);
            updateControlsBasedOnTurn(gameData); 
            updateUkGovDisplay(gameData.ukGovMoney);

            if (gameData.preGamePhase && gameData.status === "active") { 
                updatePreGameRollUI(gameData);
            } else {
                if(preGameRollArea) preGameRollArea.style.display = 'none';
            }

            if (gameData.status === "finished") {
                handleGameEndUI(gameData);
            } 
        }
        
        // --- ACTION HANDLERS (Dice, Turn, Property, etc.) ---

        async function animatePlayerMove(playerId, startPos, steps, currentBoardLayout) {
            const token = document.getElementById(`player-token-${playerId}`);
            if (!token || !currentBoardLayout || currentBoardLayout.length === 0) return;

            let currentVisualPos = startPos;
            const stepDelay = 200; 

            for (let i = 0; i < steps; i++) {
                currentVisualPos = (currentVisualPos + 1) % currentBoardLayout.length;
                const nextSpaceEl = document.getElementById(`space-${currentVisualPos}`);
                
                if (nextSpaceEl) {
                    nextSpaceEl.appendChild(token); 
                    
                    token.classList.remove('token-arrive-step'); 
                    void token.offsetWidth; 
                    token.classList.add('token-arrive-step');
                }

                if (audioContextStarted && toneSynth) {
                    try {
                        toneSynth.triggerAttackRelease("A5", "32n", Tone.now() + (i * 0.02)); 
                    } catch (e) { 
                        console.error("Token move sound error:", e); 
                    }
                }
                await new Promise(resolve => setTimeout(resolve, stepDelay));
            }
        }

        // --- PAYMENT TRANSACTION FUNCTION ---
        async function makePaymentTransaction(payerId, recipientId, amount, reason = "Payment") {
            logEvent(`makePaymentTransaction initiated: Payer: ${payerId}, Recipient: ${recipientId}, Amount: Â£${amount}, Reason: ${reason}`);
            if (!currentGameId || !db) {
                logEvent("makePaymentTransaction: Missing gameId or db connection.");
                throw new Error("Game connection error for payment.");
            }
            if (amount <= 0) {
                 logEvent("makePaymentTransaction: Amount is zero or negative. No transaction needed.");
                 return { success: true, message: "No payment needed (amount was zero or negative)." }; // Or throw error if this shouldn't happen
            }

            const gameDocRef = doc(db, "games", currentGameId);
            let paymentOutcome = { success: false, message: "Payment processing failed." };

            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) {
                        throw new Error("Game document not found during payment transaction.");
                    }
                    const freshGameData = freshGameDoc.data();
                    let updates = { updatedAt: serverTimestamp() };
                    let messages = [];

                    const payerState = freshGameData.players[payerId];
                    if (!payerState) throw new Error(`Payer ${payerId} not found.`);
                    if (payerState.isBankrupt) {
                         paymentOutcome = { success: true, message: `${payerState.name} is already bankrupt. No payment collected.`};
                         messages.push(paymentOutcome.message);
                         updates.lastActionMessage = messages.join(" ");
                         transaction.update(gameDocRef, updates);
                         return; // Exit transaction early
                    }

                    let actualAmountPaid = amount;
                    if (payerState.money < amount) {
                        actualAmountPaid = payerState.money; // Player pays all they have
                        updates[`players.${payerId}.money`] = 0;
                        updates[`players.${payerId}.isBankrupt`] = true; // Mark as bankrupt
                        messages.push(`${payerState.name} could not afford Â£${amount} for ${reason}. Paid Â£${actualAmountPaid} and is now BANKRUPT!`);
                        logEvent(`${payerState.name} is bankrupt. Assets need to be handled (future implementation).`);
                        // TODO: Implement asset forfeiture (properties to bank/recipient, etc.) in a separate, more complex transaction or phase.
                        // For now, just marking as bankrupt.
                    } else {
                        updates[`players.${payerId}.money`] = payerState.money - amount;
                        messages.push(`${payerState.name} paid Â£${amount} ${recipientId === 'bank' ? 'to the bank' : `to ${freshGameData.players[recipientId]?.name || 'another player'}`} for ${reason}.`);
                    }

                    if (recipientId === 'bank') {
                        updates.bankMoney = (freshGameData.bankMoney || 0) + actualAmountPaid;
                    } else if (recipientId === 'ukGov') {
                        updates.ukGovMoney = (freshGameData.ukGovMoney || 0) + actualAmountPaid; // If paying to UK Gov
                    } else {
                        const recipientState = freshGameData.players[recipientId];
                        if (!recipientState) throw new Error(`Recipient ${recipientId} not found.`);
                        if (!recipientState.isBankrupt) { // Don't pay bankrupt players
                             updates[`players.${recipientId}.money`] = (recipientState.money || 0) + actualAmountPaid;
                        } else {
                            messages.push(`Recipient ${recipientState.name} is bankrupt, payment of Â£${actualAmountPaid} goes to the bank instead.`);
                            updates.bankMoney = (freshGameData.bankMoney || 0) + actualAmountPaid;
                        }
                    }
                    
                    updates.lastActionMessage = messages.join(" ");
                    transaction.update(gameDocRef, updates);
                    paymentOutcome = { success: true, message: updates.lastActionMessage, payerBankrupt: updates[`players.${payerId}.isBankrupt`] || false };
                });
                logEvent("makePaymentTransaction: Transaction successful.", paymentOutcome);
                return paymentOutcome;
            } catch (error) {
                console.error("Error during makePaymentTransaction:", error);
                paymentOutcome = { success: false, message: "Payment transaction failed: " + error.message };
                showMessageModal("Payment Error", paymentOutcome.message); // Show modal for critical payment errors
                return paymentOutcome; // Still return outcome
            }
        }


        async function handleRollDiceAction() {
            if (!currentGameId || !localGameData || !localGameData.playerOrder || localGameData.playerOrder[localGameData.currentPlayerIndex] !== currentUserId) {
                showMessageModal("Not your turn", "It's not your turn to roll the dice.");
                return;
            }
             if (localGameData.preGamePhase) {
                showMessageModal("Game Phase Error", "Cannot roll main dice during pre-game roll phase. Use 'Roll to Start'.");
                return;
            }
            if (localGameData.gamePhase !== "main") {
                showMessageModal("Game Phase Error", "Cannot roll dice before the main game has started.");
                return;
            }
            if (!localGameData.players || !localGameData.players[currentUserId]) {
                 showMessageModal("Error", "Player data not found."); return;
            }
            
            const currentPlayerStateFromLocal = localGameData.players[currentUserId]; 
            if (currentPlayerStateFromLocal.playerActionTakenThisTurn && !(localGameData.lastDiceRoll?.isDoubles && currentPlayerStateFromLocal.doublesRolledInTurn < 3 && currentPlayerStateFromLocal.doublesRolledInTurn > 0)) {
                 showMessageModal("Action Taken", "You've already completed your roll action for this part of the turn.");
                return;
            }
             if (currentPlayerStateFromLocal.inDetention) {
                 showMessageModal("In Detention", "You are in detention. Use detention actions (roll for doubles, pay, or use card).");
                return;
            }

            if(rollDiceButton) rollDiceButton.disabled = true; 

            const die1 = Math.floor(Math.random() * 6) + 1;
            const die2 = Math.floor(Math.random() * 6) + 1;
            const totalRoll = die1 + die2;
            let isDoubles = die1 === die2; 

            if (audioContextStarted && toneSynth) {
                try {
                    toneSynth.triggerAttackRelease("C4", "16n", Tone.now());
                    setTimeout(() => { if (toneSynth) toneSynth.triggerAttackRelease("E4", "16n", Tone.now() + 0.1); }, 100);
                } catch (e) { console.error("Dice roll sound error:", e); }
            }
            
            const playerStartPosForAnim = localGameData.players[currentUserId].position;
            await animatePlayerMove(currentUserId, playerStartPosForAnim, totalRoll, localGameData.boardLayout);

            const gameDocRef = doc(db, "games", currentGameId);
            let landedSpaceIdAfterMove; // To store the ID of the space landed on
            let rentPaymentRequired = false; // Flag if rent payment needs to be handled after this transaction
            let rentPayerId, rentPropertyId; // Store details for rent payment

            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game document not found during roll.");
                    const freshGameData = freshGameDoc.data();
                    
                    const playerState = freshGameData.players[currentUserId]; 
                    if (!playerState || playerState.isBankrupt) throw new Error("Player data missing or bankrupt in Firestore during roll.");
                    if (freshGameData.playerOrder[freshGameData.currentPlayerIndex] !== currentUserId) {
                        throw new Error("Not your turn (checked in transaction).");
                    }
                     if (playerState.inDetention) { 
                        throw new Error("Still in detention (checked in transaction).");
                    }

                    let newPosition = playerState.position; 
                    let messages = [];
                    let updates = {};

                    let currentDoublesCount = playerState.doublesRolledInTurn || 0;
                    if (isDoubles) {
                        currentDoublesCount++;
                    } else {
                        currentDoublesCount = 0; 
                    }
                    updates[`players.${currentUserId}.doublesRolledInTurn`] = currentDoublesCount;
                    
                    if (isDoubles && currentDoublesCount === 3) {
                        messages.push(`${playerState.name} rolled 3 doubles! Sent to Detention.`);
                        newPosition = detentionCenterSpaceId; 
                        updates[`players.${currentUserId}.position`] = newPosition;
                        updates[`players.${currentUserId}.inDetention`] = true;
                        updates[`players.${currentUserId}.missedTurnsInDetention`] = 0; 
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = true; 
                        updates[`players.${currentUserId}.doublesRolledInTurn`] = 0; 
                        landedSpaceIdAfterMove = newPosition; // Store landed space
                    } else {
                        newPosition = (playerState.position + totalRoll) % freshGameData.boardLayout.length;
                        updates[`players.${currentUserId}.position`] = newPosition;
                        landedSpaceIdAfterMove = newPosition; // Store landed space
                        const landedSpace = freshGameData.boardLayout[newPosition];
                        messages.push(`${playerState.name} rolled ${totalRoll} (${die1}, ${die2})${isDoubles ? " (Doubles!)" : ""}. Moved to ${landedSpace.name}.`);

                        let passedGo = false;
                        if (playerState.position + totalRoll >= freshGameData.boardLayout.length && !(isDoubles && currentDoublesCount ===3) && !playerState.inDetention ) {
                             passedGo = true;
                        }
                        if (passedGo) {
                            const goPayout = 400; 
                            updates[`players.${currentUserId}.money`] = (playerState.money || 0) + goPayout;
                            updates.ukGovMoney = (freshGameData.ukGovMoney || 0) - goPayout; 
                            updates[`players.${currentUserId}.govReceived`] = (playerState.govReceived || 0) + goPayout;
                            messages.push(`${playerState.name} passed Dole and collected Â£${goPayout}.`);
                        }

                        // Handle direct effects of landing (taxes, go to jail, etc.)
                        // Rent payment will be handled *after* this transaction if needed.
                        if (landedSpace.type === 'payout' && landedSpace.amount) {
                            const currentMoney = updates[`players.${currentUserId}.money`] !== undefined ? updates[`players.${currentUserId}.money`] : playerState.money;
                            updates[`players.${currentUserId}.money`] = currentMoney + landedSpace.amount;
                            updates.ukGovMoney = (updates.ukGovMoney !== undefined ? updates.ukGovMoney : freshGameData.ukGovMoney) - landedSpace.amount;
                            updates[`players.${currentUserId}.govReceived`] = (updates[`players.${currentUserId}.govReceived`] || playerState.govReceived || 0) + landedSpace.amount;
                            messages.push(`${playerState.name} collected Â£${landedSpace.amount} from ${landedSpace.name}.`);
                        } else if (landedSpace.type === 'tax' && landedSpace.amount) {
                            // Defer actual payment to makePaymentTransaction if complex (e.g. bankruptcy)
                            // For simple tax, can update directly if player has enough, or flag for makePayment
                            const currentMoney = updates[`players.${currentUserId}.money`] !== undefined ? updates[`players.${currentUserId}.money`] : playerState.money;
                            if (currentMoney >= landedSpace.amount) {
                                updates[`players.${currentUserId}.money`] = currentMoney - landedSpace.amount;
                                updates.bankMoney = (freshGameData.bankMoney || 0) + landedSpace.amount;
                                messages.push(`${playerState.name} paid Â£${landedSpace.amount} for ${landedSpace.name}.`);
                            } else {
                                // Not enough for tax, trigger makePayment which will handle bankruptcy
                                // This requires a slightly different flow: this transaction only sets up the situation,
                                // then a follow-up makePaymentTransaction handles the tax.
                                // For now, let's assume tax is paid if possible, or player goes into debt (handled by bankruptcy later)
                                updates[`players.${currentUserId}.money`] = currentMoney - landedSpace.amount; // Player goes into negative, will be bankrupt
                                updates.bankMoney = (freshGameData.bankMoney || 0) + landedSpace.amount;
                                messages.push(`${playerState.name} incurred Â£${landedSpace.amount} tax for ${landedSpace.name}.`);
                                // Bankruptcy check will happen at end of turn or when payment is demanded.
                            }
                        } else if (landedSpace.type === 'crime_spree' && landedSpace.amount) {
                            const currentMoney = updates[`players.${currentUserId}.money`] !== undefined ? updates[`players.${currentUserId}.money`] : playerState.money;
                             if (currentMoney >= landedSpace.amount) {
                                updates[`players.${currentUserId}.money`] = currentMoney - landedSpace.amount;
                                updates.bankMoney = (freshGameData.bankMoney || 0) + landedSpace.amount;
                                messages.push(`${playerState.name} landed on Crime Spree and was fined Â£${landedSpace.amount}!`);
                            } else {
                                updates[`players.${currentUserId}.money`] = currentMoney - landedSpace.amount;
                                updates.bankMoney = (freshGameData.bankMoney || 0) + landedSpace.amount;
                                messages.push(`${playerState.name} fined Â£${landedSpace.amount} for Crime Spree!`);
                            }
                        } else if (landedSpace.type === 'go_to_detention') {
                            updates[`players.${currentUserId}.position`] = detentionCenterSpaceId;
                            updates[`players.${currentUserId}.inDetention`] = true;
                            updates[`players.${currentUserId}.missedTurnsInDetention`] = 0;
                            messages.push(`${playerState.name} was sent to Detention!`);
                            isDoubles = false; 
                            currentDoublesCount = 0; 
                            updates[`players.${currentUserId}.doublesRolledInTurn`] = 0;
                        }
                        
                        // Check for rent AFTER other direct effects of landing are processed by this transaction
                        const propertyDataEntry = freshGameData.propertyData.find(p => p.id === landedSpace.id);
                        if ((landedSpace.type === 'property' || landedSpace.type === 'set_property') && 
                            propertyDataEntry && propertyDataEntry.owner !== null && propertyDataEntry.owner !== currentUserId &&
                            !freshGameData.players[propertyDataEntry.owner]?.isBankrupt) { // Don't pay rent to bankrupt owner
                            
                            rentPaymentRequired = true;
                            rentPayerId = currentUserId;
                            rentPropertyId = landedSpace.id; // Store the ID of the property
                            messages.push(`${playerState.name} landed on ${landedSpace.name}, owned by ${freshGameData.players[propertyDataEntry.owner]?.name || 'another'}. Rent due.`);
                        }
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = !isDoubles; // Only true if not doubles, or if it's the 3rd double (handled above)
                    }
                    
                    updates.lastDiceRoll = { die1, die2, total: totalRoll, isDoubles };
                    updates.lastActionMessage = messages.join(" ");
                    updates.updatedAt = serverTimestamp();
                    transaction.update(gameDocRef, updates);
                });

                // --- Post-Transaction Actions (Rent, Cards) ---
                if (rentPaymentRequired && rentPayerId && rentPropertyId !== undefined) {
                    logEvent(`Post-roll transaction: Rent payment required for property ID ${rentPropertyId} by player ${rentPayerId}.`);
                    // Fetch the latest game data again to ensure `payRent` uses the most current state
                    const gameSnapshot = await getDoc(gameDocRef); 
                    if (gameSnapshot.exists()) {
                        const currentFreshGameData = gameSnapshot.data();
                        const payerStateForRent = currentFreshGameData.players[rentPayerId];
                        const propertyForRentLayout = currentFreshGameData.boardLayout.find(s => s.id === rentPropertyId);
                        const propertyForRentData = currentFreshGameData.propertyData.find(p => p.id === rentPropertyId);

                        if (payerStateForRent && propertyForRentLayout && propertyForRentData && propertyForRentData.owner && propertyForRentData.owner !== rentPayerId) {
                           await payRent(payerStateForRent, propertyForRentData, propertyForRentLayout, currentFreshGameData); // Pass full game data
                        } else {
                            logEvent("Rent payment skipped: Payer, property, or owner data inconsistent after roll transaction.");
                        }
                    }
                }


            } catch (error) {
                console.error("Error during roll dice action transaction:", error);
                showMessageModal("Roll Error", "Could not process roll transaction: " + error.message);
                 if(rollDiceButton) rollDiceButton.disabled = false; // Re-enable button on error
                return; // Important to return here so card drawing doesn't happen on error
            }

            // After transaction and potential rent payment, check for card draw
            // Use a brief timeout to allow Firestore updates from rent to propagate if needed,
            // or rely on onSnapshot to update localGameData before this check.
            // For simplicity, we'll use the landedSpaceId determined in the roll transaction.
            setTimeout(async () => { // Added async here
                const gameDataForCard = localGameData; // Use the latest from onSnapshot
                if (!gameDataForCard || !gameDataForCard.players || !gameDataForCard.players[currentUserId] || landedSpaceIdAfterMove === undefined) return;
                
                const playerForCard = gameDataForCard.players[currentUserId];
                if (playerForCard.isBankrupt || playerForCard.inDetention) return; // Don't draw cards if bankrupt or just sent to jail this move

                const finalLandedSpace = gameDataForCard.boardLayout[landedSpaceIdAfterMove];
                if (!finalLandedSpace) return;

                if (finalLandedSpace.type === 'opportunity' && !rentPaymentRequired) { // Only draw if not busy with rent
                    await drawAndShowOpportunityCard(currentUserId);
                } else if (finalLandedSpace.type === 'welfare' && !rentPaymentRequired) {
                    await drawAndShowWelfareCard(currentUserId);
                }
            }, rentPaymentRequired ? 700 : 350); // Slightly longer delay if rent was processed
        }
        
        async function handleEndTurnAction() {
            logEvent("handleEndTurnAction called."); 

            if (!currentGameId || !localGameData || !currentUserId || !db) {
                logEvent("EndTurn: Exiting - Missing critical global vars."); 
                showMessageModal("Error", "Game data or connection issue.");
                return;
            }

            const gameDataForCheck = localGameData; 
            const currentPlayerId = gameDataForCheck.playerOrder[gameDataForCheck.currentPlayerIndex]; 
            
            if (gameDataForCheck.players && gameDataForCheck.players[currentUserId]) {
                const pState = gameDataForCheck.players[currentUserId];
                logEvent(`EndTurn Initial Check: Player ${currentUserId} (current turn player: ${currentPlayerId})
                    playerActionTakenThisTurn: ${pState.playerActionTakenThisTurn}, 
                    inDetention: ${pState.inDetention},
                    doublesRolledInTurn: ${pState.doublesRolledInTurn},
                    lastDiceRoll.isDoubles: ${gameDataForCheck.lastDiceRoll?.isDoubles}`);
            } else {
                logEvent("EndTurn Initial Check: Player data for currentUserId not found in localGameData.");
            }


            if (currentPlayerId !== currentUserId) { 
                logEvent(`EndTurn: ERROR - It's not your turn! Expected: ${currentPlayerId}, You are: ${currentUserId}.`);
                showMessageModal("Error", "It's not your turn to end.");
                return;
            }

            const playerState = gameDataForCheck.players[currentUserId]; 
            if (!playerState || playerState.isBankrupt) {
                logEvent(`EndTurn: Exiting - Player state error or bankrupt.`);
                // If bankrupt, turn should auto-pass, this manual end should ideally not be needed or allowed.
                // For now, allow if called, but it implies a state issue if a bankrupt player's turn didn't auto-skip.
                if (playerState?.isBankrupt) {
                     // Proceed to pass turn for bankrupt player if somehow their turn didn't auto-skip
                } else {
                    showMessageModal("Error", "Cannot end turn (player state error or bankrupt).");
                    return;
                }
            }
            
            // If player is not bankrupt, check normal end turn conditions
            if (!playerState.isBankrupt) {
                if (gameDataForCheck.lastDiceRoll?.isDoubles && 
                    (playerState.doublesRolledInTurn || 0) > 0 && 
                    (playerState.doublesRolledInTurn || 0) < 3 && 
                    !playerState.inDetention &&
                    !playerState.playerActionTakenThisTurn) { 
                    logEvent("EndTurn: Exiting - Player must roll again (doubles).");
                    showMessageModal("Doubles!", "You rolled doubles, please roll again before ending your turn!");
                    return;
                }
                if (!playerState.playerActionTakenThisTurn && !playerState.inDetention) { 
                    logEvent("EndTurn: Exiting - Player has not taken their main action (e.g., rolled dice). playerActionTakenThisTurn is false.");
                    showMessageModal("Action Required", "You must take an action (e.g., roll dice) before ending your turn.");
                    return;
                }
            }
            
            logEvent("EndTurn: Proceeding to transaction.");
            if(endTurnButton) endTurnButton.disabled = true;

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game not found for end turn.");
                    const freshGameData = freshGameDoc.data();

                    if (freshGameData.playerOrder[freshGameData.currentPlayerIndex] !== currentUserId) {
                        logEvent("EndTurn TXN: Turn already changed. Aborting.");
                        return; 
                    }
                    const freshPlayerState = freshGameData.players[currentUserId];
                     if (!freshPlayerState) { // Bankrupt players can still have their turn ended to pass to next
                        logEvent("EndTurn TXN: Player missing. Aborting.");
                        return; 
                    }

                    if (!freshPlayerState.isBankrupt) { // Only check these for non-bankrupt players
                        if (freshGameData.lastDiceRoll?.isDoubles && 
                            (freshPlayerState.doublesRolledInTurn || 0) > 0 && 
                            (freshPlayerState.doublesRolledInTurn || 0) < 3 &&
                            !freshPlayerState.inDetention &&
                            !freshPlayerState.playerActionTakenThisTurn) { 
                            logEvent("EndTurn TXN: Must roll again (doubles) based on fresh data. Aborting.");
                            return; 
                        }
                         if (!freshPlayerState.playerActionTakenThisTurn && !freshPlayerState.inDetention) {
                            logEvent("EndTurn TXN: Player action not taken in fresh data. Aborting. playerActionTakenThisTurn is false.");
                            return;
                        }
                    }


                    let updates = {};
                    updates[`players.${currentUserId}.playerActionTakenThisTurn`] = false; 
                    updates[`players.${currentUserId}.doublesRolledInTurn`] = 0;      

                    let nextPlayerIndex = (freshGameData.currentPlayerIndex + 1) % freshGameData.playerOrder.length;
                    let nextPlayerId = freshGameData.playerOrder[nextPlayerIndex];
                    let attempts = 0;
                    const maxAttempts = freshGameData.playerOrder.length;

                    while (freshGameData.players[nextPlayerId]?.isBankrupt && attempts < maxAttempts) {
                        logEvent(`EndTurn TXN: Skipping bankrupt player ${freshGameData.players[nextPlayerId]?.name}.`);
                        // Reset their action flags just in case, though they shouldn't get actions
                        updates[`players.${nextPlayerId}.playerActionTakenThisTurn`] = false;
                        updates[`players.${nextPlayerId}.doublesRolledInTurn`] = 0;

                        nextPlayerIndex = (nextPlayerIndex + 1) % freshGameData.playerOrder.length;
                        nextPlayerId = freshGameData.playerOrder[nextPlayerIndex];
                        attempts++;
                    }

                    const nonBankruptPlayers = freshGameData.playerOrder.filter(pid => !freshGameData.players[pid]?.isBankrupt);

                    if (nonBankruptPlayers.length <= 1 && freshGameData.playerOrder.length > 1) { 
                         updates.status = "finished";
                         const winnerName = nonBankruptPlayers.length === 1 ? freshGameData.players[nonBankruptPlayers[0]].name : "No one";
                         updates.lastActionMessage = `Game Over! ${winnerName} is the winner!`;
                         logEvent(`Game ended. Winner: ${winnerName}`);
                    } else if (attempts >= maxAttempts && nonBankruptPlayers.length > 1) { 
                        logEvent("Error in turn progression: Loop completed but non-bankrupt players should exist.");
                        updates.status = "finished"; 
                        updates.lastActionMessage = "Error finding next player. Game Over.";
                    } else if (nonBankruptPlayers.length === 0 && freshGameData.playerOrder.length >=1){ 
                        updates.status = "finished";
                        updates.lastActionMessage = "All players are bankrupt! Game Over!";
                    }
                    else { 
                        updates.currentPlayerIndex = nextPlayerIndex;
                        updates.lastActionMessage = `${freshPlayerState.name} ended their turn. It's now ${freshGameData.players[nextPlayerId].name}'s turn.`;
                        updates.lastDiceRoll = null; 
                    }
                    
                    updates.updatedAt = serverTimestamp();
                    transaction.update(gameDocRef, updates);
                    logEvent(`EndTurn TXN: ${freshPlayerState.name} ended turn. Next is ${nextPlayerId || 'N/A'}.`);
                });
            } catch (error) {
                console.error("Error ending turn (transaction phase):", error);
                showMessageModal("End Turn Error", "Could not end turn: " + error.message);
            } 
        }

        async function handleBuyPropertyAction() {
            logEvent("BuyProp: Action initiated by user: " + currentUserId); 

            if (!currentGameId || !localGameData || !currentUserId || !db) {
                logEvent("BuyProp: Exiting - Missing critical global vars."); 
                showMessageModal("Error", "Game data or connection issue.");
                return;
            }

            const currentSnapshotGameData = localGameData; 
            const currentPlayerIdFromOrder = currentSnapshotGameData.playerOrder[currentSnapshotGameData.currentPlayerIndex];
            logEvent("BuyProp: Current turn player from order: " + currentPlayerIdFromOrder + ", current user: " + currentUserId); 

            if (currentPlayerIdFromOrder !== currentUserId) {
                logEvent(`BuyProp: Exiting - Not current player's turn. Expected: ${currentPlayerIdFromOrder}`); 
                showMessageModal("Error", "Not your turn to buy property.");
                return;
            }

            const playerState = currentSnapshotGameData.players[currentUserId];
            if (!playerState) {
                logEvent("BuyProp: Exiting - Player state not found for user: " + currentUserId); 
                showMessageModal("Error", "Player data not found.");
                return;
            }
            if (playerState.isBankrupt) {
                logEvent(`BuyProp: Exiting - Player ${currentUserId} is bankrupt.`); 
                showMessageModal("Error", "Cannot buy property (player is bankrupt).");
                return;
            }
            
            logEvent("BuyProp: Player state check passed."); 

            if (!currentSnapshotGameData.lastDiceRoll && !playerState.playerActionTakenThisTurn) {
                 logEvent("BuyProp: Exiting - Player has not rolled/landed yet in this turn segment."); 
                 showMessageModal("Action Required", "You must roll and land on a space before buying property.");
                 return;
            }

            const currentPosition = playerState.position;
            const spaceDetails = currentSnapshotGameData.boardLayout[currentPosition];
            logEvent("BuyProp: Attempting to buy space:", { position: currentPosition, spaceDetails }); 

            const propertyDataEntry = Array.isArray(currentSnapshotGameData.propertyData) ? 
                                      currentSnapshotGameData.propertyData.find(p => p.id === currentPosition) : null;

            if (!spaceDetails || !propertyDataEntry || (spaceDetails.type !== 'property' && spaceDetails.type !== 'set_property')) {
                logEvent(`BuyProp: Exiting - Not a buyable property.`); 
                showMessageModal("Invalid Space", "Not a buyable property space.");
                return;
            }

            if (propertyDataEntry.owner) {
                logEvent(`BuyProp: Exiting - Property already owned by ${propertyDataEntry.owner}`); 
                showMessageModal("Owned", `This property (${spaceDetails.name}) is already owned by ${currentSnapshotGameData.players[propertyDataEntry.owner]?.name || 'another player'}.`);
                return;
            }

            let price = spaceDetails.price;
            let usedVoucher = false;
            if (playerState.hasHousingVoucher && spaceDetails.type === 'property') { 
                price = Math.round(price * 0.75);
                usedVoucher = true;
                logEvent("BuyProp: Housing voucher applied. New price: " + price); 
            }

            if (playerState.money < price) {
                logEvent(`BuyProp: Exiting - Insufficient funds. Needs: ${price}, Has: ${playerState.money}`); 
                showMessageModal("Insufficient Funds", `You need Â£${price} to buy ${spaceDetails.name}, but you only have Â£${playerState.money}.`);
                return;
            }
            
            logEvent("BuyProp: All pre-transaction checks passed. Disabling button and starting transaction."); 
            if(buyPropertyButton) buyPropertyButton.disabled = true;

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    logEvent("BuyProp TXN: Inside transaction."); 
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) {
                        logEvent("BuyProp TXN: Game doc not found."); 
                        throw new Error("Game not found for buying property.");
                    }
                    const freshGameData = freshGameDoc.data();
                    logEvent("BuyProp TXN: Fetched fresh game data."); 

                    if (freshGameData.playerOrder[freshGameData.currentPlayerIndex] !== currentUserId) {
                        logEvent("BuyProp TXN: Not player's turn in fresh data."); 
                        throw new Error("Not your turn (checked in transaction).");
                    }
                    const freshPlayerState = freshGameData.players[currentUserId];
                    if (!freshPlayerState || freshPlayerState.isBankrupt) {
                        logEvent("BuyProp TXN: Player state error/bankrupt in fresh data."); 
                        throw new Error("Player error in transaction.");
                    }
                    
                    if (!freshGameData.lastDiceRoll && !freshPlayerState.playerActionTakenThisTurn) {
                         logEvent("BuyProp TXN: Player has not rolled/landed (fresh data)."); 
                         throw new Error("Player action not completed (checked in transaction).");
                    }

                    const freshCurrentPosition = freshPlayerState.position; 
                    const actualSpaceDetails = freshGameData.boardLayout[freshCurrentPosition];
                    logEvent("BuyProp TXN: Fresh player position: " + freshCurrentPosition); 
                    
                    if (!Array.isArray(freshGameData.propertyData)) { 
                        logEvent("BuyProp TXN: propertyData is not an array in fresh data."); 
                        throw new Error("Property data in Firestore is not an array. Cannot buy.");
                    }
                    const freshPropertyDataEntry = freshGameData.propertyData.find(p => p.id === freshCurrentPosition);

                    if (!actualSpaceDetails || !freshPropertyDataEntry || (actualSpaceDetails.type !== 'property' && actualSpaceDetails.type !== 'set_property')) {
                         logEvent("BuyProp TXN: Not a buyable space in fresh data."); 
                         throw new Error("Not a buyable property space (checked in transaction).");
                    }
                    if (freshPropertyDataEntry.owner) {
                        logEvent("BuyProp TXN: Property already owned in fresh data by " + freshPropertyDataEntry.owner); 
                        throw new Error(`Property (${actualSpaceDetails.name}) already owned by ${freshGameData.players[freshPropertyDataEntry.owner]?.name || 'another player'} (checked in transaction).`);
                    }
                    
                    let actualPrice = actualSpaceDetails.price;
                    let actualUsedVoucher = false;
                    if (freshPlayerState.hasHousingVoucher && actualSpaceDetails.type === 'property') {
                        actualPrice = Math.round(actualPrice * 0.75);
                        actualUsedVoucher = true;
                    }
                    if (freshPlayerState.money < actualPrice) {
                         logEvent("BuyProp TXN: Insufficient funds in fresh data."); 
                         throw new Error(`Insufficient funds (Â£${freshPlayerState.money} vs Â£${actualPrice}) for ${actualSpaceDetails.name} (checked in transaction).`);
                    }

                    let updates = {};
                    updates[`players.${currentUserId}.money`] = freshPlayerState.money - actualPrice;
                    updates[`players.${currentUserId}.propertiesOwned`] = arrayUnion(freshCurrentPosition); 
                    if (actualUsedVoucher) {
                        updates[`players.${currentUserId}.hasHousingVoucher`] = false;
                    }
                    
                    const updatedPropertyData = freshGameData.propertyData.map(prop => {
                        if (prop.id === freshCurrentPosition) {
                            return { ...prop, owner: currentUserId };
                        }
                        return prop;
                    });
                    updates.propertyData = updatedPropertyData; 
                    updates.bankMoney = (freshGameData.bankMoney || 0) + actualPrice; // Property price goes to bank

                    updates.lastActionMessage = `${freshPlayerState.name} bought ${actualSpaceDetails.name} for Â£${actualPrice}${actualUsedVoucher ? " (with voucher)" : ""}.`;
                    updates.updatedAt = serverTimestamp();

                    if (!freshGameData.lastDiceRoll?.isDoubles) {
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = true;
                         logEvent("BuyProp TXN: Non-doubles roll, setting playerActionTakenThisTurn to true."); 
                    } else {
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = false; 
                        logEvent("BuyProp TXN: Doubles roll, playerActionTakenThisTurn explicitly set to false to ensure re-roll."); 
                    }


                    transaction.update(gameDocRef, updates);
                    logEvent("BuyProp TXN: Transaction update successful."); 

                    if (audioContextStarted && toneSynth) {
                        try {
                            toneSynth.triggerAttackRelease("A3", "16n", Tone.now()); 
                            toneSynth.triggerAttackRelease("F#3", "16n", Tone.now() + 0.07); 
                        } catch(e){ console.error("Buy property sound error:", e); }
                    }
                });
                logEvent("BuyProp: Transaction completed successfully."); 
            } catch (error) {
                console.error("Error buying property (transaction phase):", error); 
                showMessageModal("Buy Property Error", "Could not buy property: " + error.message);
            } finally {
                 logEvent("BuyProp: Action finished."); 
            }
        }

        async function handlePreGameRollAction() {
            if (!currentGameId || !localGameData || !localGameData.preGamePhase) {
                showMessageModal("Error", "Not in pre-game roll phase.");
                return;
            }
             if (Object.keys(localGameData.players).length < localGameData.maxPlayers) {
                showMessageModal("Waiting", "Waiting for all players to join before rolling.");
                return;
            }
            if (localGameData.preGameRolls && localGameData.preGameRolls[currentUserId] !== undefined) {
                showMessageModal("Already Rolled", "You have already rolled for starting position.");
                return;
            }

            let nextToRollInPreGame = null;
            const sortedByJoinOrderForPreGame = [...localGameData.playerOrder].sort((a,b) => (localGameData.players[a]?.order || 0) - (localGameData.players[b]?.order || 0));
            for (const pid of sortedByJoinOrderForPreGame) {
                if (!localGameData.preGameRolls || localGameData.preGameRolls[pid] === undefined) {
                    nextToRollInPreGame = pid;
                    break;
                }
            }
            if (nextToRollInPreGame !== currentUserId) {
                showMessageModal("Wait", "It's not your turn to roll for starting position.");
                return;
            }


            if(preGameRollButton) preGameRollButton.disabled = true;
            const roll = Math.floor(Math.random() * 6) + 1 + Math.floor(Math.random() * 6) + 1; 

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game not found for pre-game roll.");
                    const freshGameData = freshGameDoc.data();
                     if (!freshGameData.players || !freshGameData.players[currentUserId]) throw new Error("Player data missing in Firestore for pre-game roll.");
                     if (!freshGameData.preGamePhase) throw new Error("Pre-game phase ended."); 
                     if (freshGameData.preGameRolls && freshGameData.preGameRolls[currentUserId] !== undefined) {
                         throw new Error("Already rolled (checked in transaction).");
                     }

                    let updates = {};
                    updates[`preGameRolls.${currentUserId}`] = roll;
                    updates.lastActionMessage = `${freshGameData.players[currentUserId].name} rolled ${roll} for starting order.`;
                    updates.updatedAt = serverTimestamp();

                    const currentPreGameRollsWithThis = { ...(freshGameData.preGameRolls || {}), [currentUserId]: roll };
                    const allPlayersInOrder = freshGameData.playerOrder || [];
                    const allHaveRolled = allPlayersInOrder.length > 0 && 
                                          allPlayersInOrder.length === freshGameData.maxPlayers &&
                                          allPlayersInOrder.every(pid => currentPreGameRollsWithThis[pid] !== undefined);


                    if (allHaveRolled) { 
                        updates.lastActionMessage += " All players rolled.";
                        if (currentUserId === freshGameData.hostId) { 
                            logEvent("Host is the last to roll (or among the last) in pre-game, finalizing directly.");
                            const sortedPlayerIds = [...allPlayersInOrder].sort((a, b) => {
                                const rollA = currentPreGameRollsWithThis[a]; 
                                const rollB = currentPreGameRollsWithThis[b];
                                if (rollB === rollA) { 
                                    return (freshGameData.players[a]?.order || 0) - (freshGameData.players[b]?.order || 0);
                                }
                                return rollB - rollA; 
                            });
                            updates.playerOrder = sortedPlayerIds; 
                            updates.currentPlayerIndex = 0; 
                            updates.preGamePhase = false; 
                            updates.gamePhase = "main"; 
                            updates.status = "active";
                            updates.lastActionMessage = `Starting order determined. ${freshGameData.players[sortedPlayerIds[0]].name} starts!`;
                        } else {
                            updates.lastActionMessage += " Waiting for host to finalize starting order.";
                        }
                    }
                    transaction.update(gameDocRef, updates);
                });
            } catch (error) {
                console.error("Error during pre-game roll:", error);
                showMessageModal("Roll Error", "Could not process pre-game roll: " + error.message);
                if(preGameRollButton) preGameRollButton.disabled = false; 
            }
        }


        // --- Event Listeners ---
        createGameButton.onclick = handleCreateGame;
        joinGameButton.onclick = handleJoinGame;
        rollDiceButton.onclick = handleRollDiceAction; 
        preGameRollButton.onclick = handlePreGameRollAction;
        endTurnButton.onclick = handleEndTurnAction; 
        buyPropertyButton.onclick = handleBuyPropertyAction; 
        developPropertyButton.onclick = () => { 
            if (localGameData && currentUserId && localGameData.players && localGameData.players[currentUserId]) {
                showDevelopPropertyOptions(localGameData.players[currentUserId], localGameData);
            }
        };
        closeDevelopButton.onclick = () => {
            if(developPropertyContainer) developPropertyContainer.style.display = 'none';
        };
        
        generatedGameIdSpan.onclick = () => {
            if (generatedGameIdSpan.textContent) {
                const textArea = document.createElement("textarea");
                textArea.value = generatedGameIdSpan.textContent;
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy'); 
                    showMessageModal("Copied!", "Game ID copied to clipboard.");
                } catch (err) {
                    console.error('Fallback: Oops, unable to copy', err);
                    showMessageModal("Copy Failed", "Could not copy Game ID automatically. Please select and copy manually.");
                }
                document.body.removeChild(textArea);
            }
        };
        
        function shuffleDeck(deck) { 
            let newDeck = [...deck];
            for (let i = newDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newDeck[i], newDeck[j]] = [newDeck[j], newDeck[i]];
            }
            return newDeck;
        }

        function canPlayerDevelopAnyProperty(playerState, gameData) {
            if (!playerState || playerState.isBankrupt || !gameData || !Array.isArray(gameData.propertyData) || !gameData.boardLayout) return false;
            
            return playerState.propertiesOwned.some(propId => { // Changed to propertiesOwned
                const propDetails = gameData.propertyData.find(p => p.id === propId);
                const propLayout = gameData.boardLayout.find(s => s.id === propId);

                if (!propDetails || !propLayout || propLayout.type !== 'property') return false; 
                if (propDetails.owner !== playerState.id || propDetails.permanentResidence) return false; 

                const groupPropertiesLayout = gameData.boardLayout.filter(s => s.groupId === propLayout.groupId && s.type === 'property');
                const ownsAllInGroup = groupPropertiesLayout.every(gpLayout => {
                    const gpDataForCheck = gameData.propertyData.find(pd => pd.id === gpLayout.id);
                    return gpDataForCheck && gpDataForCheck.owner === playerState.id;
                });
                if (!ownsAllInGroup) return false;
                
                // Check if PR can be built (acts as 5th development) or if tenancies can be added
                if (PR_IS_FIFTH_DEVELOPMENT) {
                    return propDetails.tenancies < MAX_TENANCIES_BEFORE_PR || (propDetails.tenancies === MAX_TENANCIES_BEFORE_PR && !propDetails.permanentResidence);
                } else { // Old logic if PR is separate from tenancies
                    return (propDetails.tenancies < MAX_TENANCIES_BEFORE_PR) || (!propDetails.permanentResidence);
                }
            });
        }
        
        function setupDetentionActionsUI(playerState, gameData) {
            if (!playerState || !playerState.inDetention || !detentionActionsDiv) return;
            detentionActionsDiv.innerHTML = ''; 

            const canTakeAction = gameData.playerOrder[gameData.currentPlayerIndex] === currentUserId && !playerState.playerActionTakenThisTurn;

            if (playerState.getOutOfDetentionCards > 0) {
                const useCardBtn = document.createElement('button');
                useCardBtn.textContent = "Use Legal Aid Card";
                useCardBtn.disabled = !canTakeAction;
                useCardBtn.onclick = async () => { 
                    const gameDocRef = doc(db, "games", currentGameId);
                    try {
                        await updateDoc(gameDocRef, {
                            [`players.${currentUserId}.getOutOfDetentionCards`]: playerState.getOutOfDetentionCards - 1,
                            [`players.${currentUserId}.inDetention`]: false,
                            [`players.${currentUserId}.missedTurnsInDetention`]: 0,
                            [`players.${currentUserId}.playerActionTakenThisTurn`]: false, 
                            lastActionMessage: `${playerState.name} used a Legal Aid card and is free. Roll to move.`,
                            updatedAt: serverTimestamp()
                        });
                    } catch (e) { showMessageModal("Error", "Failed to use card: " + e.message); }
                };
                detentionActionsDiv.appendChild(useCardBtn);
            }

            const fineAmount = 50;
            if (playerState.money >= fineAmount) {
                const payFineBtn = document.createElement('button');
                payFineBtn.textContent = `Pay Â£${fineAmount} Fine`;
                payFineBtn.disabled = !canTakeAction;
                payFineBtn.onclick = async () => { 
                    const gameDocRef = doc(db, "games", currentGameId);
                     try {
                        await updateDoc(gameDocRef, {
                            [`players.${currentUserId}.money`]: playerState.money - fineAmount,
                            [`players.${currentUserId}.inDetention`]: false,
                            [`players.${currentUserId}.missedTurnsInDetention`]: 0,
                            [`players.${currentUserId}.playerActionTakenThisTurn`]: false, 
                            bankMoney: (gameData.bankMoney || 0) + fineAmount, 
                            lastActionMessage: `${playerState.name} paid Â£${fineAmount} fine and is free. Roll to move.`,
                            updatedAt: serverTimestamp()
                        });
                    } catch (e) { showMessageModal("Error", "Failed to pay fine: " + e.message); }
                };
                detentionActionsDiv.appendChild(payFineBtn);
            }

            const rollDoublesBtn = document.createElement('button');
            rollDoublesBtn.textContent = "Roll for Doubles (Exit Jail)";
            rollDoublesBtn.disabled = !canTakeAction;
            rollDoublesBtn.onclick = async () => { 
                const die1 = Math.floor(Math.random() * 6) + 1;
                const die2 = Math.floor(Math.random() * 6) + 1;
                const isDoubles = die1 === die2;
                const totalRoll = die1 + die2; 
                
                const gameDocRef = doc(db, "games", currentGameId);
                let updates = { updatedAt: serverTimestamp(), lastDiceRoll: {die1, die2, total: totalRoll, isDoubles: isDoubles} }; 
                let missedTurns = playerState.missedTurnsInDetention || 0;

                if (isDoubles) {
                    updates[`players.${currentUserId}.inDetention`] = false;
                    updates[`players.${currentUserId}.missedTurnsInDetention`] = 0;
                    updates[`players.${currentUserId}.playerActionTakenThisTurn`] = false; 
                    updates.lastActionMessage = `${playerState.name} rolled doubles (${die1},${die2}) and is out of Detention! Roll again to move.`;
                } else {
                    missedTurns++;
                    updates[`players.${currentUserId}.missedTurnsInDetention`] = missedTurns;
                    updates[`players.${currentUserId}.playerActionTakenThisTurn`] = true; 
                    if (missedTurns >= 3) {
                        updates[`players.${currentUserId}.inDetention`] = false; 
                        updates[`players.${currentUserId}.missedTurnsInDetention`] = 0;
                        // Auto-pay fine
                        if (playerState.money >= fineAmount) {
                            updates[`players.${currentUserId}.money`] = (playerState.money || 0) - fineAmount; 
                            updates.bankMoney = (gameData.bankMoney || 0) + fineAmount;
                            updates.lastActionMessage = `${playerState.name} failed to roll doubles for 3 turns, paid Â£${fineAmount} fine and is out. Must roll to move on their next turn.`;
                        } else { // Not enough to pay fine - BANKRUPTCY due to jail fine
                            updates[`players.${currentUserId}.money`] = 0;
                            updates.bankMoney = (gameData.bankMoney || 0) + playerState.money; // Bank gets what player had
                            updates[`players.${currentUserId}.isBankrupt`] = true;
                            updates.lastActionMessage = `${playerState.name} failed to roll doubles for 3 turns, couldn't pay Â£${fineAmount} fine, and is BANKRUPT!`;
                        }
                        updates[`players.${currentUserId}.playerActionTakenThisTurn`] = false; // Allow roll next turn if not bankrupt
                    } else {
                        updates.lastActionMessage = `${playerState.name} failed to roll doubles (${die1},${die2}) in detention. Still in detention. ${3 - missedTurns} attempt(s) left.`;
                    }
                }
                 try {
                    await updateDoc(gameDocRef, updates);
                } catch (e) { showMessageModal("Error", "Failed to roll for doubles in detention: " + e.message); }
            };
            detentionActionsDiv.appendChild(rollDoublesBtn);
        }

        function showDevelopPropertyOptions(playerState, gameData) {
            if (!developPropertyContainer || !developPropertyOptionsDiv || !developPropertyNameH3) return;

            developPropertyOptionsDiv.innerHTML = ''; 
            developPropertyNameH3.textContent = "Develop Property"; 

            let canDevelopAnything = false;

            playerState.propertiesOwned.forEach(propId => { // Changed to propertiesOwned
                const propLayout = gameData.boardLayout.find(s => s.id === propId);
                const propData = gameData.propertyData.find(p => p.id === propId);

                if (propLayout && propData && propLayout.type === 'property' && propData.owner === playerState.id) {
                    const groupPropertiesLayout = gameData.boardLayout.filter(s => s.groupId === propLayout.groupId && s.type === 'property');
                    const ownsAllInGroup = groupPropertiesLayout.every(gpLayout => {
                        const gpDataForCheck = gameData.propertyData.find(pd => pd.id === gpLayout.id);
                        return gpDataForCheck && gpDataForCheck.owner === playerState.id;
                    });

                    if (ownsAllInGroup) {
                        const houseCost = propLayout.houseCost || 50; // Default if not specified
                        if (!propData.permanentResidence && propData.tenancies < MAX_TENANCIES_BEFORE_PR) {
                            const addTenancyButton = document.createElement('button');
                            addTenancyButton.textContent = `Add Tenancy to ${propLayout.name} (Â£${houseCost})`;
                            addTenancyButton.disabled = playerState.money < houseCost;
                            addTenancyButton.onclick = () => handleConfirmDevelopment(propId, 'tenancy', houseCost);
                            developPropertyOptionsDiv.appendChild(addTenancyButton);
                            canDevelopAnything = true;
                        }
                        // PR is the 5th development (like a hotel)
                        if (PR_IS_FIFTH_DEVELOPMENT && !propData.permanentResidence && propData.tenancies === MAX_TENANCIES_BEFORE_PR) {
                            const buildPRButton = document.createElement('button');
                            buildPRButton.textContent = `Build PR on ${propLayout.name} (Â£${houseCost})`; // PR cost is same as house cost
                            buildPRButton.disabled = playerState.money < houseCost;
                            buildPRButton.onclick = () => handleConfirmDevelopment(propId, 'pr', houseCost);
                            developPropertyOptionsDiv.appendChild(buildPRButton);
                            canDevelopAnything = true;
                        }
                    }
                }
            });

            if (!canDevelopAnything) {
                developPropertyOptionsDiv.innerHTML = '<p>No properties currently eligible for development.</p>';
            }
            developPropertyContainer.style.display = 'block';
        }

        async function handleConfirmDevelopment(propertyId, developmentType, cost) { // Added cost parameter
            logEvent(`handleConfirmDevelopment called for prop: ${propertyId}, type: ${developmentType}, cost: ${cost}`);
            if (!currentGameId || !localGameData || !currentUserId || !db) {
                showMessageModal("Error", "Game data or connection issue.");
                return;
            }

            const gameDocRef = doc(db, "games", currentGameId);
            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game not found for development.");
                    
                    const freshGameData = freshGameDoc.data();
                    const playerState = freshGameData.players[currentUserId];
                    const propLayout = freshGameData.boardLayout.find(s => s.id === propertyId);
                    const propDataIndex = freshGameData.propertyData.findIndex(p => p.id === propertyId);

                    if (propDataIndex === -1 || !propLayout || !playerState) {
                        throw new Error("Property or player data not found for development.");
                    }
                    const propData = freshGameData.propertyData[propDataIndex];

                    if (freshGameData.playerOrder[freshGameData.currentPlayerIndex] !== currentUserId) {
                        throw new Error("Not your turn to develop.");
                    }
                    if (propData.owner !== currentUserId) {
                        throw new Error("You do not own this property.");
                    }
                    if (propLayout.type !== 'property') {
                        throw new Error("This type of property cannot be developed.");
                    }

                    const groupPropertiesLayout = freshGameData.boardLayout.filter(s => s.groupId === propLayout.groupId && s.type === 'property');
                    const ownsAllInGroup = groupPropertiesLayout.every(gpLayout => {
                        const gpDataForCheck = freshGameData.propertyData.find(pd => pd.id === gpLayout.id);
                        return gpDataForCheck && gpDataForCheck.owner === currentUserId;
                    });
                    if (!ownsAllInGroup) {
                        throw new Error(`You must own all properties in the ${propLayout.color || propLayout.groupId} group to develop.`);
                    }

                    let newTenancies = propData.tenancies;
                    let newPR = propData.permanentResidence;
                    let developmentMessage = "";

                    if (developmentType === 'tenancy') {
                        if (propData.permanentResidence) throw new Error("Cannot add tenancies to a property with Permanent Residence.");
                        if (propData.tenancies >= MAX_TENANCIES_BEFORE_PR) throw new Error("Maximum tenancies reached before PR.");
                        newTenancies++;
                        developmentMessage = `added a tenancy to ${propLayout.name}`;
                    } else if (developmentType === 'pr') {
                        if (!PR_IS_FIFTH_DEVELOPMENT || propData.permanentResidence) throw new Error("Permanent Residence already built or not applicable.");
                        if (propData.tenancies < MAX_TENANCIES_BEFORE_PR) throw new Error(`Must have ${MAX_TENANCIES_BEFORE_PR} tenancies to build PR.`);
                        newPR = true; // Build PR
                        // Tenancies remain at MAX_TENANCIES_BEFORE_PR conceptually, PR replaces them visually/for rent
                        developmentMessage = `built Permanent Residence on ${propLayout.name}`;
                    } else {
                        throw new Error("Invalid development type.");
                    }

                    if (playerState.money < cost) {
                        throw new Error(`Insufficient funds. Need Â£${cost}.`);
                    }

                    const updates = {};
                    updates[`players.${currentUserId}.money`] = playerState.money - cost;
                    
                    const updatedPropertyDataArray = freshGameData.propertyData.map((p, index) => {
                        if (index === propDataIndex) {
                            return { ...p, tenancies: newTenancies, permanentResidence: newPR };
                        }
                        return p;
                    });
                    updates.propertyData = updatedPropertyDataArray;
                    updates.bankMoney = (freshGameData.bankMoney || 0) + cost; // Development cost goes to bank
                    
                    updates.lastActionMessage = `${playerState.name} ${developmentMessage} for Â£${cost}.`;
                    updates.updatedAt = serverTimestamp();
                    
                    transaction.update(gameDocRef, updates);
                    logEvent("Development successful in transaction:", updates);
                });

                developPropertyContainer.style.display = 'none'; 

            } catch (error) {
                console.error("Error confirming development:", error);
                showMessageModal("Development Error", error.message);
            }
        }


        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', async () => {
            if (firebaseConfigToUse.apiKey === "YOUR_API_KEY" || !firebaseConfigToUse.projectId) {
                 onlineSetupMessage.textContent = "CRITICAL: Firebase is not configured. Please update firebaseConfigToUse in the script.";
                 console.error("CRITICAL: Firebase configuration is a placeholder. Update it with your actual Firebase project details.");
                 createGameButton.disabled = true;
                 joinGameButton.disabled = true;
                 showMessageModal("SETUP REQUIRED", "Firebase is not configured. Online features are disabled. See console for details.");
                 return; 
            }
            reformatBoardLayout(); 
            await initializeFirebase();
            
            const overlay = document.querySelector('.overlay');
            if(overlay) overlay.style.display = 'none';
        });

        document.body.addEventListener('click', async () => {
            if (!audioContextStarted && typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                try {
                    await Tone.start();
                    audioContextStarted = true;
                    logEvent("AudioContext started by user interaction.");
                    if (!toneSynth) { 
                        toneSynth = new Tone.Synth({
                            oscillator: { type: "triangle" }, 
                            envelope: { attack: 0.005, decay: 0.1, sustain: 0.2, release: 0.3 }
                        }).toDestination();
                        logEvent("Tone.Synth initialized.");
                    }
                } catch (e) { 
                    console.error("Error starting Tone.js AudioContext or initializing synth:", e); 
                }
            }
        }, { once: true }); 

        // --- Card Draw and Action Logic ---
        async function setCurrentCardDraw(card, type, playerId) {
            const gameDocRef = doc(db, "games", currentGameId);
            await updateDoc(gameDocRef, {
                currentCardDraw: {
                    id: `${Date.now()}_${Math.random().toString(36).substr(2,5)}`,
                    type,
                    text: card.text,
                    action: card.action,
                    amount: card.amount || null, // Ensure amount is present or null
                    amountPerTenancy: card.amountPerTenancy || null,
                    amountPerPR: card.amountPerPR || null,
                    playerId,
                },
                updatedAt: serverTimestamp(),
            });
        }

        function showCardModal(card, type, onOkCallback) {
            if (!onBoardCardDisplayDiv || !onBoardCardTypeH4 || !onBoardCardTextP || !onBoardCardOkButton) return;
            onBoardCardTypeH4.textContent = `${type} Card`;
            onBoardCardTextP.textContent = card.text;
            onBoardCardDisplayDiv.style.display = 'flex';
            
            // Ensure OK button is only clickable by the player who drew the card, or host for AI
            const playerWhoDrew = localGameData.players[card.playerId];
            const amIEligibleToClickOk = card.playerId === currentUserId || (playerWhoDrew?.isAI && currentUserId === localGameData.hostId);

            onBoardCardOkButton.disabled = !amIEligibleToClickOk;
            onBoardCardOkButton.onclick = () => {
                if (!amIEligibleToClickOk) return; // Extra safety
                onBoardCardDisplayDiv.style.display = 'none';
                if (onOkCallback) onOkCallback();
            };
        }


        async function drawAndShowOpportunityCard(playerId) {
            const gameData = localGameData; // Use localGameData for current deck state
            if (!gameData || !gameData.shuffledOpportunityCards) {
                logEvent("drawAndShowOpportunityCard: Missing gameData or shuffledOpportunityCards.");
                return;
            }
            let cardIndex = gameData.opportunityCardIndex || 0;
            let deck = [...gameData.shuffledOpportunityCards]; 

            if (cardIndex >= deck.length) {
                logEvent("Reshuffling Opportunity Deck");
                deck = shuffleDeck([...opportunityCards]); 
                cardIndex = 0;
                 // Update Firestore with the newly shuffled deck immediately if reshuffled
                await updateDoc(doc(db, "games", currentGameId), { 
                    shuffledOpportunityCards: deck, 
                    opportunityCardIndex: 0 
                });
            }
            const card = deck[cardIndex];
            await setCurrentCardDraw(card, 'Opportunity', playerId); 
            // Update deck index in Firestore AFTER setting the current card draw
            await updateDoc(doc(db, "games", currentGameId), {
                opportunityCardIndex: cardIndex + 1,
                // No need to update shuffledOpportunityCards here again if not reshuffled
            });
        }

        async function drawAndShowWelfareCard(playerId) {
            const gameData = localGameData;
            if (!gameData || !gameData.shuffledWelfareCards) {
                logEvent("drawAndShowWelfareCard: Missing gameData or shuffledWelfareCards.");
                return;
            }
            let cardIndex = gameData.welfareCardIndex || 0;
            let deck = [...gameData.shuffledWelfareCards];

            if (cardIndex >= deck.length) {
                logEvent("Reshuffling Welfare Deck");
                deck = shuffleDeck([...welfareCards]);
                cardIndex = 0;
                await updateDoc(doc(db, "games", currentGameId), { 
                    shuffledWelfareCards: deck,
                    welfareCardIndex: 0 
                });
            }
            const card = deck[cardIndex];
            await setCurrentCardDraw(card, 'Welfare', playerId);
            await updateDoc(doc(db, "games", currentGameId), {
                welfareCardIndex: cardIndex + 1,
            });
        }


        async function applyCardAction(card, playerId, deckType) {
            logEvent(`Applying card action: ${card.action} for player ${playerId}`, card);
            const gameDocRef = doc(db, "games", currentGameId);

            try {
                await runTransaction(db, async (transaction) => {
                    const freshGameDoc = await transaction.get(gameDocRef);
                    if (!freshGameDoc.exists()) throw new Error("Game not found for card action.");
                    const freshGameData = freshGameDoc.data();
                    const playerState = freshGameData.players[playerId];
                    if (!playerState || playerState.isBankrupt) {
                        logEvent(`Card action for ${playerId} skipped: Player not found or bankrupt.`);
                        // Still need to clear the card draw even if action is skipped for bankrupt player
                        transaction.update(gameDocRef, { currentCardDraw: null, updatedAt: serverTimestamp(), lastActionMessage: `${playerState?.name || 'A player'} drew: ${card.text} (No action due to bankruptcy/state)` });
                        return;
                    }

                    let updates = { updatedAt: serverTimestamp() };
                    let messages = [`${playerState.name} drew (${deckType}): "${card.text}"`];
                    let paymentResult;

                    switch(card.action) {
                        case 'collect':
                            updates[`players.${playerId}.money`] = (playerState.money || 0) + (card.amount || 0);
                            messages.push(`Collected Â£${card.amount}.`);
                            break;
                        case 'pay':
                             // Use makePaymentTransaction for robust payment handling including bankruptcy
                            // This is tricky because makePaymentTransaction is itself a transaction.
                            // For now, we'll do a direct update, but this could be refactored.
                            // A simpler approach for cards is direct debit/credit if player has funds,
                            // or a specific "demand payment" state if they don't.
                            const costToPay = card.amount || 0;
                            if (playerState.money >= costToPay) {
                                updates[`players.${playerId}.money`] = playerState.money - costToPay;
                                updates.bankMoney = (freshGameData.bankMoney || 0) + costToPay; // Card payments usually go to bank
                                messages.push(`Paid Â£${costToPay} to the bank.`);
                            } else { // Not enough money
                                updates.bankMoney = (freshGameData.bankMoney || 0) + playerState.money; // Bank gets what player has
                                updates[`players.${playerId}.money`] = 0;
                                updates[`players.${playerId}.isBankrupt`] = true;
                                messages.push(`Could not afford Â£${costToPay}, paid Â£${playerState.money} and is BANKRUPT!`);
                            }
                            break;
                        case 'getOutOfDetentionFree':
                            updates[`players.${playerId}.getOutOfDetentionCards`] = (playerState.getOutOfDetentionCards || 0) + 1;
                            messages.push(`Received a Legal Aid card.`);
                            break;
                        case 'gainHealthService':
                            updates[`players.${playerId}.healthServices`] = (playerState.healthServices || 0) + 1;
                            messages.push(`Gained a Health Service.`);
                            break;
                        case 'payPerDevelopment':
                            let totalDevelopmentCost = 0;
                            playerState.propertiesOwned.forEach(propId => {
                                const propData = freshGameData.propertyData.find(p => p.id === propId);
                                if (propData) {
                                    totalDevelopmentCost += (propData.tenancies || 0) * (card.amountPerTenancy || 0);
                                    if (propData.permanentResidence) {
                                        totalDevelopmentCost += (card.amountPerPR || 0);
                                    }
                                }
                            });
                            if (totalDevelopmentCost > 0) {
                                if (playerState.money >= totalDevelopmentCost) {
                                    updates[`players.${playerId}.money`] = playerState.money - totalDevelopmentCost;
                                    updates.bankMoney = (freshGameData.bankMoney || 0) + totalDevelopmentCost;
                                    messages.push(`Paid Â£${totalDevelopmentCost} for housing inspection.`);
                                } else {
                                    updates.bankMoney = (freshGameData.bankMoney || 0) + playerState.money;
                                    updates[`players.${playerId}.money`] = 0;
                                    updates[`players.${playerId}.isBankrupt`] = true;
                                    messages.push(`Could not afford housing inspection of Â£${totalDevelopmentCost}, paid Â£${playerState.money} and is BANKRUPT!`);
                                }
                            } else {
                                messages.push(`No developed properties, no inspection fee.`);
                            }
                            break;
                        case 'moveToNearestPayout':
                            let currentPos = playerState.position;
                            let nearestPayoutId = -1;
                            let minDistance = freshGameData.boardLayout.length;
                            freshGameData.boardLayout.forEach(space => {
                                if (space.type === 'payout') {
                                    let dist = (space.id - currentPos + freshGameData.boardLayout.length) % freshGameData.boardLayout.length;
                                    if (dist === 0) dist = freshGameData.boardLayout.length; // If on payout, move to next one (full lap)
                                    if (dist < minDistance) {
                                        minDistance = dist;
                                        nearestPayoutId = space.id;
                                    }
                                }
                            });
                            if (nearestPayoutId !== -1) {
                                updates[`players.${playerId}.position`] = nearestPayoutId;
                                messages.push(`Moved to ${freshGameData.boardLayout[nearestPayoutId].name}.`);
                                // Payout itself is handled by landing logic if not already handled here
                                const payoutSpace = freshGameData.boardLayout[nearestPayoutId];
                                if (payoutSpace.amount) {
                                     updates[`players.${playerId}.money`] = (updates[`players.${playerId}.money`] || playerState.money) + payoutSpace.amount;
                                     updates.ukGovMoney = (updates.ukGovMoney || freshGameData.ukGovMoney) - payoutSpace.amount;
                                     updates[`players.${playerId}.govReceived`] = (updates[`players.${playerId}.govReceived`] || playerState.govReceived || 0) + payoutSpace.amount;
                                     messages.push(`Collected Â£${payoutSpace.amount}.`);
                                }
                            }
                            break;
                        case 'goToDetentionDirect':
                            updates[`players.${playerId}.position`] = detentionCenterSpaceId;
                            updates[`players.${playerId}.inDetention`] = true;
                            updates[`players.${playerId}.missedTurnsInDetention`] = 0;
                            updates[`players.${playerId}.doublesRolledInTurn`] = 0; // Cancel any doubles streak
                            updates[`players.${playerId}.playerActionTakenThisTurn`] = true; // End turn for this player
                            messages.push(`Sent directly to Detention Center.`);
                            break;
                        case 'housingVoucher':
                            updates[`players.${playerId}.hasHousingVoucher`] = true;
                            messages.push(`Received a Housing Voucher (25% off next estate).`);
                            break;
                        case 'collectFromPlayers':
                            const amountPerPlayer = card.amount || 0;
                            let totalCollectedFromOthers = 0;
                            freshGameData.playerOrder.forEach(otherPlayerId => {
                                if (otherPlayerId !== playerId) {
                                    const otherPlayerState = freshGameData.players[otherPlayerId];
                                    if (otherPlayerState && !otherPlayerState.isBankrupt) {
                                        if (otherPlayerState.money >= amountPerPlayer) {
                                            updates[`players.${otherPlayerId}.money`] = otherPlayerState.money - amountPerPlayer;
                                            totalCollectedFromOthers += amountPerPlayer;
                                        } else { // Other player doesn't have enough
                                            totalCollectedFromOthers += otherPlayerState.money;
                                            updates[`players.${otherPlayerId}.money`] = 0;
                                            updates[`players.${otherPlayerId}.isBankrupt`] = true; // They go bankrupt
                                            messages.push(`${otherPlayerState.name} couldn't pay Â£${amountPerPlayer} and is BANKRUPT!`);
                                        }
                                    }
                                }
                            });
                            updates[`players.${playerId}.money`] = (playerState.money || 0) + totalCollectedFromOthers;
                            messages.push(`Collected a total of Â£${totalCollectedFromOthers} from other players.`);
                            break;
                        case 'advanceToGo':
                            const oldPosForGo = playerState.position;
                            updates[`players.${playerId}.position`] = 0; // Dole space ID
                            messages.push(`Advanced to Dole.`);
                            // Collect GO money only if they actually pass/land on GO from a previous position
                            // This card implies they collect the GO salary regardless of passing.
                            const goSalary = 400;
                            updates[`players.${playerId}.money`] = (updates[`players.${playerId}.money`] !== undefined ? updates[`players.${playerId}.money`] : playerState.money) + goSalary;
                            updates.ukGovMoney = (updates.ukGovMoney !== undefined ? updates.ukGovMoney : freshGameData.ukGovMoney) - goSalary;
                            updates[`players.${playerId}.govReceived`] = (updates[`players.${playerId}.govReceived`] || playerState.govReceived || 0) + goSalary;
                            messages.push(`Collected Â£${goSalary}.`);
                            break;
                        default:
                            messages.push(`(Action '${card.action}' not fully implemented).`);
                            logEvent("Unknown or not-yet-implemented card action:", card.action);
                    }

                    updates.lastActionMessage = messages.join(" ");
                    updates.currentCardDraw = null; // Clear the card after processing its action
                    transaction.update(gameDocRef, updates);
                });
                logEvent("Card action transaction completed.");
            } catch (error) {
                console.error("Error applying card action (transaction phase):", error);
                showMessageModal("Card Action Error", "Could not apply card effect: " + error.message);
                 // Still try to clear the card draw to prevent re-processing
                await updateDoc(gameDocRef, { currentCardDraw: null, updatedAt: serverTimestamp(), lastActionMessage: `Error processing card: ${card.text}` });
            }
        }

        function calculateSpecialSetRent(propertyLayout, ownerId, gameData) {
            // propertyLayout is from boardLayout, ownerId is the ID of the property owner
            // gameData contains propertyData and players
            if (!propertyLayout || propertyLayout.groupId !== 'special_set' || !gameData || !gameData.propertyData) return 0;
            
            const ownedSpecialPropertiesCount = gameData.propertyData.filter(pData => {
                const pLayout = gameData.boardLayout.find(s => s.id === pData.id);
                return pLayout && pLayout.groupId === 'special_set' && pData.owner === ownerId;
            }).length;
            
            const baseRentPerProperty = propertyLayout.rent_base || 25; // Default if not set
            // Rent is typically baseRent * number of utilities/railroads owned.
            // For this game, let's say: 1 owned = base, 2 owned = 2*base, 3 owned = 4*base, 4 owned = 8*base (Monopoly railroad style)
            if (ownedSpecialPropertiesCount === 0) return 0;
            if (ownedSpecialPropertiesCount === 1) return baseRentPerProperty;
            if (ownedSpecialPropertiesCount === 2) return baseRentPerProperty * 2;
            if (ownedSpecialPropertiesCount === 3) return baseRentPerProperty * 4;
            if (ownedSpecialPropertiesCount >= 4) return baseRentPerProperty * 8; // Max for 4
            return 0;
        }

        async function payRent(payerState, propertyDataEntry, propertyLayoutDetails, gameData) {
            // payerState is the full object of the player landing on the property
            // propertyDataEntry is the entry from gameData.propertyData for the landed property
            // propertyLayoutDetails is the entry from gameData.boardLayout for the landed property
            // gameData is the full current game state
            if (payerState.isBankrupt) {
                logEvent(`Rent skipped: Payer ${payerState.name} is already bankrupt.`);
                return;
            }

            const ownerId = propertyDataEntry.owner;
            if (!ownerId || ownerId === payerState.id) { // No owner or self-owned
                return;
            }

            const ownerState = gameData.players[ownerId];
            if (!ownerState || ownerState.isBankrupt) {
                logEvent(`Rent skipped: Owner ${ownerState?.name || `ID ${ownerId}`} is bankrupt or not found for ${propertyLayoutDetails.name}.`);
                return;
            }

            let rentAmount = 0;

            if (propertyLayoutDetails.type === "set_property") {
                rentAmount = calculateSpecialSetRent(propertyLayoutDetails, ownerId, gameData);
                logEvent(`${payerState.name} owes Â£${rentAmount} rent to ${ownerState.name} for ${propertyLayoutDetails.name} (Special Set).`);
            } else if (propertyLayoutDetails.type === "property") {
                const groupPropertiesLayout = gameData.boardLayout.filter(s => s.groupId === propertyLayoutDetails.groupId && s.type === 'property');
                const ownerOwnsAllInGroup = groupPropertiesLayout.every(gpLayout => {
                    const gpDataForCheck = gameData.propertyData.find(pd => pd.id === gpLayout.id);
                    return gpDataForCheck && gpDataForCheck.owner === ownerId;
                });

                if (propertyDataEntry.permanentResidence) { // Hotel equivalent
                    rentAmount = propertyLayoutDetails.rent[MAX_TENANCIES_BEFORE_PR + 1] || propertyLayoutDetails.rent[propertyLayoutDetails.rent.length -1]; // Last rent tier for PR
                } else if (propertyDataEntry.tenancies > 0) { // Houses
                    rentAmount = propertyLayoutDetails.rent[propertyDataEntry.tenancies] || 0;
                } else { // No developments
                    rentAmount = propertyLayoutDetails.rent[0] || 0; // Base rent
                    if (ownerOwnsAllInGroup) {
                        rentAmount *= 2; // Double rent if all in group are owned and unimproved
                        logEvent(`Rent for ${propertyLayoutDetails.name} is doubled to Â£${rentAmount} (unimproved, owns all in group).`);
                    }
                }
                logEvent(`${payerState.name} owes Â£${rentAmount} rent to ${ownerState.name} for ${propertyLayoutDetails.name} (Tenancies: ${propertyDataEntry.tenancies}, PR: ${propertyDataEntry.permanentResidence}).`);
            } else {
                logEvent(`Cannot calculate rent for ${propertyLayoutDetails.name} - unknown type or configuration.`);
                return;
            }

            if (rentAmount > 0) {
                const paymentDetails = await makePaymentTransaction(payerState.id, ownerId, rentAmount, `rent for ${propertyLayoutDetails.name}`);
                // Further actions based on paymentDetails.payerBankrupt can be handled here if needed,
                // like triggering asset forfeiture, though that's a more advanced step.
                logEvent(`Rent payment outcome for ${payerState.name}: ${paymentDetails.message}`);
            } else {
                logEvent(`Calculated rent is Â£0 for ${propertyLayoutDetails.name}. No payment made.`);
            }
        }

    </script>
  </div>
</body>
</html>
